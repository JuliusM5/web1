{"ast":null,"code":"// src/services/subscriptionService.js\n\nconst TokenizedSubscription = require('../models/TokenizedSubscription');\n// Or use the in-memory version for development\n// const TokenizedSubscription = require('../models/inMemoryTokenizedSubscription');\n\nconst appleReceiptVerifier = require('./platforms/appleReceiptVerifier');\nconst googleReceiptVerifier = require('./platforms/googleReceiptVerifier');\n\n/**\r\n * Service for managing accountless subscriptions\r\n */\nclass SubscriptionService {\n  /**\r\n   * Create a new subscription from web purchase\r\n   * @param {string} email - User's email (only for receipts)\r\n   * @param {string} plan - Subscription plan ID\r\n   * @param {string} paymentId - Reference to payment processor's transaction ID\r\n   * @returns {Promise<Object>} - Created subscription details\r\n   */\n  async createSubscription(email, plan, paymentId) {\n    try {\n      // Calculate expiry date\n      const expiresAt = this.calculateExpiryDate(plan);\n\n      // For MongoDB implementation\n      // Create new subscription document\n      const subscription = await TokenizedSubscription.create({\n        email,\n        accessToken: TokenizedSubscription.generateToken(),\n        mobileAccessCode: TokenizedSubscription.generateMobileAccessCode(),\n        plan,\n        expiresAt,\n        paymentId,\n        active: true\n      });\n      return {\n        success: true,\n        accessToken: subscription.accessToken,\n        mobileAccessCode: subscription.mobileAccessCode,\n        expiresAt: subscription.expiresAt\n      };\n\n      // For in-memory implementation\n      /*\r\n      return await TokenizedSubscription.create({\r\n        email,\r\n        plan,\r\n        expiresAt,\r\n        paymentId\r\n      });\r\n      */\n    } catch (error) {\n      console.error('Failed to create subscription:', error);\n      return {\n        success: false,\n        error: 'Subscription creation failed'\n      };\n    }\n  }\n\n  /**\r\n   * Verify a subscription token\r\n   * @param {string} token - Subscription access token\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\n  async verifyToken(token) {\n    try {\n      return await TokenizedSubscription.verifyToken(token);\n    } catch (error) {\n      console.error('Token verification failed:', error);\n      return {\n        valid: false,\n        error: 'Verification failed'\n      };\n    }\n  }\n\n  /**\r\n   * Verify an Apple receipt\r\n   * @param {string} receipt - Apple receipt data\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\n  async verifyAppleReceipt(receipt) {\n    try {\n      // Use Apple's verification service\n      const verificationResult = await appleReceiptVerifier.verify(receipt);\n      if (verificationResult.valid) {\n        // Store the verified receipt for future reference\n        // This could be in a separate collection/table\n\n        return {\n          verified: true,\n          expiresAt: verificationResult.expiresAt,\n          productId: verificationResult.productId\n        };\n      }\n      return {\n        verified: false\n      };\n    } catch (error) {\n      console.error('Apple receipt verification failed:', error);\n      return {\n        verified: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\r\n   * Verify a Google Play receipt\r\n   * @param {string|Object} receipt - Google Play receipt data\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\n  async verifyGoogleReceipt(receipt) {\n    try {\n      // Parse the receipt if it's a string\n      const receiptData = typeof receipt === 'string' ? JSON.parse(receipt) : receipt;\n\n      // Use Google's API to verify\n      const verificationResult = await googleReceiptVerifier.verify(receiptData.packageName, receiptData.productId, receiptData.purchaseToken);\n      if (verificationResult.valid) {\n        // Store the verified receipt for future reference\n\n        return {\n          verified: true,\n          expiresAt: verificationResult.expiresAt,\n          productId: receiptData.productId\n        };\n      }\n      return {\n        verified: false\n      };\n    } catch (error) {\n      console.error('Google receipt verification failed:', error);\n      return {\n        verified: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\r\n   * Activate subscription on mobile with web access code\r\n   * @param {string} accessCode - Mobile access code from web purchase\r\n   * @param {string} platform - Mobile platform ('ios' or 'android')\r\n   * @returns {Promise<Object>} - Activation result\r\n   */\n  async activateWithCode(accessCode, platform) {\n    try {\n      // Find the subscription by mobile access code\n      const verification = await TokenizedSubscription.verifyMobileCode(accessCode);\n      if (!verification.valid) {\n        return {\n          success: false,\n          error: 'Invalid or expired code'\n        };\n      }\n\n      // Create a \"web receipt\" that can be stored on the mobile device\n      const webReceipt = JSON.stringify({\n        accessToken: verification.accessToken,\n        code: accessCode,\n        platform\n      });\n      return {\n        success: true,\n        webReceipt,\n        plan: verification.plan,\n        expiresAt: verification.expiresAt\n      };\n    } catch (error) {\n      console.error('Code activation failed:', error);\n      return {\n        success: false,\n        error: 'Activation failed'\n      };\n    }\n  }\n\n  /**\r\n   * Verify a \"web receipt\" from mobile device\r\n   * @param {string|Object} webReceipt - Web receipt data\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\n  async verifyWebReceipt(webReceipt) {\n    try {\n      // Parse the receipt if it's a string\n      const receiptData = typeof webReceipt === 'string' ? JSON.parse(webReceipt) : webReceipt;\n\n      // Verify the access token\n      return await this.verifyToken(receiptData.accessToken);\n    } catch (error) {\n      console.error('Web receipt verification failed:', error);\n      return {\n        verified: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\r\n   * Cancel a subscription\r\n   * @param {string} token - Subscription token\r\n   * @returns {Promise<Object>} - Cancellation result\r\n   */\n  async cancelSubscription(token) {\n    try {\n      // For MongoDB implementation\n      const subscription = await TokenizedSubscription.findOne({\n        accessToken: token\n      });\n      if (!subscription) {\n        return {\n          success: false,\n          error: 'Subscription not found'\n        };\n      }\n      subscription.active = false;\n      await subscription.save();\n      return {\n        success: true\n      };\n\n      // For in-memory implementation\n      /*\r\n      return await TokenizedSubscription.cancelSubscription(token);\r\n      */\n    } catch (error) {\n      console.error('Cancellation failed:', error);\n      return {\n        success: false,\n        error: 'Failed to cancel subscription'\n      };\n    }\n  }\n\n  /**\r\n   * Calculate subscription expiry date based on plan\r\n   * @param {string} plan - Subscription plan ID\r\n   * @returns {Date} - Expiry date\r\n   */\n  calculateExpiryDate(plan) {\n    const now = new Date();\n    if (plan === 'monthly_premium') {\n      return new Date(now.setMonth(now.getMonth() + 1));\n    } else if (plan === 'yearly_premium') {\n      return new Date(now.setFullYear(now.getFullYear() + 1));\n    } else {\n      // Default to 1 month if plan is unknown\n      return new Date(now.setMonth(now.getMonth() + 1));\n    }\n  }\n}\nmodule.exports = new SubscriptionService();","map":{"version":3,"names":["TokenizedSubscription","require","appleReceiptVerifier","googleReceiptVerifier","SubscriptionService","createSubscription","email","plan","paymentId","expiresAt","calculateExpiryDate","subscription","create","accessToken","generateToken","mobileAccessCode","generateMobileAccessCode","active","success","error","console","verifyToken","token","valid","verifyAppleReceipt","receipt","verificationResult","verify","verified","productId","message","verifyGoogleReceipt","receiptData","JSON","parse","packageName","purchaseToken","activateWithCode","accessCode","platform","verification","verifyMobileCode","webReceipt","stringify","code","verifyWebReceipt","cancelSubscription","findOne","save","now","Date","setMonth","getMonth","setFullYear","getFullYear","module","exports"],"sources":["C:/Users/juliu/Desktop/web/src/services/SubscriptionService.js"],"sourcesContent":["// src/services/subscriptionService.js\r\n\r\nconst TokenizedSubscription = require('../models/TokenizedSubscription');\r\n// Or use the in-memory version for development\r\n// const TokenizedSubscription = require('../models/inMemoryTokenizedSubscription');\r\n\r\nconst appleReceiptVerifier = require('./platforms/appleReceiptVerifier');\r\nconst googleReceiptVerifier = require('./platforms/googleReceiptVerifier');\r\n\r\n/**\r\n * Service for managing accountless subscriptions\r\n */\r\nclass SubscriptionService {\r\n  /**\r\n   * Create a new subscription from web purchase\r\n   * @param {string} email - User's email (only for receipts)\r\n   * @param {string} plan - Subscription plan ID\r\n   * @param {string} paymentId - Reference to payment processor's transaction ID\r\n   * @returns {Promise<Object>} - Created subscription details\r\n   */\r\n  async createSubscription(email, plan, paymentId) {\r\n    try {\r\n      // Calculate expiry date\r\n      const expiresAt = this.calculateExpiryDate(plan);\r\n      \r\n      // For MongoDB implementation\r\n      // Create new subscription document\r\n      const subscription = await TokenizedSubscription.create({\r\n        email,\r\n        accessToken: TokenizedSubscription.generateToken(),\r\n        mobileAccessCode: TokenizedSubscription.generateMobileAccessCode(),\r\n        plan,\r\n        expiresAt,\r\n        paymentId,\r\n        active: true\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        accessToken: subscription.accessToken,\r\n        mobileAccessCode: subscription.mobileAccessCode,\r\n        expiresAt: subscription.expiresAt\r\n      };\r\n      \r\n      // For in-memory implementation\r\n      /*\r\n      return await TokenizedSubscription.create({\r\n        email,\r\n        plan,\r\n        expiresAt,\r\n        paymentId\r\n      });\r\n      */\r\n    } catch (error) {\r\n      console.error('Failed to create subscription:', error);\r\n      return { success: false, error: 'Subscription creation failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a subscription token\r\n   * @param {string} token - Subscription access token\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\r\n  async verifyToken(token) {\r\n    try {\r\n      return await TokenizedSubscription.verifyToken(token);\r\n    } catch (error) {\r\n      console.error('Token verification failed:', error);\r\n      return { valid: false, error: 'Verification failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify an Apple receipt\r\n   * @param {string} receipt - Apple receipt data\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\r\n  async verifyAppleReceipt(receipt) {\r\n    try {\r\n      // Use Apple's verification service\r\n      const verificationResult = await appleReceiptVerifier.verify(receipt);\r\n      \r\n      if (verificationResult.valid) {\r\n        // Store the verified receipt for future reference\r\n        // This could be in a separate collection/table\r\n        \r\n        return {\r\n          verified: true,\r\n          expiresAt: verificationResult.expiresAt,\r\n          productId: verificationResult.productId\r\n        };\r\n      }\r\n      \r\n      return { verified: false };\r\n    } catch (error) {\r\n      console.error('Apple receipt verification failed:', error);\r\n      return { verified: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a Google Play receipt\r\n   * @param {string|Object} receipt - Google Play receipt data\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\r\n  async verifyGoogleReceipt(receipt) {\r\n    try {\r\n      // Parse the receipt if it's a string\r\n      const receiptData = typeof receipt === 'string' ? JSON.parse(receipt) : receipt;\r\n      \r\n      // Use Google's API to verify\r\n      const verificationResult = await googleReceiptVerifier.verify(\r\n        receiptData.packageName,\r\n        receiptData.productId,\r\n        receiptData.purchaseToken\r\n      );\r\n      \r\n      if (verificationResult.valid) {\r\n        // Store the verified receipt for future reference\r\n        \r\n        return {\r\n          verified: true,\r\n          expiresAt: verificationResult.expiresAt,\r\n          productId: receiptData.productId\r\n        };\r\n      }\r\n      \r\n      return { verified: false };\r\n    } catch (error) {\r\n      console.error('Google receipt verification failed:', error);\r\n      return { verified: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate subscription on mobile with web access code\r\n   * @param {string} accessCode - Mobile access code from web purchase\r\n   * @param {string} platform - Mobile platform ('ios' or 'android')\r\n   * @returns {Promise<Object>} - Activation result\r\n   */\r\n  async activateWithCode(accessCode, platform) {\r\n    try {\r\n      // Find the subscription by mobile access code\r\n      const verification = await TokenizedSubscription.verifyMobileCode(accessCode);\r\n      \r\n      if (!verification.valid) {\r\n        return { success: false, error: 'Invalid or expired code' };\r\n      }\r\n      \r\n      // Create a \"web receipt\" that can be stored on the mobile device\r\n      const webReceipt = JSON.stringify({\r\n        accessToken: verification.accessToken,\r\n        code: accessCode,\r\n        platform\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        webReceipt,\r\n        plan: verification.plan,\r\n        expiresAt: verification.expiresAt\r\n      };\r\n    } catch (error) {\r\n      console.error('Code activation failed:', error);\r\n      return { success: false, error: 'Activation failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a \"web receipt\" from mobile device\r\n   * @param {string|Object} webReceipt - Web receipt data\r\n   * @returns {Promise<Object>} - Verification result\r\n   */\r\n  async verifyWebReceipt(webReceipt) {\r\n    try {\r\n      // Parse the receipt if it's a string\r\n      const receiptData = typeof webReceipt === 'string' ? JSON.parse(webReceipt) : webReceipt;\r\n      \r\n      // Verify the access token\r\n      return await this.verifyToken(receiptData.accessToken);\r\n    } catch (error) {\r\n      console.error('Web receipt verification failed:', error);\r\n      return { verified: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel a subscription\r\n   * @param {string} token - Subscription token\r\n   * @returns {Promise<Object>} - Cancellation result\r\n   */\r\n  async cancelSubscription(token) {\r\n    try {\r\n      // For MongoDB implementation\r\n      const subscription = await TokenizedSubscription.findOne({ accessToken: token });\r\n      \r\n      if (!subscription) {\r\n        return { success: false, error: 'Subscription not found' };\r\n      }\r\n      \r\n      subscription.active = false;\r\n      await subscription.save();\r\n      \r\n      return { success: true };\r\n      \r\n      // For in-memory implementation\r\n      /*\r\n      return await TokenizedSubscription.cancelSubscription(token);\r\n      */\r\n    } catch (error) {\r\n      console.error('Cancellation failed:', error);\r\n      return { success: false, error: 'Failed to cancel subscription' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate subscription expiry date based on plan\r\n   * @param {string} plan - Subscription plan ID\r\n   * @returns {Date} - Expiry date\r\n   */\r\n  calculateExpiryDate(plan) {\r\n    const now = new Date();\r\n    \r\n    if (plan === 'monthly_premium') {\r\n      return new Date(now.setMonth(now.getMonth() + 1));\r\n    } else if (plan === 'yearly_premium') {\r\n      return new Date(now.setFullYear(now.getFullYear() + 1));\r\n    } else {\r\n      // Default to 1 month if plan is unknown\r\n      return new Date(now.setMonth(now.getMonth() + 1));\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = new SubscriptionService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}