{"ast":null,"code":"// src/services/flightDataSharingService.js\n\nimport { storageKeys } from '../constants/storageKeys';\nclass FlightDataSharingService {\n  constructor() {\n    // Global cache of flight data shared across all users\n    this.globalCache = {};\n\n    // Track route popularity\n    this.routeRequests = {};\n\n    // Cache expiration times (adaptive based on popularity)\n    this.cacheExpiryTimes = {\n      highTraffic: 30 * 60 * 1000,\n      // 30 minutes for popular routes\n      medium: 2 * 60 * 60 * 1000,\n      // 2 hours for medium traffic\n      low: 6 * 60 * 60 * 1000 // 6 hours for low traffic routes\n    };\n\n    // Load cached data on startup\n    this.loadCachedData();\n\n    // Set up periodic cleanup\n    setInterval(() => this.cleanupExpiredData(), 15 * 60 * 1000); // Run every 15 minutes\n  }\n  loadCachedData() {\n    try {\n      // Load from localStorage\n      const cachedData = localStorage.getItem(storageKeys.GLOBAL_FLIGHT_CACHE);\n      if (cachedData) {\n        this.globalCache = JSON.parse(cachedData);\n      }\n      const routeStats = localStorage.getItem(storageKeys.ROUTE_STATISTICS);\n      if (routeStats) {\n        this.routeRequests = JSON.parse(routeStats);\n      }\n    } catch (error) {\n      console.error('Error loading cached flight data:', error);\n      this.globalCache = {};\n      this.routeRequests = {};\n    }\n  }\n  saveCachedData() {\n    try {\n      localStorage.setItem(storageKeys.GLOBAL_FLIGHT_CACHE, JSON.stringify(this.globalCache));\n      localStorage.setItem(storageKeys.ROUTE_STATISTICS, JSON.stringify(this.routeRequests));\n    } catch (error) {\n      console.error('Error saving cached flight data:', error);\n    }\n  }\n\n  // Get flight data for a route, with intelligent refresh logic\n  async getFlightData(originCode, destinationCode, originId, destinationId, skyscannerService) {\n    // Create a unique route key\n    const routeKey = `${originCode}-${destinationCode}`;\n\n    // Track route popularity\n    this.incrementRouteRequests(routeKey);\n\n    // Check if we have cached data\n    if (this.globalCache[routeKey] && !this.isCacheExpired(routeKey)) {\n      // Return cached data without making API call\n      return this.globalCache[routeKey].data;\n    }\n\n    // Cache miss or expired cache - fetch fresh data\n    try {\n      // Make the API call (one call serves all users looking for this route)\n      const data = await skyscannerService.searchOneWayFlights(originCode, destinationCode, originId, destinationId);\n\n      // Store in cache with timestamp\n      this.globalCache[routeKey] = {\n        data,\n        timestamp: Date.now(),\n        popularity: this.getRoutePopularity(routeKey)\n      };\n      this.saveCachedData();\n      return data;\n    } catch (error) {\n      console.error(`Error fetching flight data for ${routeKey}:`, error);\n\n      // Return stale cache if available, even if expired\n      if (this.globalCache[routeKey]) {\n        return this.globalCache[routeKey].data;\n      }\n      throw error;\n    }\n  }\n\n  // Check if cache is expired based on adaptive expiry time\n  isCacheExpired(routeKey) {\n    if (!this.globalCache[routeKey]) return true;\n    const entry = this.globalCache[routeKey];\n    const age = Date.now() - entry.timestamp;\n    const expiryTime = this.getCacheExpiryTime(routeKey);\n    return age > expiryTime;\n  }\n\n  // Get appropriate cache expiry time based on route popularity\n  getCacheExpiryTime(routeKey) {\n    const popularity = this.getRoutePopularity(routeKey);\n    if (popularity >= 10) {\n      // High traffic route\n      return this.cacheExpiryTimes.highTraffic;\n    } else if (popularity >= 3) {\n      // Medium traffic\n      return this.cacheExpiryTimes.medium;\n    } else {\n      // Low traffic\n      return this.cacheExpiryTimes.low;\n    }\n  }\n\n  // Track route popularity (how many times a route is requested)\n  incrementRouteRequests(routeKey) {\n    // Initialize if needed\n    if (!this.routeRequests[routeKey]) {\n      this.routeRequests[routeKey] = {\n        total: 0,\n        lastHour: 0,\n        lastHourStart: Date.now()\n      };\n    }\n\n    // Update counters\n    this.routeRequests[routeKey].total++;\n\n    // Reset hourly counter if it's been more than an hour\n    const hourlyData = this.routeRequests[routeKey];\n    if (Date.now() - hourlyData.lastHourStart > 60 * 60 * 1000) {\n      hourlyData.lastHour = 1;\n      hourlyData.lastHourStart = Date.now();\n    } else {\n      hourlyData.lastHour++;\n    }\n  }\n\n  // Get current route popularity (weighted toward recent activity)\n  getRoutePopularity(routeKey) {\n    if (!this.routeRequests[routeKey]) return 0;\n\n    // Weight recent activity higher\n    return this.routeRequests[routeKey].lastHour * 2 + Math.min(this.routeRequests[routeKey].total, 100) / 10;\n  }\n\n  // Remove expired entries to save space\n  cleanupExpiredData() {\n    const now = Date.now();\n    let entriesRemoved = 0;\n\n    // Remove entries older than the maximum cache time plus a buffer\n    const maxExpiryTime = this.cacheExpiryTimes.low + 60 * 60 * 1000; // Add 1 hour buffer\n\n    Object.keys(this.globalCache).forEach(routeKey => {\n      const entry = this.globalCache[routeKey];\n      if (now - entry.timestamp > maxExpiryTime) {\n        delete this.globalCache[routeKey];\n        entriesRemoved++;\n      }\n    });\n    if (entriesRemoved > 0) {\n      console.log(`Cleaned up ${entriesRemoved} expired flight data entries`);\n      this.saveCachedData();\n    }\n  }\n\n  // For free users - check if they've used all their free signals (3 total, not per day)\n  canUserGetFreeSignal(userId) {\n    // Get user's signal usage from localStorage\n    try {\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\n      if (!userSignals) {\n        return true; // New user, no signals used yet\n      }\n      const signalData = JSON.parse(userSignals);\n\n      // Check if user has used all 3 free signals total\n      return signalData.count < 3;\n    } catch (error) {\n      console.error('Error checking user signal usage:', error);\n      return false;\n    }\n  }\n\n  // Record when a user uses a free signal (lifetime limit of 3)\n  recordFreeSignalUsage(userId) {\n    try {\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\n      const signalData = userSignals ? JSON.parse(userSignals) : {\n        count: 0,\n        firstUsed: Date.now()\n      };\n      signalData.count++;\n      signalData.lastUsed = Date.now();\n      localStorage.setItem(`user_signals_${userId}`, JSON.stringify(signalData));\n      return signalData.count;\n    } catch (error) {\n      console.error('Error recording signal usage:', error);\n      return 3; // Assume max usage on error\n    }\n  }\n\n  // Get remaining free signals for a user (out of 3 total)\n  getRemainingFreeSignals(userId) {\n    try {\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\n      if (!userSignals) return 3; // New user gets 3 signals\n\n      const signalData = JSON.parse(userSignals);\n      return Math.max(0, 3 - signalData.count);\n    } catch (error) {\n      console.error('Error getting remaining signals:', error);\n      return 0;\n    }\n  }\n}\nexport default new FlightDataSharingService();","map":{"version":3,"names":["storageKeys","FlightDataSharingService","constructor","globalCache","routeRequests","cacheExpiryTimes","highTraffic","medium","low","loadCachedData","setInterval","cleanupExpiredData","cachedData","localStorage","getItem","GLOBAL_FLIGHT_CACHE","JSON","parse","routeStats","ROUTE_STATISTICS","error","console","saveCachedData","setItem","stringify","getFlightData","originCode","destinationCode","originId","destinationId","skyscannerService","routeKey","incrementRouteRequests","isCacheExpired","data","searchOneWayFlights","timestamp","Date","now","popularity","getRoutePopularity","entry","age","expiryTime","getCacheExpiryTime","total","lastHour","lastHourStart","hourlyData","Math","min","entriesRemoved","maxExpiryTime","Object","keys","forEach","log","canUserGetFreeSignal","userId","userSignals","signalData","count","recordFreeSignalUsage","firstUsed","lastUsed","getRemainingFreeSignals","max"],"sources":["C:/Users/juliu/Desktop/web/src/services/flightDataSharingService.js"],"sourcesContent":["// src/services/flightDataSharingService.js\r\n\r\nimport { storageKeys } from '../constants/storageKeys';\r\n\r\nclass FlightDataSharingService {\r\n  constructor() {\r\n    // Global cache of flight data shared across all users\r\n    this.globalCache = {};\r\n    \r\n    // Track route popularity\r\n    this.routeRequests = {};\r\n    \r\n    // Cache expiration times (adaptive based on popularity)\r\n    this.cacheExpiryTimes = {\r\n      highTraffic: 30 * 60 * 1000, // 30 minutes for popular routes\r\n      medium: 2 * 60 * 60 * 1000,  // 2 hours for medium traffic\r\n      low: 6 * 60 * 60 * 1000      // 6 hours for low traffic routes\r\n    };\r\n    \r\n    // Load cached data on startup\r\n    this.loadCachedData();\r\n    \r\n    // Set up periodic cleanup\r\n    setInterval(() => this.cleanupExpiredData(), 15 * 60 * 1000); // Run every 15 minutes\r\n  }\r\n  \r\n  loadCachedData() {\r\n    try {\r\n      // Load from localStorage\r\n      const cachedData = localStorage.getItem(storageKeys.GLOBAL_FLIGHT_CACHE);\r\n      if (cachedData) {\r\n        this.globalCache = JSON.parse(cachedData);\r\n      }\r\n      \r\n      const routeStats = localStorage.getItem(storageKeys.ROUTE_STATISTICS);\r\n      if (routeStats) {\r\n        this.routeRequests = JSON.parse(routeStats);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading cached flight data:', error);\r\n      this.globalCache = {};\r\n      this.routeRequests = {};\r\n    }\r\n  }\r\n  \r\n  saveCachedData() {\r\n    try {\r\n      localStorage.setItem(storageKeys.GLOBAL_FLIGHT_CACHE, JSON.stringify(this.globalCache));\r\n      localStorage.setItem(storageKeys.ROUTE_STATISTICS, JSON.stringify(this.routeRequests));\r\n    } catch (error) {\r\n      console.error('Error saving cached flight data:', error);\r\n    }\r\n  }\r\n  \r\n  // Get flight data for a route, with intelligent refresh logic\r\n  async getFlightData(originCode, destinationCode, originId, destinationId, skyscannerService) {\r\n    // Create a unique route key\r\n    const routeKey = `${originCode}-${destinationCode}`;\r\n    \r\n    // Track route popularity\r\n    this.incrementRouteRequests(routeKey);\r\n    \r\n    // Check if we have cached data\r\n    if (this.globalCache[routeKey] && !this.isCacheExpired(routeKey)) {\r\n      // Return cached data without making API call\r\n      return this.globalCache[routeKey].data;\r\n    }\r\n    \r\n    // Cache miss or expired cache - fetch fresh data\r\n    try {\r\n      // Make the API call (one call serves all users looking for this route)\r\n      const data = await skyscannerService.searchOneWayFlights(\r\n        originCode, destinationCode, originId, destinationId\r\n      );\r\n      \r\n      // Store in cache with timestamp\r\n      this.globalCache[routeKey] = {\r\n        data,\r\n        timestamp: Date.now(),\r\n        popularity: this.getRoutePopularity(routeKey)\r\n      };\r\n      \r\n      this.saveCachedData();\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      console.error(`Error fetching flight data for ${routeKey}:`, error);\r\n      \r\n      // Return stale cache if available, even if expired\r\n      if (this.globalCache[routeKey]) {\r\n        return this.globalCache[routeKey].data;\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Check if cache is expired based on adaptive expiry time\r\n  isCacheExpired(routeKey) {\r\n    if (!this.globalCache[routeKey]) return true;\r\n    \r\n    const entry = this.globalCache[routeKey];\r\n    const age = Date.now() - entry.timestamp;\r\n    const expiryTime = this.getCacheExpiryTime(routeKey);\r\n    \r\n    return age > expiryTime;\r\n  }\r\n  \r\n  // Get appropriate cache expiry time based on route popularity\r\n  getCacheExpiryTime(routeKey) {\r\n    const popularity = this.getRoutePopularity(routeKey);\r\n    \r\n    if (popularity >= 10) { // High traffic route\r\n      return this.cacheExpiryTimes.highTraffic;\r\n    } else if (popularity >= 3) { // Medium traffic\r\n      return this.cacheExpiryTimes.medium;\r\n    } else { // Low traffic\r\n      return this.cacheExpiryTimes.low;\r\n    }\r\n  }\r\n  \r\n  // Track route popularity (how many times a route is requested)\r\n  incrementRouteRequests(routeKey) {\r\n    // Initialize if needed\r\n    if (!this.routeRequests[routeKey]) {\r\n      this.routeRequests[routeKey] = {\r\n        total: 0,\r\n        lastHour: 0,\r\n        lastHourStart: Date.now()\r\n      };\r\n    }\r\n    \r\n    // Update counters\r\n    this.routeRequests[routeKey].total++;\r\n    \r\n    // Reset hourly counter if it's been more than an hour\r\n    const hourlyData = this.routeRequests[routeKey];\r\n    if (Date.now() - hourlyData.lastHourStart > 60 * 60 * 1000) {\r\n      hourlyData.lastHour = 1;\r\n      hourlyData.lastHourStart = Date.now();\r\n    } else {\r\n      hourlyData.lastHour++;\r\n    }\r\n  }\r\n  \r\n  // Get current route popularity (weighted toward recent activity)\r\n  getRoutePopularity(routeKey) {\r\n    if (!this.routeRequests[routeKey]) return 0;\r\n    \r\n    // Weight recent activity higher\r\n    return this.routeRequests[routeKey].lastHour * 2 + \r\n      Math.min(this.routeRequests[routeKey].total, 100) / 10;\r\n  }\r\n  \r\n  // Remove expired entries to save space\r\n  cleanupExpiredData() {\r\n    const now = Date.now();\r\n    let entriesRemoved = 0;\r\n    \r\n    // Remove entries older than the maximum cache time plus a buffer\r\n    const maxExpiryTime = this.cacheExpiryTimes.low + (60 * 60 * 1000); // Add 1 hour buffer\r\n    \r\n    Object.keys(this.globalCache).forEach(routeKey => {\r\n      const entry = this.globalCache[routeKey];\r\n      if (now - entry.timestamp > maxExpiryTime) {\r\n        delete this.globalCache[routeKey];\r\n        entriesRemoved++;\r\n      }\r\n    });\r\n    \r\n    if (entriesRemoved > 0) {\r\n      console.log(`Cleaned up ${entriesRemoved} expired flight data entries`);\r\n      this.saveCachedData();\r\n    }\r\n  }\r\n  \r\n  // For free users - check if they've used all their free signals (3 total, not per day)\r\n  canUserGetFreeSignal(userId) {\r\n    // Get user's signal usage from localStorage\r\n    try {\r\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\r\n      if (!userSignals) {\r\n        return true; // New user, no signals used yet\r\n      }\r\n      \r\n      const signalData = JSON.parse(userSignals);\r\n      \r\n      // Check if user has used all 3 free signals total\r\n      return signalData.count < 3;\r\n    } catch (error) {\r\n      console.error('Error checking user signal usage:', error);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Record when a user uses a free signal (lifetime limit of 3)\r\n  recordFreeSignalUsage(userId) {\r\n    try {\r\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\r\n      const signalData = userSignals ? JSON.parse(userSignals) : { count: 0, firstUsed: Date.now() };\r\n      \r\n      signalData.count++;\r\n      signalData.lastUsed = Date.now();\r\n      \r\n      localStorage.setItem(`user_signals_${userId}`, JSON.stringify(signalData));\r\n      \r\n      return signalData.count;\r\n    } catch (error) {\r\n      console.error('Error recording signal usage:', error);\r\n      return 3; // Assume max usage on error\r\n    }\r\n  }\r\n  \r\n  // Get remaining free signals for a user (out of 3 total)\r\n  getRemainingFreeSignals(userId) {\r\n    try {\r\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\r\n      if (!userSignals) return 3; // New user gets 3 signals\r\n      \r\n      const signalData = JSON.parse(userSignals);\r\n      return Math.max(0, 3 - signalData.count);\r\n    } catch (error) {\r\n      console.error('Error getting remaining signals:', error);\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new FlightDataSharingService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}