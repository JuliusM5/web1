{"ast":null,"code":"/**\r\n * API Service\r\n * Provides generic HTTP request functionality with error handling, retries, and caching\r\n */\n\n// Default options for fetch requests\nconst defaultOptions = {\n  // Default headers for all requests\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  // Cache responses for GET requests\n  cache: true,\n  // Cache lifetime in milliseconds (15 minutes)\n  cacheLifetime: 15 * 60 * 1000,\n  // Number of retries for failed requests\n  retries: 1,\n  // Delay between retries in milliseconds\n  retryDelay: 1000,\n  // Timeout for requests in milliseconds (10 seconds)\n  timeout: 10000\n};\n\n/**\r\n * Make an HTTP request with error handling, retries, and caching\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\nexport const request = async (url, options = {}) => {\n  // Merge default options with provided options\n  const mergedOptions = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    cache,\n    cacheLifetime,\n    retries,\n    retryDelay,\n    timeout,\n    ...fetchOptions\n  } = mergedOptions;\n\n  // Check if request should be cached (only for GET requests)\n  const shouldCache = cache && (!fetchOptions.method || fetchOptions.method === 'GET');\n\n  // Check cache for existing response\n  if (shouldCache) {\n    const cachedResponse = getCachedResponse(url, fetchOptions);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n  }\n\n  // Add timeout to request\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n  fetchOptions.signal = controller.signal;\n\n  // Try making the request with retries\n  let lastError;\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      if (attempt > 0) {\n        // Wait before retrying\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n      }\n\n      // Make the request\n      const response = await fetch(url, fetchOptions);\n\n      // Clear timeout\n      clearTimeout(timeoutId);\n\n      // Handle non-2xx responses\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP error ${response.status}: ${errorText}`);\n      }\n\n      // Parse response based on content type\n      let data;\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('application/json')) {\n        data = await response.json();\n      } else {\n        data = await response.text();\n      }\n\n      // Cache the response if needed\n      if (shouldCache) {\n        cacheResponse(url, fetchOptions, data, cacheLifetime);\n      }\n\n      // Record the request for offline sync if needed\n      if (!navigator.onLine && (fetchOptions.method === 'POST' || fetchOptions.method === 'PUT' || fetchOptions.method === 'DELETE')) {\n        recordOfflineRequest(url, fetchOptions);\n      }\n      return data;\n    } catch (error) {\n      lastError = error;\n\n      // Don't retry if request was aborted or if it's the last attempt\n      if (error.name === 'AbortError' || attempt === retries) {\n        clearTimeout(timeoutId);\n\n        // If offline, record the request for later sync\n        if (!navigator.onLine && (fetchOptions.method === 'POST' || fetchOptions.method === 'PUT' || fetchOptions.method === 'DELETE')) {\n          recordOfflineRequest(url, fetchOptions);\n          throw new Error(`Network request failed (offline). The request will be synchronized when you're back online.`);\n        }\n        throw error;\n      }\n\n      // Continue to next retry attempt\n    }\n  }\n\n  // This should not happen, but just in case\n  throw lastError;\n};\n\n/**\r\n * Make a GET request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\nexport const get = (url, options = {}) => {\n  return request(url, {\n    ...options,\n    method: 'GET'\n  });\n};\n\n/**\r\n * Make a POST request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} data Request body data\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\nexport const post = (url, data, options = {}) => {\n  return request(url, {\n    ...options,\n    method: 'POST',\n    body: JSON.stringify(data)\n  });\n};\n\n/**\r\n * Make a PUT request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} data Request body data\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\nexport const put = (url, data, options = {}) => {\n  return request(url, {\n    ...options,\n    method: 'PUT',\n    body: JSON.stringify(data)\n  });\n};\n\n/**\r\n * Make a DELETE request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\nexport const del = (url, options = {}) => {\n  return request(url, {\n    ...options,\n    method: 'DELETE'\n  });\n};\n\n// Cache functions\n\n/**\r\n * Generate a cache key for a request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {string} Cache key\r\n */\nconst generateCacheKey = (url, options) => {\n  const paramsString = JSON.stringify(options);\n  return `${url}:${paramsString}`;\n};\n\n/**\r\n * Get a cached response if available and not expired\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Object|null} Cached response or null if not available\r\n */\nconst getCachedResponse = (url, options) => {\n  const cacheKey = generateCacheKey(url, options);\n  const cachedItem = localStorage.getItem(`api_cache:${cacheKey}`);\n  if (cachedItem) {\n    try {\n      const {\n        data,\n        expiry\n      } = JSON.parse(cachedItem);\n\n      // Check if cache is still valid\n      if (expiry > Date.now()) {\n        return data;\n      } else {\n        // Remove expired cache\n        localStorage.removeItem(`api_cache:${cacheKey}`);\n      }\n    } catch (error) {\n      console.error('Error parsing cached response:', error);\n      localStorage.removeItem(`api_cache:${cacheKey}`);\n    }\n  }\n  return null;\n};\n\n/**\r\n * Cache a response for future use\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @param {Object} data Response data\r\n * @param {number} lifetime Cache lifetime in milliseconds\r\n */\nconst cacheResponse = (url, options, data, lifetime) => {\n  const cacheKey = generateCacheKey(url, options);\n  const expiry = Date.now() + lifetime;\n  try {\n    localStorage.setItem(`api_cache:${cacheKey}`, JSON.stringify({\n      data,\n      expiry\n    }));\n  } catch (error) {\n    console.error('Error caching response:', error);\n    // If storage is full, clear old cache items\n    if (error instanceof DOMException && error.name === 'QuotaExceededError') {\n      clearOldCacheItems();\n    }\n  }\n};\n\n/**\r\n * Clear old cache items when storage is full\r\n */\nconst clearOldCacheItems = () => {\n  // Get all cache keys\n  const cacheKeys = [];\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i);\n    if (key.startsWith('api_cache:')) {\n      cacheKeys.push(key);\n    }\n  }\n\n  // Sort keys by age (oldest first)\n  const sortedKeys = cacheKeys.map(key => {\n    try {\n      const item = JSON.parse(localStorage.getItem(key));\n      return {\n        key,\n        expiry: item.expiry\n      };\n    } catch (error) {\n      return {\n        key,\n        expiry: 0\n      }; // If can't parse, treat as oldest\n    }\n  }).sort((a, b) => a.expiry - b.expiry);\n\n  // Remove oldest 20% of cache\n  const removeCount = Math.max(1, Math.ceil(sortedKeys.length * 0.2));\n  sortedKeys.slice(0, removeCount).forEach(({\n    key\n  }) => {\n    localStorage.removeItem(key);\n  });\n};\n\n/**\r\n * Record an offline request for later synchronization\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n */\nconst recordOfflineRequest = (url, options) => {\n  // Get existing unsynced changes\n  const unsynced = JSON.parse(localStorage.getItem('unsyncedChanges') || '[]');\n\n  // Add this request\n  unsynced.push({\n    timestamp: Date.now(),\n    url,\n    options,\n    id: Date.now() + Math.floor(Math.random() * 1000)\n  });\n\n  // Save updated unsynced changes\n  localStorage.setItem('unsyncedChanges', JSON.stringify(unsynced));\n\n  // Update unsynced count for UI\n  window.dispatchEvent(new CustomEvent('unsyncedChangesUpdated', {\n    detail: {\n      count: unsynced.length\n    }\n  }));\n};","map":{"version":3,"names":["defaultOptions","headers","cache","cacheLifetime","retries","retryDelay","timeout","request","url","options","mergedOptions","fetchOptions","shouldCache","method","cachedResponse","getCachedResponse","controller","AbortController","timeoutId","setTimeout","abort","signal","lastError","attempt","Promise","resolve","response","fetch","clearTimeout","ok","errorText","text","Error","status","data","contentType","get","includes","json","cacheResponse","navigator","onLine","recordOfflineRequest","error","name","post","body","JSON","stringify","put","del","generateCacheKey","paramsString","cacheKey","cachedItem","localStorage","getItem","expiry","parse","Date","now","removeItem","console","lifetime","setItem","DOMException","clearOldCacheItems","cacheKeys","i","length","key","startsWith","push","sortedKeys","map","item","sort","a","b","removeCount","Math","max","ceil","slice","forEach","unsynced","timestamp","id","floor","random","window","dispatchEvent","CustomEvent","detail","count"],"sources":["C:/Users/juliu/Desktop/web/src/services/apiService.js"],"sourcesContent":["/**\r\n * API Service\r\n * Provides generic HTTP request functionality with error handling, retries, and caching\r\n */\r\n\r\n// Default options for fetch requests\r\nconst defaultOptions = {\r\n  // Default headers for all requests\r\n  headers: {\r\n    'Content-Type': 'application/json'\r\n  },\r\n  // Cache responses for GET requests\r\n  cache: true,\r\n  // Cache lifetime in milliseconds (15 minutes)\r\n  cacheLifetime: 15 * 60 * 1000,\r\n  // Number of retries for failed requests\r\n  retries: 1,\r\n  // Delay between retries in milliseconds\r\n  retryDelay: 1000,\r\n  // Timeout for requests in milliseconds (10 seconds)\r\n  timeout: 10000\r\n};\r\n\r\n/**\r\n * Make an HTTP request with error handling, retries, and caching\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\r\nexport const request = async (url, options = {}) => {\r\n  // Merge default options with provided options\r\n  const mergedOptions = { ...defaultOptions, ...options };\r\n  const { cache, cacheLifetime, retries, retryDelay, timeout, ...fetchOptions } = mergedOptions;\r\n  \r\n  // Check if request should be cached (only for GET requests)\r\n  const shouldCache = cache && (!fetchOptions.method || fetchOptions.method === 'GET');\r\n  \r\n  // Check cache for existing response\r\n  if (shouldCache) {\r\n    const cachedResponse = getCachedResponse(url, fetchOptions);\r\n    if (cachedResponse) {\r\n      return cachedResponse;\r\n    }\r\n  }\r\n  \r\n  // Add timeout to request\r\n  const controller = new AbortController();\r\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n  fetchOptions.signal = controller.signal;\r\n  \r\n  // Try making the request with retries\r\n  let lastError;\r\n  for (let attempt = 0; attempt <= retries; attempt++) {\r\n    try {\r\n      if (attempt > 0) {\r\n        // Wait before retrying\r\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\r\n      }\r\n      \r\n      // Make the request\r\n      const response = await fetch(url, fetchOptions);\r\n      \r\n      // Clear timeout\r\n      clearTimeout(timeoutId);\r\n      \r\n      // Handle non-2xx responses\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        throw new Error(`HTTP error ${response.status}: ${errorText}`);\r\n      }\r\n      \r\n      // Parse response based on content type\r\n      let data;\r\n      const contentType = response.headers.get('content-type');\r\n      if (contentType && contentType.includes('application/json')) {\r\n        data = await response.json();\r\n      } else {\r\n        data = await response.text();\r\n      }\r\n      \r\n      // Cache the response if needed\r\n      if (shouldCache) {\r\n        cacheResponse(url, fetchOptions, data, cacheLifetime);\r\n      }\r\n      \r\n      // Record the request for offline sync if needed\r\n      if (!navigator.onLine && (fetchOptions.method === 'POST' || fetchOptions.method === 'PUT' || fetchOptions.method === 'DELETE')) {\r\n        recordOfflineRequest(url, fetchOptions);\r\n      }\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      lastError = error;\r\n      \r\n      // Don't retry if request was aborted or if it's the last attempt\r\n      if (error.name === 'AbortError' || attempt === retries) {\r\n        clearTimeout(timeoutId);\r\n        \r\n        // If offline, record the request for later sync\r\n        if (!navigator.onLine && (fetchOptions.method === 'POST' || fetchOptions.method === 'PUT' || fetchOptions.method === 'DELETE')) {\r\n          recordOfflineRequest(url, fetchOptions);\r\n          throw new Error(`Network request failed (offline). The request will be synchronized when you're back online.`);\r\n        }\r\n        \r\n        throw error;\r\n      }\r\n      \r\n      // Continue to next retry attempt\r\n    }\r\n  }\r\n  \r\n  // This should not happen, but just in case\r\n  throw lastError;\r\n};\r\n\r\n/**\r\n * Make a GET request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\r\nexport const get = (url, options = {}) => {\r\n  return request(url, {\r\n    ...options,\r\n    method: 'GET'\r\n  });\r\n};\r\n\r\n/**\r\n * Make a POST request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} data Request body data\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\r\nexport const post = (url, data, options = {}) => {\r\n  return request(url, {\r\n    ...options,\r\n    method: 'POST',\r\n    body: JSON.stringify(data)\r\n  });\r\n};\r\n\r\n/**\r\n * Make a PUT request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} data Request body data\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\r\nexport const put = (url, data, options = {}) => {\r\n  return request(url, {\r\n    ...options,\r\n    method: 'PUT',\r\n    body: JSON.stringify(data)\r\n  });\r\n};\r\n\r\n/**\r\n * Make a DELETE request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Promise<any>} Promise that resolves to response data\r\n */\r\nexport const del = (url, options = {}) => {\r\n  return request(url, {\r\n    ...options,\r\n    method: 'DELETE'\r\n  });\r\n};\r\n\r\n// Cache functions\r\n\r\n/**\r\n * Generate a cache key for a request\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {string} Cache key\r\n */\r\nconst generateCacheKey = (url, options) => {\r\n  const paramsString = JSON.stringify(options);\r\n  return `${url}:${paramsString}`;\r\n};\r\n\r\n/**\r\n * Get a cached response if available and not expired\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @returns {Object|null} Cached response or null if not available\r\n */\r\nconst getCachedResponse = (url, options) => {\r\n  const cacheKey = generateCacheKey(url, options);\r\n  const cachedItem = localStorage.getItem(`api_cache:${cacheKey}`);\r\n  \r\n  if (cachedItem) {\r\n    try {\r\n      const { data, expiry } = JSON.parse(cachedItem);\r\n      \r\n      // Check if cache is still valid\r\n      if (expiry > Date.now()) {\r\n        return data;\r\n      } else {\r\n        // Remove expired cache\r\n        localStorage.removeItem(`api_cache:${cacheKey}`);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing cached response:', error);\r\n      localStorage.removeItem(`api_cache:${cacheKey}`);\r\n    }\r\n  }\r\n  \r\n  return null;\r\n};\r\n\r\n/**\r\n * Cache a response for future use\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n * @param {Object} data Response data\r\n * @param {number} lifetime Cache lifetime in milliseconds\r\n */\r\nconst cacheResponse = (url, options, data, lifetime) => {\r\n  const cacheKey = generateCacheKey(url, options);\r\n  const expiry = Date.now() + lifetime;\r\n  \r\n  try {\r\n    localStorage.setItem(`api_cache:${cacheKey}`, JSON.stringify({ data, expiry }));\r\n  } catch (error) {\r\n    console.error('Error caching response:', error);\r\n    // If storage is full, clear old cache items\r\n    if (error instanceof DOMException && error.name === 'QuotaExceededError') {\r\n      clearOldCacheItems();\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Clear old cache items when storage is full\r\n */\r\nconst clearOldCacheItems = () => {\r\n  // Get all cache keys\r\n  const cacheKeys = [];\r\n  for (let i = 0; i < localStorage.length; i++) {\r\n    const key = localStorage.key(i);\r\n    if (key.startsWith('api_cache:')) {\r\n      cacheKeys.push(key);\r\n    }\r\n  }\r\n  \r\n  // Sort keys by age (oldest first)\r\n  const sortedKeys = cacheKeys.map(key => {\r\n    try {\r\n      const item = JSON.parse(localStorage.getItem(key));\r\n      return { key, expiry: item.expiry };\r\n    } catch (error) {\r\n      return { key, expiry: 0 }; // If can't parse, treat as oldest\r\n    }\r\n  }).sort((a, b) => a.expiry - b.expiry);\r\n  \r\n  // Remove oldest 20% of cache\r\n  const removeCount = Math.max(1, Math.ceil(sortedKeys.length * 0.2));\r\n  sortedKeys.slice(0, removeCount).forEach(({ key }) => {\r\n    localStorage.removeItem(key);\r\n  });\r\n};\r\n\r\n/**\r\n * Record an offline request for later synchronization\r\n * \r\n * @param {string} url Request URL\r\n * @param {Object} options Request options\r\n */\r\nconst recordOfflineRequest = (url, options) => {\r\n  // Get existing unsynced changes\r\n  const unsynced = JSON.parse(localStorage.getItem('unsyncedChanges') || '[]');\r\n  \r\n  // Add this request\r\n  unsynced.push({\r\n    timestamp: Date.now(),\r\n    url,\r\n    options,\r\n    id: Date.now() + Math.floor(Math.random() * 1000)\r\n  });\r\n  \r\n  // Save updated unsynced changes\r\n  localStorage.setItem('unsyncedChanges', JSON.stringify(unsynced));\r\n  \r\n  // Update unsynced count for UI\r\n  window.dispatchEvent(new CustomEvent('unsyncedChangesUpdated', {\r\n    detail: { count: unsynced.length }\r\n  }));\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}