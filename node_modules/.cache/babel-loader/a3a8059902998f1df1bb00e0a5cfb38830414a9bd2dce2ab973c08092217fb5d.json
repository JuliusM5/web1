{"ast":null,"code":"// src/data/inMemoryProvider.js\n// Simple in-memory storage without any external dependencies\n\n// In-memory storage using localStorage for persistence\nconst STORAGE_KEY = 'subscription_data';\n\n// Initialize or load existing data\nconst loadData = () => {\n  try {\n    const storedData = localStorage.getItem(STORAGE_KEY);\n    return storedData ? JSON.parse(storedData) : {\n      subscriptions: []\n    };\n  } catch (e) {\n    console.error('Error loading data from localStorage:', e);\n    return {\n      subscriptions: []\n    };\n  }\n};\n\n// Save data to localStorage\nconst saveData = data => {\n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n  } catch (e) {\n    console.error('Error saving data to localStorage:', e);\n  }\n};\n\n// Generate a simple random ID\nconst generateId = () => {\n  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n};\n\n// Generate an access code\nconst generateAccessCode = () => {\n  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\n  let code = '';\n  for (let i = 0; i < 12; i++) {\n    if (i === 4 || i === 8) {\n      code += '-';\n    }\n    code += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return code;\n};\nconst inMemoryProvider = {\n  // Subscription methods\n  async createSubscription(subscriptionData) {\n    try {\n      const data = loadData();\n\n      // Generate an ID and access code if not provided\n      const id = subscriptionData.id || generateId();\n      const accessCode = subscriptionData.accessCode || generateAccessCode();\n      const newSubscription = {\n        ...subscriptionData,\n        id,\n        accessCode,\n        createdAt: subscriptionData.createdAt || new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      data.subscriptions.push(newSubscription);\n      saveData(data);\n      return {\n        ...newSubscription\n      };\n    } catch (error) {\n      console.error('Error creating subscription:', error);\n      throw error;\n    }\n  },\n  async getSubscriptionByAccessCode(accessCode) {\n    try {\n      const data = loadData();\n      const subscription = data.subscriptions.find(sub => sub.accessCode === accessCode);\n      return subscription ? {\n        ...subscription\n      } : null;\n    } catch (error) {\n      console.error('Error finding subscription by access code:', error);\n      throw error;\n    }\n  },\n  async getSubscriptionByTransactionId(transactionId) {\n    try {\n      const data = loadData();\n      const subscription = data.subscriptions.find(sub => sub.originalTransactionId === transactionId);\n      return subscription ? {\n        ...subscription\n      } : null;\n    } catch (error) {\n      console.error('Error finding subscription by transaction ID:', error);\n      throw error;\n    }\n  },\n  async updateSubscription(accessCode, updates) {\n    try {\n      const data = loadData();\n      const index = data.subscriptions.findIndex(sub => sub.accessCode === accessCode);\n      if (index === -1) {\n        throw new Error('Subscription not found');\n      }\n\n      // Update the subscription\n      const updatedSubscription = {\n        ...data.subscriptions[index],\n        ...updates,\n        updatedAt: new Date().toISOString()\n      };\n      data.subscriptions[index] = updatedSubscription;\n      saveData(data);\n      return {\n        ...updatedSubscription\n      };\n    } catch (error) {\n      console.error('Error updating subscription:', error);\n      throw error;\n    }\n  },\n  async activateSubscriptionOnDevice(accessCode, deviceId, platform) {\n    try {\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\n      if (!subscription) {\n        throw new Error('Subscription not found');\n      }\n\n      // Initialize activations array if it doesn't exist\n      if (!subscription.activations) {\n        subscription.activations = [];\n      }\n\n      // Check if maximum activations reached\n      if (subscription.activations.length >= (subscription.maxActivations || 3)) {\n        throw new Error('Maximum device activations reached');\n      }\n\n      // Check if device is already activated\n      const isDeviceActivated = subscription.activations.some(a => a.deviceId === deviceId);\n      if (!isDeviceActivated) {\n        subscription.activations.push({\n          deviceId,\n          platform,\n          activatedAt: new Date().toISOString()\n        });\n      }\n\n      // Update the subscription\n      return await this.updateSubscription(accessCode, {\n        activations: subscription.activations\n      });\n    } catch (error) {\n      console.error('Error activating subscription on device:', error);\n      throw error;\n    }\n  },\n  async deactivateSubscriptionOnDevice(accessCode, deviceId) {\n    try {\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\n      if (!subscription) {\n        throw new Error('Subscription not found');\n      }\n\n      // Filter out the device\n      const activations = (subscription.activations || []).filter(a => a.deviceId !== deviceId);\n\n      // Update the subscription\n      return await this.updateSubscription(accessCode, {\n        activations\n      });\n    } catch (error) {\n      console.error('Error deactivating subscription on device:', error);\n      throw error;\n    }\n  },\n  async getAllSubscriptions() {\n    try {\n      const data = loadData();\n      return [...data.subscriptions];\n    } catch (error) {\n      console.error('Error getting all subscriptions:', error);\n      throw error;\n    }\n  },\n  async getActiveSubscriptions() {\n    try {\n      const data = loadData();\n      return data.subscriptions.filter(sub => sub.status === 'active');\n    } catch (error) {\n      console.error('Error getting active subscriptions:', error);\n      throw error;\n    }\n  },\n  // For development/testing only\n  _clearSubscriptions() {\n    saveData({\n      subscriptions: []\n    });\n  }\n};\nexport default inMemoryProvider;","map":{"version":3,"names":["STORAGE_KEY","loadData","storedData","localStorage","getItem","JSON","parse","subscriptions","e","console","error","saveData","data","setItem","stringify","generateId","Math","random","toString","substring","generateAccessCode","chars","code","i","charAt","floor","length","inMemoryProvider","createSubscription","subscriptionData","id","accessCode","newSubscription","createdAt","Date","toISOString","updatedAt","push","getSubscriptionByAccessCode","subscription","find","sub","getSubscriptionByTransactionId","transactionId","originalTransactionId","updateSubscription","updates","index","findIndex","Error","updatedSubscription","activateSubscriptionOnDevice","deviceId","platform","activations","maxActivations","isDeviceActivated","some","a","activatedAt","deactivateSubscriptionOnDevice","filter","getAllSubscriptions","getActiveSubscriptions","status","_clearSubscriptions"],"sources":["C:/Users/juliu/Desktop/web/src/data/inMemoryProvider.js"],"sourcesContent":["// src/data/inMemoryProvider.js\r\n// Simple in-memory storage without any external dependencies\r\n\r\n// In-memory storage using localStorage for persistence\r\nconst STORAGE_KEY = 'subscription_data';\r\n\r\n// Initialize or load existing data\r\nconst loadData = () => {\r\n  try {\r\n    const storedData = localStorage.getItem(STORAGE_KEY);\r\n    return storedData ? JSON.parse(storedData) : { subscriptions: [] };\r\n  } catch (e) {\r\n    console.error('Error loading data from localStorage:', e);\r\n    return { subscriptions: [] };\r\n  }\r\n};\r\n\r\n// Save data to localStorage\r\nconst saveData = (data) => {\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n  } catch (e) {\r\n    console.error('Error saving data to localStorage:', e);\r\n  }\r\n};\r\n\r\n// Generate a simple random ID\r\nconst generateId = () => {\r\n  return Math.random().toString(36).substring(2, 15) + \r\n         Math.random().toString(36).substring(2, 15);\r\n};\r\n\r\n// Generate an access code\r\nconst generateAccessCode = () => {\r\n  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\r\n  let code = '';\r\n  \r\n  for (let i = 0; i < 12; i++) {\r\n    if (i === 4 || i === 8) {\r\n      code += '-';\r\n    }\r\n    code += chars.charAt(Math.floor(Math.random() * chars.length));\r\n  }\r\n  \r\n  return code;\r\n};\r\n\r\nconst inMemoryProvider = {\r\n  // Subscription methods\r\n  async createSubscription(subscriptionData) {\r\n    try {\r\n      const data = loadData();\r\n      \r\n      // Generate an ID and access code if not provided\r\n      const id = subscriptionData.id || generateId();\r\n      const accessCode = subscriptionData.accessCode || generateAccessCode();\r\n      \r\n      const newSubscription = {\r\n        ...subscriptionData,\r\n        id,\r\n        accessCode,\r\n        createdAt: subscriptionData.createdAt || new Date().toISOString(),\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n      \r\n      data.subscriptions.push(newSubscription);\r\n      saveData(data);\r\n      \r\n      return { ...newSubscription };\r\n    } catch (error) {\r\n      console.error('Error creating subscription:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getSubscriptionByAccessCode(accessCode) {\r\n    try {\r\n      const data = loadData();\r\n      const subscription = data.subscriptions.find(sub => sub.accessCode === accessCode);\r\n      return subscription ? { ...subscription } : null;\r\n    } catch (error) {\r\n      console.error('Error finding subscription by access code:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getSubscriptionByTransactionId(transactionId) {\r\n    try {\r\n      const data = loadData();\r\n      const subscription = data.subscriptions.find(sub => \r\n        sub.originalTransactionId === transactionId\r\n      );\r\n      return subscription ? { ...subscription } : null;\r\n    } catch (error) {\r\n      console.error('Error finding subscription by transaction ID:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async updateSubscription(accessCode, updates) {\r\n    try {\r\n      const data = loadData();\r\n      const index = data.subscriptions.findIndex(sub => sub.accessCode === accessCode);\r\n      \r\n      if (index === -1) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n      \r\n      // Update the subscription\r\n      const updatedSubscription = {\r\n        ...data.subscriptions[index],\r\n        ...updates,\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n      \r\n      data.subscriptions[index] = updatedSubscription;\r\n      saveData(data);\r\n      \r\n      return { ...updatedSubscription };\r\n    } catch (error) {\r\n      console.error('Error updating subscription:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async activateSubscriptionOnDevice(accessCode, deviceId, platform) {\r\n    try {\r\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n      \r\n      // Initialize activations array if it doesn't exist\r\n      if (!subscription.activations) {\r\n        subscription.activations = [];\r\n      }\r\n      \r\n      // Check if maximum activations reached\r\n      if (subscription.activations.length >= (subscription.maxActivations || 3)) {\r\n        throw new Error('Maximum device activations reached');\r\n      }\r\n      \r\n      // Check if device is already activated\r\n      const isDeviceActivated = subscription.activations.some(a => a.deviceId === deviceId);\r\n      \r\n      if (!isDeviceActivated) {\r\n        subscription.activations.push({\r\n          deviceId,\r\n          platform,\r\n          activatedAt: new Date().toISOString()\r\n        });\r\n      }\r\n      \r\n      // Update the subscription\r\n      return await this.updateSubscription(accessCode, {\r\n        activations: subscription.activations\r\n      });\r\n    } catch (error) {\r\n      console.error('Error activating subscription on device:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async deactivateSubscriptionOnDevice(accessCode, deviceId) {\r\n    try {\r\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n      \r\n      // Filter out the device\r\n      const activations = (subscription.activations || []).filter(a => a.deviceId !== deviceId);\r\n      \r\n      // Update the subscription\r\n      return await this.updateSubscription(accessCode, {\r\n        activations\r\n      });\r\n    } catch (error) {\r\n      console.error('Error deactivating subscription on device:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getAllSubscriptions() {\r\n    try {\r\n      const data = loadData();\r\n      return [...data.subscriptions];\r\n    } catch (error) {\r\n      console.error('Error getting all subscriptions:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getActiveSubscriptions() {\r\n    try {\r\n      const data = loadData();\r\n      return data.subscriptions.filter(sub => sub.status === 'active');\r\n    } catch (error) {\r\n      console.error('Error getting active subscriptions:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // For development/testing only\r\n  _clearSubscriptions() {\r\n    saveData({ subscriptions: [] });\r\n  }\r\n};\r\n\r\nexport default inMemoryProvider;"],"mappings":"AAAA;AACA;;AAEA;AACA,MAAMA,WAAW,GAAG,mBAAmB;;AAEvC;AACA,MAAMC,QAAQ,GAAGA,CAAA,KAAM;EACrB,IAAI;IACF,MAAMC,UAAU,GAAGC,YAAY,CAACC,OAAO,CAACJ,WAAW,CAAC;IACpD,OAAOE,UAAU,GAAGG,IAAI,CAACC,KAAK,CAACJ,UAAU,CAAC,GAAG;MAAEK,aAAa,EAAE;IAAG,CAAC;EACpE,CAAC,CAAC,OAAOC,CAAC,EAAE;IACVC,OAAO,CAACC,KAAK,CAAC,uCAAuC,EAAEF,CAAC,CAAC;IACzD,OAAO;MAAED,aAAa,EAAE;IAAG,CAAC;EAC9B;AACF,CAAC;;AAED;AACA,MAAMI,QAAQ,GAAIC,IAAI,IAAK;EACzB,IAAI;IACFT,YAAY,CAACU,OAAO,CAACb,WAAW,EAAEK,IAAI,CAACS,SAAS,CAACF,IAAI,CAAC,CAAC;EACzD,CAAC,CAAC,OAAOJ,CAAC,EAAE;IACVC,OAAO,CAACC,KAAK,CAAC,oCAAoC,EAAEF,CAAC,CAAC;EACxD;AACF,CAAC;;AAED;AACA,MAAMO,UAAU,GAAGA,CAAA,KAAM;EACvB,OAAOC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAC3CH,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;AACpD,CAAC;;AAED;AACA,MAAMC,kBAAkB,GAAGA,CAAA,KAAM;EAC/B,MAAMC,KAAK,GAAG,kCAAkC;EAChD,IAAIC,IAAI,GAAG,EAAE;EAEb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IAC3B,IAAIA,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC,EAAE;MACtBD,IAAI,IAAI,GAAG;IACb;IACAA,IAAI,IAAID,KAAK,CAACG,MAAM,CAACR,IAAI,CAACS,KAAK,CAACT,IAAI,CAACC,MAAM,CAAC,CAAC,GAAGI,KAAK,CAACK,MAAM,CAAC,CAAC;EAChE;EAEA,OAAOJ,IAAI;AACb,CAAC;AAED,MAAMK,gBAAgB,GAAG;EACvB;EACA,MAAMC,kBAAkBA,CAACC,gBAAgB,EAAE;IACzC,IAAI;MACF,MAAMjB,IAAI,GAAGX,QAAQ,CAAC,CAAC;;MAEvB;MACA,MAAM6B,EAAE,GAAGD,gBAAgB,CAACC,EAAE,IAAIf,UAAU,CAAC,CAAC;MAC9C,MAAMgB,UAAU,GAAGF,gBAAgB,CAACE,UAAU,IAAIX,kBAAkB,CAAC,CAAC;MAEtE,MAAMY,eAAe,GAAG;QACtB,GAAGH,gBAAgB;QACnBC,EAAE;QACFC,UAAU;QACVE,SAAS,EAAEJ,gBAAgB,CAACI,SAAS,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACjEC,SAAS,EAAE,IAAIF,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;MAEDvB,IAAI,CAACL,aAAa,CAAC8B,IAAI,CAACL,eAAe,CAAC;MACxCrB,QAAQ,CAACC,IAAI,CAAC;MAEd,OAAO;QAAE,GAAGoB;MAAgB,CAAC;IAC/B,CAAC,CAAC,OAAOtB,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,MAAMA,KAAK;IACb;EACF,CAAC;EAED,MAAM4B,2BAA2BA,CAACP,UAAU,EAAE;IAC5C,IAAI;MACF,MAAMnB,IAAI,GAAGX,QAAQ,CAAC,CAAC;MACvB,MAAMsC,YAAY,GAAG3B,IAAI,CAACL,aAAa,CAACiC,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACV,UAAU,KAAKA,UAAU,CAAC;MAClF,OAAOQ,YAAY,GAAG;QAAE,GAAGA;MAAa,CAAC,GAAG,IAAI;IAClD,CAAC,CAAC,OAAO7B,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;MAClE,MAAMA,KAAK;IACb;EACF,CAAC;EAED,MAAMgC,8BAA8BA,CAACC,aAAa,EAAE;IAClD,IAAI;MACF,MAAM/B,IAAI,GAAGX,QAAQ,CAAC,CAAC;MACvB,MAAMsC,YAAY,GAAG3B,IAAI,CAACL,aAAa,CAACiC,IAAI,CAACC,GAAG,IAC9CA,GAAG,CAACG,qBAAqB,KAAKD,aAChC,CAAC;MACD,OAAOJ,YAAY,GAAG;QAAE,GAAGA;MAAa,CAAC,GAAG,IAAI;IAClD,CAAC,CAAC,OAAO7B,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,+CAA+C,EAAEA,KAAK,CAAC;MACrE,MAAMA,KAAK;IACb;EACF,CAAC;EAED,MAAMmC,kBAAkBA,CAACd,UAAU,EAAEe,OAAO,EAAE;IAC5C,IAAI;MACF,MAAMlC,IAAI,GAAGX,QAAQ,CAAC,CAAC;MACvB,MAAM8C,KAAK,GAAGnC,IAAI,CAACL,aAAa,CAACyC,SAAS,CAACP,GAAG,IAAIA,GAAG,CAACV,UAAU,KAAKA,UAAU,CAAC;MAEhF,IAAIgB,KAAK,KAAK,CAAC,CAAC,EAAE;QAChB,MAAM,IAAIE,KAAK,CAAC,wBAAwB,CAAC;MAC3C;;MAEA;MACA,MAAMC,mBAAmB,GAAG;QAC1B,GAAGtC,IAAI,CAACL,aAAa,CAACwC,KAAK,CAAC;QAC5B,GAAGD,OAAO;QACVV,SAAS,EAAE,IAAIF,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC,CAAC;MAEDvB,IAAI,CAACL,aAAa,CAACwC,KAAK,CAAC,GAAGG,mBAAmB;MAC/CvC,QAAQ,CAACC,IAAI,CAAC;MAEd,OAAO;QAAE,GAAGsC;MAAoB,CAAC;IACnC,CAAC,CAAC,OAAOxC,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,MAAMA,KAAK;IACb;EACF,CAAC;EAED,MAAMyC,4BAA4BA,CAACpB,UAAU,EAAEqB,QAAQ,EAAEC,QAAQ,EAAE;IACjE,IAAI;MACF,MAAMd,YAAY,GAAG,MAAM,IAAI,CAACD,2BAA2B,CAACP,UAAU,CAAC;MAEvE,IAAI,CAACQ,YAAY,EAAE;QACjB,MAAM,IAAIU,KAAK,CAAC,wBAAwB,CAAC;MAC3C;;MAEA;MACA,IAAI,CAACV,YAAY,CAACe,WAAW,EAAE;QAC7Bf,YAAY,CAACe,WAAW,GAAG,EAAE;MAC/B;;MAEA;MACA,IAAIf,YAAY,CAACe,WAAW,CAAC5B,MAAM,KAAKa,YAAY,CAACgB,cAAc,IAAI,CAAC,CAAC,EAAE;QACzE,MAAM,IAAIN,KAAK,CAAC,oCAAoC,CAAC;MACvD;;MAEA;MACA,MAAMO,iBAAiB,GAAGjB,YAAY,CAACe,WAAW,CAACG,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACN,QAAQ,KAAKA,QAAQ,CAAC;MAErF,IAAI,CAACI,iBAAiB,EAAE;QACtBjB,YAAY,CAACe,WAAW,CAACjB,IAAI,CAAC;UAC5Be,QAAQ;UACRC,QAAQ;UACRM,WAAW,EAAE,IAAIzB,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;QACtC,CAAC,CAAC;MACJ;;MAEA;MACA,OAAO,MAAM,IAAI,CAACU,kBAAkB,CAACd,UAAU,EAAE;QAC/CuB,WAAW,EAAEf,YAAY,CAACe;MAC5B,CAAC,CAAC;IACJ,CAAC,CAAC,OAAO5C,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;MAChE,MAAMA,KAAK;IACb;EACF,CAAC;EAED,MAAMkD,8BAA8BA,CAAC7B,UAAU,EAAEqB,QAAQ,EAAE;IACzD,IAAI;MACF,MAAMb,YAAY,GAAG,MAAM,IAAI,CAACD,2BAA2B,CAACP,UAAU,CAAC;MAEvE,IAAI,CAACQ,YAAY,EAAE;QACjB,MAAM,IAAIU,KAAK,CAAC,wBAAwB,CAAC;MAC3C;;MAEA;MACA,MAAMK,WAAW,GAAG,CAACf,YAAY,CAACe,WAAW,IAAI,EAAE,EAAEO,MAAM,CAACH,CAAC,IAAIA,CAAC,CAACN,QAAQ,KAAKA,QAAQ,CAAC;;MAEzF;MACA,OAAO,MAAM,IAAI,CAACP,kBAAkB,CAACd,UAAU,EAAE;QAC/CuB;MACF,CAAC,CAAC;IACJ,CAAC,CAAC,OAAO5C,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;MAClE,MAAMA,KAAK;IACb;EACF,CAAC;EAED,MAAMoD,mBAAmBA,CAAA,EAAG;IAC1B,IAAI;MACF,MAAMlD,IAAI,GAAGX,QAAQ,CAAC,CAAC;MACvB,OAAO,CAAC,GAAGW,IAAI,CAACL,aAAa,CAAC;IAChC,CAAC,CAAC,OAAOG,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MACxD,MAAMA,KAAK;IACb;EACF,CAAC;EAED,MAAMqD,sBAAsBA,CAAA,EAAG;IAC7B,IAAI;MACF,MAAMnD,IAAI,GAAGX,QAAQ,CAAC,CAAC;MACvB,OAAOW,IAAI,CAACL,aAAa,CAACsD,MAAM,CAACpB,GAAG,IAAIA,GAAG,CAACuB,MAAM,KAAK,QAAQ,CAAC;IAClE,CAAC,CAAC,OAAOtD,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3D,MAAMA,KAAK;IACb;EACF,CAAC;EAED;EACAuD,mBAAmBA,CAAA,EAAG;IACpBtD,QAAQ,CAAC;MAAEJ,aAAa,EAAE;IAAG,CAAC,CAAC;EACjC;AACF,CAAC;AAED,eAAeoB,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}