{"ast":null,"code":"// src/models/TokenizedSubscription.js\nconst mongoose = require('mongoose');\nconst crypto = require('crypto');\nconst TokenizedSubscriptionSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    index: true\n  },\n  accessToken: {\n    type: String,\n    required: true,\n    unique: true,\n    index: true\n  },\n  mobileAccessCode: {\n    type: String,\n    required: true,\n    unique: true,\n    index: true\n  },\n  plan: {\n    type: String,\n    required: true,\n    enum: ['monthly_premium', 'yearly_premium']\n  },\n  startDate: {\n    type: Date,\n    default: Date.now\n  },\n  expiresAt: {\n    type: Date,\n    required: true\n  },\n  paymentId: {\n    type: String,\n    required: true\n  },\n  active: {\n    type: Boolean,\n    default: true\n  },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\n// Method to verify token\nTokenizedSubscriptionSchema.statics.verifyToken = async function (token) {\n  const subscription = await this.findOne({\n    accessToken: token\n  });\n  if (!subscription) return {\n    valid: false\n  };\n  const isActive = subscription.active && new Date(subscription.expiresAt) > new Date();\n  return {\n    valid: isActive,\n    plan: subscription.plan,\n    expiresAt: subscription.expiresAt\n  };\n};\n\n// Method to verify mobile access code\nTokenizedSubscriptionSchema.statics.verifyMobileCode = async function (code) {\n  const subscription = await this.findOne({\n    mobileAccessCode: code\n  });\n  if (!subscription) return {\n    valid: false\n  };\n  const isActive = subscription.active && new Date(subscription.expiresAt) > new Date();\n  return {\n    valid: isActive,\n    plan: subscription.plan,\n    expiresAt: subscription.expiresAt,\n    accessToken: subscription.accessToken\n  };\n};\n\n// Helper method to generate a secure token\nTokenizedSubscriptionSchema.statics.generateToken = function () {\n  return crypto.randomBytes(32).toString('hex');\n};\n\n// Helper method to generate a user-friendly mobile access code\nTokenizedSubscriptionSchema.statics.generateMobileAccessCode = function () {\n  // Format: XXXX-XXXX-XXXX (12 alphanumeric characters in groups of 4)\n  const code = crypto.randomBytes(6).toString('hex').toUpperCase();\n  return `${code.substring(0, 4)}-${code.substring(4, 8)}-${code.substring(8, 12)}`;\n};\nmodule.exports = mongoose.model('TokenizedSubscription', TokenizedSubscriptionSchema);","map":{"version":3,"names":["mongoose","require","crypto","TokenizedSubscriptionSchema","Schema","email","type","String","required","index","accessToken","unique","mobileAccessCode","plan","enum","startDate","Date","default","now","expiresAt","paymentId","active","Boolean","createdAt","statics","verifyToken","token","subscription","findOne","valid","isActive","verifyMobileCode","code","generateToken","randomBytes","toString","generateMobileAccessCode","toUpperCase","substring","module","exports","model"],"sources":["C:/Users/juliu/Desktop/web/src/models/TokenizedSubscription.js"],"sourcesContent":["// src/models/TokenizedSubscription.js\r\nconst mongoose = require('mongoose');\r\nconst crypto = require('crypto');\r\n\r\nconst TokenizedSubscriptionSchema = new mongoose.Schema({\r\n  email: {\r\n    type: String,\r\n    required: true,\r\n    index: true\r\n  },\r\n  accessToken: {\r\n    type: String,\r\n    required: true,\r\n    unique: true,\r\n    index: true\r\n  },\r\n  mobileAccessCode: {\r\n    type: String,\r\n    required: true,\r\n    unique: true,\r\n    index: true\r\n  },\r\n  plan: {\r\n    type: String,\r\n    required: true,\r\n    enum: ['monthly_premium', 'yearly_premium']\r\n  },\r\n  startDate: {\r\n    type: Date,\r\n    default: Date.now\r\n  },\r\n  expiresAt: {\r\n    type: Date,\r\n    required: true\r\n  },\r\n  paymentId: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  active: {\r\n    type: Boolean,\r\n    default: true\r\n  },\r\n  createdAt: {\r\n    type: Date,\r\n    default: Date.now\r\n  }\r\n});\r\n\r\n// Method to verify token\r\nTokenizedSubscriptionSchema.statics.verifyToken = async function(token) {\r\n  const subscription = await this.findOne({ accessToken: token });\r\n  \r\n  if (!subscription) return { valid: false };\r\n  \r\n  const isActive = subscription.active && new Date(subscription.expiresAt) > new Date();\r\n  \r\n  return {\r\n    valid: isActive,\r\n    plan: subscription.plan,\r\n    expiresAt: subscription.expiresAt\r\n  };\r\n};\r\n\r\n// Method to verify mobile access code\r\nTokenizedSubscriptionSchema.statics.verifyMobileCode = async function(code) {\r\n  const subscription = await this.findOne({ mobileAccessCode: code });\r\n  \r\n  if (!subscription) return { valid: false };\r\n  \r\n  const isActive = subscription.active && new Date(subscription.expiresAt) > new Date();\r\n  \r\n  return {\r\n    valid: isActive,\r\n    plan: subscription.plan,\r\n    expiresAt: subscription.expiresAt,\r\n    accessToken: subscription.accessToken\r\n  };\r\n};\r\n\r\n// Helper method to generate a secure token\r\nTokenizedSubscriptionSchema.statics.generateToken = function() {\r\n  return crypto.randomBytes(32).toString('hex');\r\n};\r\n\r\n// Helper method to generate a user-friendly mobile access code\r\nTokenizedSubscriptionSchema.statics.generateMobileAccessCode = function() {\r\n  // Format: XXXX-XXXX-XXXX (12 alphanumeric characters in groups of 4)\r\n  const code = crypto.randomBytes(6).toString('hex').toUpperCase();\r\n  return `${code.substring(0, 4)}-${code.substring(4, 8)}-${code.substring(8, 12)}`;\r\n};\r\n\r\nmodule.exports = mongoose.model('TokenizedSubscription', TokenizedSubscriptionSchema);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}