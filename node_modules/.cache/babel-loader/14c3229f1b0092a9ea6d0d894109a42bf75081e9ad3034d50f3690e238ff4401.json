{"ast":null,"code":"// src/data/inMemoryProvider.js\nconst fs = require('fs').promises;\nconst path = require('path');\nconst bcrypt = require('bcryptjs');\n\n// Directory for data files\nconst dataDir = path.join(__dirname, '..', '..', 'data');\n\n// Ensure data directory exists\nconst ensureDataDir = async () => {\n  try {\n    await fs.mkdir(dataDir, {\n      recursive: true\n    });\n  } catch (err) {\n    console.error('Error creating data directory:', err);\n  }\n};\n\n// Save data to a JSON file\nconst saveData = async (filename, data) => {\n  await ensureDataDir();\n  const filePath = path.join(dataDir, `${filename}.json`);\n  await fs.writeFile(filePath, JSON.stringify(data, null, 2));\n};\n\n// Load data from a JSON file\nconst loadData = async (filename, defaultData = []) => {\n  await ensureDataDir();\n  const filePath = path.join(dataDir, `${filename}.json`);\n  try {\n    const fileData = await fs.readFile(filePath, 'utf8');\n    return JSON.parse(fileData);\n  } catch (err) {\n    // If file doesn't exist or is invalid, return default data\n    if (err.code === 'ENOENT' || err instanceof SyntaxError) {\n      await saveData(filename, defaultData); // Create the file with default data\n      return defaultData;\n    }\n    throw err;\n  }\n};\n\n// In-memory storage with file persistence\nlet users = [];\nlet subscriptions = [];\nlet nextUserId = 1;\n\n// Initialize data\nconst initData = async () => {\n  users = await loadData('users', []);\n  subscriptions = await loadData('subscriptions', []);\n\n  // Set nextUserId to be one more than the maximum id\n  nextUserId = users.length > 0 ? Math.max(...users.map(user => user.id)) + 1 : 1;\n};\n\n// Initialize on module load\ninitData();\n\n// User methods\nconst userMethods = {\n  async findById(id) {\n    return users.find(user => user.id === parseInt(id)) || null;\n  },\n  async findByEmail(email) {\n    return users.find(user => user.email === email) || null;\n  },\n  async create(userData) {\n    // Check if user exists\n    if (await this.findByEmail(userData.email)) {\n      throw new Error('User already exists');\n    }\n\n    // Hash password\n    const salt = await bcrypt.genSalt(10);\n    const hashedPassword = await bcrypt.hash(userData.password, salt);\n\n    // Create user\n    const newUser = {\n      id: nextUserId++,\n      name: userData.name,\n      email: userData.email,\n      password: hashedPassword,\n      createdAt: new Date()\n    };\n    users.push(newUser);\n\n    // Save to file\n    await saveData('users', users);\n\n    // Return user without password\n    const {\n      password,\n      ...userWithoutPassword\n    } = newUser;\n    return userWithoutPassword;\n  },\n  async update(id, updates) {\n    const index = users.findIndex(user => user.id === parseInt(id));\n    if (index === -1) {\n      throw new Error('User not found');\n    }\n\n    // Update fields\n    users[index] = {\n      ...users[index],\n      ...updates\n    };\n\n    // Save to file\n    await saveData('users', users);\n\n    // Return user without password\n    const {\n      password,\n      ...userWithoutPassword\n    } = users[index];\n    return userWithoutPassword;\n  },\n  async changePassword(id, newPassword) {\n    const index = users.findIndex(user => user.id === parseInt(id));\n    if (index === -1) {\n      throw new Error('User not found');\n    }\n\n    // Hash new password\n    const salt = await bcrypt.genSalt(10);\n    const hashedPassword = await bcrypt.hash(newPassword, salt);\n\n    // Update password\n    users[index].password = hashedPassword;\n\n    // Save to file\n    await saveData('users', users);\n    return true;\n  },\n  async comparePassword(userId, candidatePassword) {\n    const user = await this.findById(userId);\n    if (!user) return false;\n    return bcrypt.compare(candidatePassword, user.password);\n  }\n};\n\n// Subscription methods\nconst subscriptionMethods = {\n  async findByUserId(userId) {\n    return subscriptions.find(sub => sub.userId === parseInt(userId)) || null;\n  },\n  async create(subscriptionData) {\n    const subscription = {\n      id: Date.now().toString(),\n      userId: parseInt(subscriptionData.userId),\n      plan: subscriptionData.plan,\n      startDate: subscriptionData.startDate || new Date(),\n      endDate: subscriptionData.endDate,\n      status: 'active',\n      features: this.getFeaturesForPlan(subscriptionData.plan)\n    };\n    subscriptions.push(subscription);\n\n    // Save to file\n    await saveData('subscriptions', subscriptions);\n    return subscription;\n  },\n  async update(id, updates) {\n    const index = subscriptions.findIndex(sub => sub.id === id);\n    if (index === -1) {\n      return null;\n    }\n    subscriptions[index] = {\n      ...subscriptions[index],\n      ...updates\n    };\n\n    // Save to file\n    await saveData('subscriptions', subscriptions);\n    return subscriptions[index];\n  },\n  async cancel(id) {\n    const index = subscriptions.findIndex(sub => sub.id === id);\n    if (index === -1) {\n      return false;\n    }\n    subscriptions[index].status = 'cancelled';\n\n    // Save to file\n    await saveData('subscriptions', subscriptions);\n    return true;\n  },\n  getFeaturesForPlan(plan) {\n    switch (plan) {\n      case 'free':\n        return {\n          dealAlerts: 3,\n          destinations: 2,\n          customAlerts: false,\n          adFree: false\n        };\n      case 'monthly':\n      case 'yearly':\n      case 'premium':\n        return {\n          dealAlerts: -1,\n          // unlimited\n          destinations: -1,\n          // unlimited\n          customAlerts: true,\n          adFree: true\n        };\n      default:\n        return {\n          dealAlerts: 0,\n          destinations: 0,\n          customAlerts: false,\n          adFree: false\n        };\n    }\n  }\n};\nmodule.exports = {\n  user: userMethods,\n  subscription: subscriptionMethods\n};","map":{"version":3,"names":["fs","require","promises","path","bcrypt","dataDir","join","__dirname","ensureDataDir","mkdir","recursive","err","console","error","saveData","filename","data","filePath","writeFile","JSON","stringify","loadData","defaultData","fileData","readFile","parse","code","SyntaxError","users","subscriptions","nextUserId","initData","length","Math","max","map","user","id","userMethods","findById","find","parseInt","findByEmail","email","create","userData","Error","salt","genSalt","hashedPassword","hash","password","newUser","name","createdAt","Date","push","userWithoutPassword","update","updates","index","findIndex","changePassword","newPassword","comparePassword","userId","candidatePassword","compare","subscriptionMethods","findByUserId","sub","subscriptionData","subscription","now","toString","plan","startDate","endDate","status","features","getFeaturesForPlan","cancel","dealAlerts","destinations","customAlerts","adFree","module","exports"],"sources":["C:/Users/juliu/Desktop/web/src/data/inMemoryProvider.js"],"sourcesContent":["// src/data/inMemoryProvider.js\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst bcrypt = require('bcryptjs');\r\n\r\n// Directory for data files\r\nconst dataDir = path.join(__dirname, '..', '..', 'data');\r\n\r\n// Ensure data directory exists\r\nconst ensureDataDir = async () => {\r\n  try {\r\n    await fs.mkdir(dataDir, { recursive: true });\r\n  } catch (err) {\r\n    console.error('Error creating data directory:', err);\r\n  }\r\n};\r\n\r\n// Save data to a JSON file\r\nconst saveData = async (filename, data) => {\r\n  await ensureDataDir();\r\n  const filePath = path.join(dataDir, `${filename}.json`);\r\n  await fs.writeFile(filePath, JSON.stringify(data, null, 2));\r\n};\r\n\r\n// Load data from a JSON file\r\nconst loadData = async (filename, defaultData = []) => {\r\n  await ensureDataDir();\r\n  const filePath = path.join(dataDir, `${filename}.json`);\r\n  \r\n  try {\r\n    const fileData = await fs.readFile(filePath, 'utf8');\r\n    return JSON.parse(fileData);\r\n  } catch (err) {\r\n    // If file doesn't exist or is invalid, return default data\r\n    if (err.code === 'ENOENT' || err instanceof SyntaxError) {\r\n      await saveData(filename, defaultData); // Create the file with default data\r\n      return defaultData;\r\n    }\r\n    throw err;\r\n  }\r\n};\r\n\r\n// In-memory storage with file persistence\r\nlet users = [];\r\nlet subscriptions = [];\r\nlet nextUserId = 1;\r\n\r\n// Initialize data\r\nconst initData = async () => {\r\n  users = await loadData('users', []);\r\n  subscriptions = await loadData('subscriptions', []);\r\n  \r\n  // Set nextUserId to be one more than the maximum id\r\n  nextUserId = users.length > 0 \r\n    ? Math.max(...users.map(user => user.id)) + 1 \r\n    : 1;\r\n};\r\n\r\n// Initialize on module load\r\ninitData();\r\n\r\n// User methods\r\nconst userMethods = {\r\n  async findById(id) {\r\n    return users.find(user => user.id === parseInt(id)) || null;\r\n  },\r\n  \r\n  async findByEmail(email) {\r\n    return users.find(user => user.email === email) || null;\r\n  },\r\n  \r\n  async create(userData) {\r\n    // Check if user exists\r\n    if (await this.findByEmail(userData.email)) {\r\n      throw new Error('User already exists');\r\n    }\r\n    \r\n    // Hash password\r\n    const salt = await bcrypt.genSalt(10);\r\n    const hashedPassword = await bcrypt.hash(userData.password, salt);\r\n    \r\n    // Create user\r\n    const newUser = {\r\n      id: nextUserId++,\r\n      name: userData.name,\r\n      email: userData.email,\r\n      password: hashedPassword,\r\n      createdAt: new Date()\r\n    };\r\n    \r\n    users.push(newUser);\r\n    \r\n    // Save to file\r\n    await saveData('users', users);\r\n    \r\n    // Return user without password\r\n    const { password, ...userWithoutPassword } = newUser;\r\n    return userWithoutPassword;\r\n  },\r\n  \r\n  async update(id, updates) {\r\n    const index = users.findIndex(user => user.id === parseInt(id));\r\n    \r\n    if (index === -1) {\r\n      throw new Error('User not found');\r\n    }\r\n    \r\n    // Update fields\r\n    users[index] = { ...users[index], ...updates };\r\n    \r\n    // Save to file\r\n    await saveData('users', users);\r\n    \r\n    // Return user without password\r\n    const { password, ...userWithoutPassword } = users[index];\r\n    return userWithoutPassword;\r\n  },\r\n  \r\n  async changePassword(id, newPassword) {\r\n    const index = users.findIndex(user => user.id === parseInt(id));\r\n    \r\n    if (index === -1) {\r\n      throw new Error('User not found');\r\n    }\r\n    \r\n    // Hash new password\r\n    const salt = await bcrypt.genSalt(10);\r\n    const hashedPassword = await bcrypt.hash(newPassword, salt);\r\n    \r\n    // Update password\r\n    users[index].password = hashedPassword;\r\n    \r\n    // Save to file\r\n    await saveData('users', users);\r\n    \r\n    return true;\r\n  },\r\n  \r\n  async comparePassword(userId, candidatePassword) {\r\n    const user = await this.findById(userId);\r\n    if (!user) return false;\r\n    \r\n    return bcrypt.compare(candidatePassword, user.password);\r\n  }\r\n};\r\n\r\n// Subscription methods\r\nconst subscriptionMethods = {\r\n  async findByUserId(userId) {\r\n    return subscriptions.find(sub => sub.userId === parseInt(userId)) || null;\r\n  },\r\n  \r\n  async create(subscriptionData) {\r\n    const subscription = {\r\n      id: Date.now().toString(),\r\n      userId: parseInt(subscriptionData.userId),\r\n      plan: subscriptionData.plan,\r\n      startDate: subscriptionData.startDate || new Date(),\r\n      endDate: subscriptionData.endDate,\r\n      status: 'active',\r\n      features: this.getFeaturesForPlan(subscriptionData.plan)\r\n    };\r\n    \r\n    subscriptions.push(subscription);\r\n    \r\n    // Save to file\r\n    await saveData('subscriptions', subscriptions);\r\n    \r\n    return subscription;\r\n  },\r\n  \r\n  async update(id, updates) {\r\n    const index = subscriptions.findIndex(sub => sub.id === id);\r\n    \r\n    if (index === -1) {\r\n      return null;\r\n    }\r\n    \r\n    subscriptions[index] = { ...subscriptions[index], ...updates };\r\n    \r\n    // Save to file\r\n    await saveData('subscriptions', subscriptions);\r\n    \r\n    return subscriptions[index];\r\n  },\r\n  \r\n  async cancel(id) {\r\n    const index = subscriptions.findIndex(sub => sub.id === id);\r\n    \r\n    if (index === -1) {\r\n      return false;\r\n    }\r\n    \r\n    subscriptions[index].status = 'cancelled';\r\n    \r\n    // Save to file\r\n    await saveData('subscriptions', subscriptions);\r\n    \r\n    return true;\r\n  },\r\n  \r\n  getFeaturesForPlan(plan) {\r\n    switch (plan) {\r\n      case 'free':\r\n        return {\r\n          dealAlerts: 3,\r\n          destinations: 2,\r\n          customAlerts: false,\r\n          adFree: false\r\n        };\r\n      case 'monthly':\r\n      case 'yearly':\r\n      case 'premium':\r\n        return {\r\n          dealAlerts: -1, // unlimited\r\n          destinations: -1, // unlimited\r\n          customAlerts: true,\r\n          adFree: true\r\n        };\r\n      default:\r\n        return {\r\n          dealAlerts: 0,\r\n          destinations: 0,\r\n          customAlerts: false,\r\n          adFree: false\r\n        };\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  user: userMethods,\r\n  subscription: subscriptionMethods\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}