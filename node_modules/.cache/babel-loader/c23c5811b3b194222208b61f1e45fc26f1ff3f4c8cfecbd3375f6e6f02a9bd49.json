{"ast":null,"code":"/**\r\n * Geocoding Service\r\n * Provides geocoding functionality using OpenStreetMap Nominatim API\r\n * \r\n * This service handles:\r\n * - Forward geocoding (location name to coordinates)\r\n * - Reverse geocoding (coordinates to location name)\r\n * - Geocoding for autocomplete suggestions\r\n */\n\n// Base API URL for Nominatim (OpenStreetMap)\nconst NOMINATIM_API_BASE = 'https://nominatim.openstreetmap.org';\n\n/**\r\n * Convert a location name to geographic coordinates (forward geocoding)\r\n * \r\n * @param {string} location Location name (e.g., city, address)\r\n * @returns {Promise<Object>} Promise that resolves to geocoding data\r\n */\nexport const geocodeLocation = async location => {\n  if (!location) {\n    throw new Error('Location is required');\n  }\n  try {\n    var _result$address$count;\n    // Build API URL with parameters\n    const url = new URL(`${NOMINATIM_API_BASE}/search`);\n    url.search = new URLSearchParams({\n      q: location,\n      format: 'json',\n      limit: 1,\n      addressdetails: 1\n    }).toString();\n\n    // Make API request\n    const response = await fetch(url, {\n      headers: {\n        'User-Agent': 'TravelEase/1.0'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Geocoding failed: ${response.status} ${response.statusText}`);\n    }\n\n    // Parse response\n    const data = await response.json();\n\n    // Check if result was found\n    if (!data || data.length === 0) {\n      throw new Error(`No location found for: ${location}`);\n    }\n\n    // Extract and return relevant data\n    const result = data[0];\n    return {\n      lat: parseFloat(result.lat),\n      lon: parseFloat(result.lon),\n      name: result.display_name.split(',')[0],\n      fullName: result.display_name,\n      country: result.address.country,\n      countryCode: (_result$address$count = result.address.country_code) === null || _result$address$count === void 0 ? void 0 : _result$address$count.toUpperCase(),\n      city: result.address.city || result.address.town || result.address.village,\n      state: result.address.state || result.address.province,\n      type: result.type,\n      osm_id: result.osm_id\n    };\n  } catch (error) {\n    console.error(`Error geocoding location \"${location}\":`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Get location suggestions for autocomplete\r\n * \r\n * @param {string} query Partial location query\r\n * @param {number} limit Maximum number of results (default: 5)\r\n * @returns {Promise<Array<Object>>} Promise that resolves to an array of location suggestions\r\n */\nexport const getLocationSuggestions = async (query, limit = 5) => {\n  if (!query || query.length < 3) {\n    return [];\n  }\n  try {\n    // Build API URL with parameters\n    const url = new URL(`${NOMINATIM_API_BASE}/search`);\n    url.search = new URLSearchParams({\n      q: query,\n      format: 'json',\n      limit: limit,\n      addressdetails: 1\n    }).toString();\n\n    // Make API request\n    const response = await fetch(url, {\n      headers: {\n        'User-Agent': 'TravelEase/1.0'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Autocomplete suggestion failed: ${response.status} ${response.statusText}`);\n    }\n\n    // Parse response\n    const data = await response.json();\n\n    // Transform the results into a simpler format\n    return data.map(result => {\n      var _result$address$count2;\n      return {\n        id: result.place_id,\n        name: result.display_name.split(',')[0],\n        fullName: result.display_name,\n        type: result.type,\n        lat: parseFloat(result.lat),\n        lon: parseFloat(result.lon),\n        country: result.address.country,\n        countryCode: (_result$address$count2 = result.address.country_code) === null || _result$address$count2 === void 0 ? void 0 : _result$address$count2.toUpperCase(),\n        city: result.address.city || result.address.town || result.address.village\n      };\n    });\n  } catch (error) {\n    console.error(`Error getting location suggestions for \"${query}\":`, error);\n    return []; // Return empty array instead of throwing to avoid breaking the UI\n  }\n};\n\n/**\r\n * Calculate distance between two geographic coordinates\r\n * \r\n * @param {number} lat1 Latitude of first point\r\n * @param {number} lon1 Longitude of first point\r\n * @param {number} lat2 Latitude of second point\r\n * @param {number} lon2 Longitude of second point\r\n * @param {string} unit Unit of measurement ('km' or 'mi')\r\n * @returns {number} Distance between the two points in the specified unit\r\n */\nexport const calculateDistance = (lat1, lon1, lat2, lon2, unit = 'km') => {\n  if (lat1 === lat2 && lon1 === lon2) {\n    return 0;\n  }\n\n  // Convert degrees to radians\n  const radLat1 = Math.PI * lat1 / 180;\n  const radLon1 = Math.PI * lon1 / 180;\n  const radLat2 = Math.PI * lat2 / 180;\n  const radLon2 = Math.PI * lon2 / 180;\n\n  // Haversine formula\n  const dLat = radLat2 - radLat1;\n  const dLon = radLon2 - radLon1;\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  // Earth's radius in kilometers\n  const earthRadius = 6371;\n\n  // Calculate distance\n  let distance = earthRadius * c;\n\n  // Convert to miles if necessary\n  if (unit === 'mi') {\n    distance *= 0.621371;\n  }\n  return distance;\n};\n\n/**\r\n * Convert geographic coordinates to a location name (reverse geocoding)\r\n * \r\n * @param {number} latitude Latitude coordinate\r\n * @param {number} longitude Longitude coordinate\r\n * @returns {Promise<Object>} Promise that resolves to reverse geocoding data\r\n */\nexport const reverseGeocode = async (latitude, longitude) => {\n  if (latitude === undefined || longitude === undefined) {\n    throw new Error('Latitude and longitude are required');\n  }\n  try {\n    var _data$address$country;\n    // Build API URL with parameters\n    const url = new URL(`${NOMINATIM_API_BASE}/reverse`);\n    url.search = new URLSearchParams({\n      lat: latitude,\n      lon: longitude,\n      format: 'json',\n      addressdetails: 1\n    }).toString();\n\n    // Make API request\n    const response = await fetch(url, {\n      headers: {\n        'User-Agent': 'TravelEase/1.0'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Reverse geocoding failed: ${response.status} ${response.statusText}`);\n    }\n\n    // Parse response\n    const data = await response.json();\n\n    // Extract and return relevant data\n    return {\n      name: data.address.city || data.address.town || data.address.village || data.address.hamlet || data.address.suburb,\n      fullName: data.display_name,\n      country: data.address.country,\n      countryCode: (_data$address$country = data.address.country_code) === null || _data$address$country === void 0 ? void 0 : _data$address$country.toUpperCase(),\n      city: data.address.city || data.address.town || data.address.village,\n      state: data.address.state || data.address.province,\n      type: data.type,\n      osm_id: data.osm_id,\n      lat: parseFloat(data.lat),\n      lon: parseFloat(data.lon)\n    };\n  } catch (error) {\n    console.error(`Error reverse geocoding coordinates (${latitude}, ${longitude}):`, error);\n    throw error;\n  }\n};","map":{"version":3,"names":["NOMINATIM_API_BASE","geocodeLocation","location","Error","_result$address$count","url","URL","search","URLSearchParams","q","format","limit","addressdetails","toString","response","fetch","headers","ok","status","statusText","data","json","length","result","lat","parseFloat","lon","name","display_name","split","fullName","country","address","countryCode","country_code","toUpperCase","city","town","village","state","province","type","osm_id","error","console","getLocationSuggestions","query","map","_result$address$count2","id","place_id","calculateDistance","lat1","lon1","lat2","lon2","unit","radLat1","Math","PI","radLon1","radLat2","radLon2","dLat","dLon","a","sin","cos","c","atan2","sqrt","earthRadius","distance","reverseGeocode","latitude","longitude","undefined","_data$address$country","hamlet","suburb"],"sources":["C:/Users/juliu/Desktop/web/src/services/geocodingService.js"],"sourcesContent":["/**\r\n * Geocoding Service\r\n * Provides geocoding functionality using OpenStreetMap Nominatim API\r\n * \r\n * This service handles:\r\n * - Forward geocoding (location name to coordinates)\r\n * - Reverse geocoding (coordinates to location name)\r\n * - Geocoding for autocomplete suggestions\r\n */\r\n\r\n// Base API URL for Nominatim (OpenStreetMap)\r\nconst NOMINATIM_API_BASE = 'https://nominatim.openstreetmap.org';\r\n\r\n/**\r\n * Convert a location name to geographic coordinates (forward geocoding)\r\n * \r\n * @param {string} location Location name (e.g., city, address)\r\n * @returns {Promise<Object>} Promise that resolves to geocoding data\r\n */\r\nexport const geocodeLocation = async (location) => {\r\n  if (!location) {\r\n    throw new Error('Location is required');\r\n  }\r\n  \r\n  try {\r\n    // Build API URL with parameters\r\n    const url = new URL(`${NOMINATIM_API_BASE}/search`);\r\n    url.search = new URLSearchParams({\r\n      q: location,\r\n      format: 'json',\r\n      limit: 1,\r\n      addressdetails: 1\r\n    }).toString();\r\n    \r\n    // Make API request\r\n    const response = await fetch(url, {\r\n      headers: {\r\n        'User-Agent': 'TravelEase/1.0'\r\n      }\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Geocoding failed: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    // Parse response\r\n    const data = await response.json();\r\n    \r\n    // Check if result was found\r\n    if (!data || data.length === 0) {\r\n      throw new Error(`No location found for: ${location}`);\r\n    }\r\n    \r\n    // Extract and return relevant data\r\n    const result = data[0];\r\n    return {\r\n      lat: parseFloat(result.lat),\r\n      lon: parseFloat(result.lon),\r\n      name: result.display_name.split(',')[0],\r\n      fullName: result.display_name,\r\n      country: result.address.country,\r\n      countryCode: result.address.country_code?.toUpperCase(),\r\n      city: result.address.city || result.address.town || result.address.village,\r\n      state: result.address.state || result.address.province,\r\n      type: result.type,\r\n      osm_id: result.osm_id\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error geocoding location \"${location}\":`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get location suggestions for autocomplete\r\n * \r\n * @param {string} query Partial location query\r\n * @param {number} limit Maximum number of results (default: 5)\r\n * @returns {Promise<Array<Object>>} Promise that resolves to an array of location suggestions\r\n */\r\nexport const getLocationSuggestions = async (query, limit = 5) => {\r\n  if (!query || query.length < 3) {\r\n    return [];\r\n  }\r\n  \r\n  try {\r\n    // Build API URL with parameters\r\n    const url = new URL(`${NOMINATIM_API_BASE}/search`);\r\n    url.search = new URLSearchParams({\r\n      q: query,\r\n      format: 'json',\r\n      limit: limit,\r\n      addressdetails: 1\r\n    }).toString();\r\n    \r\n    // Make API request\r\n    const response = await fetch(url, {\r\n      headers: {\r\n        'User-Agent': 'TravelEase/1.0'\r\n      }\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Autocomplete suggestion failed: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    // Parse response\r\n    const data = await response.json();\r\n    \r\n    // Transform the results into a simpler format\r\n    return data.map(result => ({\r\n      id: result.place_id,\r\n      name: result.display_name.split(',')[0],\r\n      fullName: result.display_name,\r\n      type: result.type,\r\n      lat: parseFloat(result.lat),\r\n      lon: parseFloat(result.lon),\r\n      country: result.address.country,\r\n      countryCode: result.address.country_code?.toUpperCase(),\r\n      city: result.address.city || result.address.town || result.address.village\r\n    }));\r\n  } catch (error) {\r\n    console.error(`Error getting location suggestions for \"${query}\":`, error);\r\n    return []; // Return empty array instead of throwing to avoid breaking the UI\r\n  }\r\n};\r\n\r\n/**\r\n * Calculate distance between two geographic coordinates\r\n * \r\n * @param {number} lat1 Latitude of first point\r\n * @param {number} lon1 Longitude of first point\r\n * @param {number} lat2 Latitude of second point\r\n * @param {number} lon2 Longitude of second point\r\n * @param {string} unit Unit of measurement ('km' or 'mi')\r\n * @returns {number} Distance between the two points in the specified unit\r\n */\r\nexport const calculateDistance = (lat1, lon1, lat2, lon2, unit = 'km') => {\r\n  if (lat1 === lat2 && lon1 === lon2) {\r\n    return 0;\r\n  }\r\n  \r\n  // Convert degrees to radians\r\n  const radLat1 = (Math.PI * lat1) / 180;\r\n  const radLon1 = (Math.PI * lon1) / 180;\r\n  const radLat2 = (Math.PI * lat2) / 180;\r\n  const radLon2 = (Math.PI * lon2) / 180;\r\n  \r\n  // Haversine formula\r\n  const dLat = radLat2 - radLat1;\r\n  const dLon = radLon2 - radLon1;\r\n  const a = \r\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n    Math.cos(radLat1) * Math.cos(radLat2) * \r\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  \r\n  // Earth's radius in kilometers\r\n  const earthRadius = 6371;\r\n  \r\n  // Calculate distance\r\n  let distance = earthRadius * c;\r\n  \r\n  // Convert to miles if necessary\r\n  if (unit === 'mi') {\r\n    distance *= 0.621371;\r\n  }\r\n  \r\n  return distance;\r\n};\r\n\r\n/**\r\n * Convert geographic coordinates to a location name (reverse geocoding)\r\n * \r\n * @param {number} latitude Latitude coordinate\r\n * @param {number} longitude Longitude coordinate\r\n * @returns {Promise<Object>} Promise that resolves to reverse geocoding data\r\n */\r\nexport const reverseGeocode = async (latitude, longitude) => {\r\n  if (latitude === undefined || longitude === undefined) {\r\n    throw new Error('Latitude and longitude are required');\r\n  }\r\n  \r\n  try {\r\n    // Build API URL with parameters\r\n    const url = new URL(`${NOMINATIM_API_BASE}/reverse`);\r\n    url.search = new URLSearchParams({\r\n      lat: latitude,\r\n      lon: longitude,\r\n      format: 'json',\r\n      addressdetails: 1\r\n    }).toString();\r\n    \r\n    // Make API request\r\n    const response = await fetch(url, {\r\n      headers: {\r\n        'User-Agent': 'TravelEase/1.0'\r\n      }\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Reverse geocoding failed: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    // Parse response\r\n    const data = await response.json();\r\n    \r\n    // Extract and return relevant data\r\n    return {\r\n      name: data.address.city || data.address.town || data.address.village || data.address.hamlet || data.address.suburb,\r\n      fullName: data.display_name,\r\n      country: data.address.country,\r\n      countryCode: data.address.country_code?.toUpperCase(),\r\n      city: data.address.city || data.address.town || data.address.village,\r\n      state: data.address.state || data.address.province,\r\n      type: data.type,\r\n      osm_id: data.osm_id,\r\n      lat: parseFloat(data.lat),\r\n      lon: parseFloat(data.lon)\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error reverse geocoding coordinates (${latitude}, ${longitude}):`, error);\r\n    throw error;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}