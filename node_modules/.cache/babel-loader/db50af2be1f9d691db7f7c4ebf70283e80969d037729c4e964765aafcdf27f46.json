{"ast":null,"code":"// src/services/SubscriptionService.js\nimport { v4 as uuidv4 } from 'uuid';\nimport dataProvider from '../data/dataProvider';\nimport stripeService from './stripeService';\nimport analyticsService from './analyticsService';\nimport { captureError } from '../utils/errorMonitoring';\nclass SubscriptionService {\n  constructor() {\n    this.currentSubscription = null;\n    this.deviceId = this.getOrCreateDeviceId();\n  }\n\n  // Get or create a unique device ID\n  getOrCreateDeviceId() {\n    let deviceId = localStorage.getItem('deviceId');\n    if (!deviceId) {\n      deviceId = uuidv4();\n      localStorage.setItem('deviceId', deviceId);\n    }\n    return deviceId;\n  }\n\n  // Create a new subscription using Stripe\n  async createSubscription(planId, paymentMethodId) {\n    try {\n      // Create a subscription with Stripe\n      const stripeSubscription = await stripeService.createSubscription(paymentMethodId, planId);\n\n      // Generate a unique access code\n      const accessCode = this.generateAccessCode();\n\n      // Store the subscription in our database\n      const subscription = await dataProvider.createSubscription({\n        accessCode,\n        platform: 'web',\n        originalTransactionId: stripeSubscription.id,\n        status: 'active',\n        expiresAt: new Date(stripeSubscription.current_period_end * 1000),\n        planId,\n        deviceId: this.deviceId,\n        activations: [{\n          deviceId: this.deviceId,\n          platform: 'web',\n          activatedAt: new Date()\n        }]\n      });\n\n      // Set as current subscription\n      this.currentSubscription = subscription;\n      localStorage.setItem('accessCode', accessCode);\n\n      // Track the subscription event\n      analyticsService.trackSubscriptionStarted(planId, stripeSubscription.plan.amount / 100, 'web');\n      return subscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Creating subscription'\n      });\n      throw error;\n    }\n  }\n\n  // Activate a subscription using an access code\n  async activateWithCode(accessCode) {\n    try {\n      // Check if the code is valid\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\n      if (!subscription) {\n        throw new Error('Invalid access code');\n      }\n      if (subscription.status !== 'active') {\n        throw new Error('Subscription is not active');\n      }\n\n      // Activate the subscription on this device\n      const activatedSubscription = await dataProvider.activateSubscriptionOnDevice(accessCode, this.deviceId, 'web');\n\n      // Set as current subscription\n      this.currentSubscription = activatedSubscription;\n      localStorage.setItem('accessCode', accessCode);\n\n      // Track code activation\n      const daysRemaining = Math.ceil((new Date(subscription.expiresAt) - new Date()) / (1000 * 60 * 60 * 24));\n      analyticsService.trackCodeActivated('web', daysRemaining);\n      return activatedSubscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Activating subscription with code'\n      });\n      throw error;\n    }\n  }\n\n  // Cancel a subscription\n  async cancelSubscription() {\n    try {\n      if (!this.currentSubscription) {\n        throw new Error('No active subscription');\n      }\n\n      // Cancel with Stripe if it's a web subscription\n      if (this.currentSubscription.platform === 'web') {\n        await stripeService.cancelSubscription(this.currentSubscription.originalTransactionId);\n      }\n\n      // Update subscription status in database\n      const updatedSubscription = await dataProvider.updateSubscription(this.currentSubscription.accessCode, {\n        status: 'cancelled'\n      });\n\n      // Track cancellation\n      const createdAt = new Date(this.currentSubscription.createdAt);\n      const daysSinceSubscribed = Math.floor((new Date() - createdAt) / (1000 * 60 * 60 * 24));\n      analyticsService.trackSubscriptionCancelled(this.currentSubscription.planId, 'user_initiated', daysSinceSubscribed);\n\n      // Clear current subscription\n      this.currentSubscription = null;\n      localStorage.removeItem('accessCode');\n      return updatedSubscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Cancelling subscription'\n      });\n      throw error;\n    }\n  }\n\n  // Check current subscription status\n  async checkSubscription() {\n    try {\n      const accessCode = localStorage.getItem('accessCode');\n      if (!accessCode) {\n        return null;\n      }\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\n      if (!subscription || subscription.status !== 'active') {\n        localStorage.removeItem('accessCode');\n        this.currentSubscription = null;\n        return null;\n      }\n\n      // Check if subscription is expired\n      if (new Date(subscription.expiresAt) < new Date()) {\n        // Update subscription status to expired\n        await dataProvider.updateSubscription(accessCode, {\n          status: 'expired'\n        });\n        localStorage.removeItem('accessCode');\n        this.currentSubscription = null;\n        return null;\n      }\n      this.currentSubscription = subscription;\n      return subscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Checking subscription'\n      });\n      // Return null instead of throwing, to prevent app crashes on status checks\n      return null;\n    }\n  }\n\n  // Check if a specific feature is available with the current subscription\n  async isFeatureAvailable(featureName) {\n    try {\n      const subscription = await this.checkSubscription();\n      if (!subscription) {\n        return false;\n      }\n\n      // In a real implementation, you would check if the specific plan includes this feature\n      // For simplicity, we'll assume all subscriptions include all premium features\n\n      // Track premium feature usage\n      analyticsService.trackPremiumFeatureUsed(featureName);\n      return true;\n    } catch (error) {\n      captureError(error, {\n        context: 'Checking feature availability'\n      });\n      return false;\n    }\n  }\n\n  // Get current subscription\n  async getCurrentSubscription() {\n    return await this.checkSubscription();\n  }\n\n  // Generate a random access code\n  generateAccessCode() {\n    // Format: XXXX-XXXX-XXXX (where X is alphanumeric)\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\n    let code = '';\n    for (let i = 0; i < 12; i++) {\n      if (i === 4 || i === 8) {\n        code += '-';\n      }\n      code += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return code;\n  }\n}\nexport default new SubscriptionService();","map":{"version":3,"names":["v4","uuidv4","dataProvider","stripeService","analyticsService","captureError","SubscriptionService","constructor","currentSubscription","deviceId","getOrCreateDeviceId","localStorage","getItem","setItem","createSubscription","planId","paymentMethodId","stripeSubscription","accessCode","generateAccessCode","subscription","platform","originalTransactionId","id","status","expiresAt","Date","current_period_end","activations","activatedAt","trackSubscriptionStarted","plan","amount","error","context","activateWithCode","getSubscriptionByAccessCode","Error","activatedSubscription","activateSubscriptionOnDevice","daysRemaining","Math","ceil","trackCodeActivated","cancelSubscription","updatedSubscription","updateSubscription","createdAt","daysSinceSubscribed","floor","trackSubscriptionCancelled","removeItem","checkSubscription","isFeatureAvailable","featureName","trackPremiumFeatureUsed","getCurrentSubscription","chars","code","i","charAt","random","length"],"sources":["C:/Users/juliu/Desktop/web/src/services/SubscriptionService.js"],"sourcesContent":["// src/services/SubscriptionService.js\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport dataProvider from '../data/dataProvider';\r\nimport stripeService from './stripeService';\r\nimport analyticsService from './analyticsService';\r\nimport { captureError } from '../utils/errorMonitoring';\r\n\r\nclass SubscriptionService {\r\n  constructor() {\r\n    this.currentSubscription = null;\r\n    this.deviceId = this.getOrCreateDeviceId();\r\n  }\r\n\r\n  // Get or create a unique device ID\r\n  getOrCreateDeviceId() {\r\n    let deviceId = localStorage.getItem('deviceId');\r\n    if (!deviceId) {\r\n      deviceId = uuidv4();\r\n      localStorage.setItem('deviceId', deviceId);\r\n    }\r\n    return deviceId;\r\n  }\r\n\r\n  // Create a new subscription using Stripe\r\n  async createSubscription(planId, paymentMethodId) {\r\n    try {\r\n      // Create a subscription with Stripe\r\n      const stripeSubscription = await stripeService.createSubscription(paymentMethodId, planId);\r\n      \r\n      // Generate a unique access code\r\n      const accessCode = this.generateAccessCode();\r\n      \r\n      // Store the subscription in our database\r\n      const subscription = await dataProvider.createSubscription({\r\n        accessCode,\r\n        platform: 'web',\r\n        originalTransactionId: stripeSubscription.id,\r\n        status: 'active',\r\n        expiresAt: new Date(stripeSubscription.current_period_end * 1000),\r\n        planId,\r\n        deviceId: this.deviceId,\r\n        activations: [\r\n          {\r\n            deviceId: this.deviceId,\r\n            platform: 'web',\r\n            activatedAt: new Date()\r\n          }\r\n        ]\r\n      });\r\n      \r\n      // Set as current subscription\r\n      this.currentSubscription = subscription;\r\n      localStorage.setItem('accessCode', accessCode);\r\n      \r\n      // Track the subscription event\r\n      analyticsService.trackSubscriptionStarted(\r\n        planId, \r\n        stripeSubscription.plan.amount / 100,\r\n        'web'\r\n      );\r\n      \r\n      return subscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Creating subscription' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Activate a subscription using an access code\r\n  async activateWithCode(accessCode) {\r\n    try {\r\n      // Check if the code is valid\r\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription) {\r\n        throw new Error('Invalid access code');\r\n      }\r\n      \r\n      if (subscription.status !== 'active') {\r\n        throw new Error('Subscription is not active');\r\n      }\r\n      \r\n      // Activate the subscription on this device\r\n      const activatedSubscription = await dataProvider.activateSubscriptionOnDevice(\r\n        accessCode,\r\n        this.deviceId,\r\n        'web'\r\n      );\r\n      \r\n      // Set as current subscription\r\n      this.currentSubscription = activatedSubscription;\r\n      localStorage.setItem('accessCode', accessCode);\r\n      \r\n      // Track code activation\r\n      const daysRemaining = Math.ceil((new Date(subscription.expiresAt) - new Date()) / (1000 * 60 * 60 * 24));\r\n      analyticsService.trackCodeActivated('web', daysRemaining);\r\n      \r\n      return activatedSubscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Activating subscription with code' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Cancel a subscription\r\n  async cancelSubscription() {\r\n    try {\r\n      if (!this.currentSubscription) {\r\n        throw new Error('No active subscription');\r\n      }\r\n      \r\n      // Cancel with Stripe if it's a web subscription\r\n      if (this.currentSubscription.platform === 'web') {\r\n        await stripeService.cancelSubscription(this.currentSubscription.originalTransactionId);\r\n      }\r\n      \r\n      // Update subscription status in database\r\n      const updatedSubscription = await dataProvider.updateSubscription(\r\n        this.currentSubscription.accessCode,\r\n        { status: 'cancelled' }\r\n      );\r\n      \r\n      // Track cancellation\r\n      const createdAt = new Date(this.currentSubscription.createdAt);\r\n      const daysSinceSubscribed = Math.floor((new Date() - createdAt) / (1000 * 60 * 60 * 24));\r\n      \r\n      analyticsService.trackSubscriptionCancelled(\r\n        this.currentSubscription.planId,\r\n        'user_initiated',\r\n        daysSinceSubscribed\r\n      );\r\n      \r\n      // Clear current subscription\r\n      this.currentSubscription = null;\r\n      localStorage.removeItem('accessCode');\r\n      \r\n      return updatedSubscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Cancelling subscription' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Check current subscription status\r\n  async checkSubscription() {\r\n    try {\r\n      const accessCode = localStorage.getItem('accessCode');\r\n      \r\n      if (!accessCode) {\r\n        return null;\r\n      }\r\n      \r\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription || subscription.status !== 'active') {\r\n        localStorage.removeItem('accessCode');\r\n        this.currentSubscription = null;\r\n        return null;\r\n      }\r\n      \r\n      // Check if subscription is expired\r\n      if (new Date(subscription.expiresAt) < new Date()) {\r\n        // Update subscription status to expired\r\n        await dataProvider.updateSubscription(accessCode, { status: 'expired' });\r\n        localStorage.removeItem('accessCode');\r\n        this.currentSubscription = null;\r\n        return null;\r\n      }\r\n      \r\n      this.currentSubscription = subscription;\r\n      return subscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Checking subscription' });\r\n      // Return null instead of throwing, to prevent app crashes on status checks\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Check if a specific feature is available with the current subscription\r\n  async isFeatureAvailable(featureName) {\r\n    try {\r\n      const subscription = await this.checkSubscription();\r\n      \r\n      if (!subscription) {\r\n        return false;\r\n      }\r\n      \r\n      // In a real implementation, you would check if the specific plan includes this feature\r\n      // For simplicity, we'll assume all subscriptions include all premium features\r\n      \r\n      // Track premium feature usage\r\n      analyticsService.trackPremiumFeatureUsed(featureName);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Checking feature availability' });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Get current subscription\r\n  async getCurrentSubscription() {\r\n    return await this.checkSubscription();\r\n  }\r\n\r\n  // Generate a random access code\r\n  generateAccessCode() {\r\n    // Format: XXXX-XXXX-XXXX (where X is alphanumeric)\r\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\r\n    let code = '';\r\n    \r\n    for (let i = 0; i < 12; i++) {\r\n      if (i === 4 || i === 8) {\r\n        code += '-';\r\n      }\r\n      code += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    \r\n    return code;\r\n  }\r\n}\r\n\r\nexport default new SubscriptionService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}