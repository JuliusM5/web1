{"ast":null,"code":"// src/services/SubscriptionService.js\n\nimport { storageKeys } from '../constants/storageKeys';\nimport { deviceDetection } from '../utils/deviceDetection';\nclass SubscriptionService {\n  constructor() {\n    // Read subscription status from storage\n    this.loadSubscriptionState();\n\n    // Platform-specific payment handlers\n    this.paymentHandlers = {\n      android: this.handleGooglePayment,\n      ios: this.handleApplePayment,\n      web: this.handleWebPayment\n    };\n  }\n  loadSubscriptionState() {\n    try {\n      const savedState = localStorage.getItem(storageKeys.USER_SUBSCRIPTION);\n      if (savedState) {\n        this.subscriptionState = JSON.parse(savedState);\n      } else {\n        this.subscriptionState = {\n          isSubscribed: false,\n          plan: null,\n          expiryDate: null,\n          paymentMethod: null,\n          subscriptionId: null\n        };\n      }\n    } catch (error) {\n      console.error('Error loading subscription state:', error);\n      // Default state if error\n      this.subscriptionState = {\n        isSubscribed: false,\n        plan: null,\n        expiryDate: null,\n        paymentMethod: null,\n        subscriptionId: null\n      };\n    }\n  }\n  saveSubscriptionState() {\n    try {\n      localStorage.setItem(storageKeys.USER_SUBSCRIPTION, JSON.stringify(this.subscriptionState));\n    } catch (error) {\n      console.error('Error saving subscription state:', error);\n    }\n  }\n  getSubscriptionState() {\n    return {\n      ...this.subscriptionState\n    };\n  }\n\n  // Check if a user still has free signals available (3 total)\n  checkFreeSignalAvailability(userId) {\n    try {\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\n      if (!userSignals) {\n        return {\n          available: true,\n          remaining: 3\n        };\n      }\n      const signalData = JSON.parse(userSignals);\n      const remaining = Math.max(0, 3 - signalData.count);\n      return {\n        available: remaining > 0,\n        remaining,\n        used: signalData.count\n      };\n    } catch (error) {\n      console.error('Error checking free signal availability:', error);\n      return {\n        available: false,\n        remaining: 0,\n        error: true\n      };\n    }\n  }\n\n  // Record usage of a free signal (increment count)\n  useFreeSignal(userId) {\n    if (this.subscriptionState.isSubscribed) {\n      return {\n        success: true,\n        unlimited: true\n      }; // Subscribed users don't count\n    }\n    try {\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\n      const signalData = userSignals ? JSON.parse(userSignals) : {\n        count: 0,\n        firstUsed: Date.now()\n      };\n      if (signalData.count >= 3) {\n        return {\n          success: false,\n          reason: 'No free signals remaining'\n        };\n      }\n      signalData.count++;\n      signalData.lastUsed = Date.now();\n      localStorage.setItem(`user_signals_${userId}`, JSON.stringify(signalData));\n      return {\n        success: true,\n        remaining: 3 - signalData.count,\n        used: signalData.count\n      };\n    } catch (error) {\n      console.error('Error using free signal:', error);\n      return {\n        success: false,\n        reason: 'Error processing request'\n      };\n    }\n  }\n\n  // Reset a user's free signals (when they subscribe)\n  resetFreeSignals(userId) {\n    try {\n      // When a user subscribes, we can reset their signal count\n      localStorage.removeItem(`user_signals_${userId}`);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error resetting free signals:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n  async startSubscription(plan, userId) {\n    try {\n      // Detect platform for payment method\n      const deviceInfo = deviceDetection();\n      const platform = deviceInfo.isIOS ? 'ios' : deviceInfo.isAndroid ? 'android' : 'web';\n\n      // Select payment handler based on platform\n      const handler = this.paymentHandlers[platform] || this.paymentHandlers.web;\n      const result = await handler(plan);\n      if (result.success) {\n        // Reset free signals when user subscribes\n        this.resetFreeSignals(userId);\n\n        // Update subscription state\n        this.subscriptionState.isSubscribed = true;\n        this.subscriptionState.plan = plan;\n        this.subscriptionState.expiryDate = result.expiryDate;\n        this.subscriptionState.paymentMethod = result.paymentMethod;\n        this.subscriptionState.subscriptionId = result.subscriptionId;\n        this.saveSubscriptionState();\n        return {\n          success: true,\n          subscription: this.subscriptionState\n        };\n      }\n      return {\n        success: false,\n        error: result.error\n      };\n    } catch (error) {\n      console.error('Error starting subscription:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n  async cancelSubscription() {\n    // Logic to cancel subscription\n    try {\n      // API call to cancel subscription with payment provider\n      const result = await fetch('/api/subscription/cancel', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          subscriptionId: this.subscriptionState.subscriptionId\n        })\n      });\n      if (result.ok) {\n        // Update local state\n        this.subscriptionState.isSubscribed = false;\n        this.subscriptionState.plan = null;\n        this.subscriptionState.expiryDate = null;\n        this.subscriptionState.subscriptionId = null;\n        this.saveSubscriptionState();\n        return {\n          success: true\n        };\n      }\n      const data = await result.json();\n      return {\n        success: false,\n        error: data.message\n      };\n    } catch (error) {\n      console.error('Error canceling subscription:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Platform-specific payment handlers\n  async handleGooglePayment(plan) {\n    // Google Pay implementation\n    // For testing, we'll return a mock successful result\n    return {\n      success: true,\n      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n      // 30 days\n      paymentMethod: 'google_pay',\n      subscriptionId: 'gp_' + Math.random().toString(36).substring(2, 15)\n    };\n  }\n  async handleApplePayment(plan) {\n    // Apple Pay implementation\n    return {\n      success: true,\n      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n      // 30 days\n      paymentMethod: 'apple_pay',\n      subscriptionId: 'ap_' + Math.random().toString(36).substring(2, 15)\n    };\n  }\n  async handleWebPayment(plan) {\n    // Stripe/PayPal implementation for web\n    return {\n      success: true,\n      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n      // 30 days\n      paymentMethod: 'stripe',\n      subscriptionId: 'st_' + Math.random().toString(36).substring(2, 15)\n    };\n  }\n\n  // Check if subscription is about to expire\n  isSubscriptionExpiringSoon() {\n    if (!this.subscriptionState.isSubscribed || !this.subscriptionState.expiryDate) {\n      return false;\n    }\n    const expiryDate = new Date(this.subscriptionState.expiryDate);\n    const now = new Date();\n    const daysUntilExpiry = Math.floor((expiryDate - now) / (1000 * 60 * 60 * 24));\n    return daysUntilExpiry <= 3; // Consider \"soon\" as 3 days or less\n  }\n\n  // Get subscription details for display\n  getFormattedSubscriptionDetails() {\n    if (!this.subscriptionState.isSubscribed) {\n      return {\n        status: 'Not subscribed'\n      };\n    }\n    const expiryDate = new Date(this.subscriptionState.expiryDate);\n    return {\n      status: 'Active',\n      plan: this.subscriptionState.plan,\n      expiryDate: expiryDate.toLocaleDateString(),\n      daysRemaining: Math.max(0, Math.floor((expiryDate - new Date()) / (1000 * 60 * 60 * 24))),\n      paymentMethod: this.subscriptionState.paymentMethod\n    };\n  }\n}\nexport default new SubscriptionService();","map":{"version":3,"names":["storageKeys","deviceDetection","SubscriptionService","constructor","loadSubscriptionState","paymentHandlers","android","handleGooglePayment","ios","handleApplePayment","web","handleWebPayment","savedState","localStorage","getItem","USER_SUBSCRIPTION","subscriptionState","JSON","parse","isSubscribed","plan","expiryDate","paymentMethod","subscriptionId","error","console","saveSubscriptionState","setItem","stringify","getSubscriptionState","checkFreeSignalAvailability","userId","userSignals","available","remaining","signalData","Math","max","count","used","useFreeSignal","success","unlimited","firstUsed","Date","now","reason","lastUsed","resetFreeSignals","removeItem","message","startSubscription","deviceInfo","platform","isIOS","isAndroid","handler","result","subscription","cancelSubscription","fetch","method","headers","body","ok","data","json","random","toString","substring","isSubscriptionExpiringSoon","daysUntilExpiry","floor","getFormattedSubscriptionDetails","status","toLocaleDateString","daysRemaining"],"sources":["C:/Users/juliu/Desktop/web/src/services/SubscriptionService.js"],"sourcesContent":["// src/services/SubscriptionService.js\r\n\r\nimport { storageKeys } from '../constants/storageKeys';\r\nimport { deviceDetection } from '../utils/deviceDetection';\r\n\r\nclass SubscriptionService {\r\n  constructor() {\r\n    // Read subscription status from storage\r\n    this.loadSubscriptionState();\r\n    \r\n    // Platform-specific payment handlers\r\n    this.paymentHandlers = {\r\n      android: this.handleGooglePayment,\r\n      ios: this.handleApplePayment,\r\n      web: this.handleWebPayment\r\n    };\r\n  }\r\n  \r\n  loadSubscriptionState() {\r\n    try {\r\n      const savedState = localStorage.getItem(storageKeys.USER_SUBSCRIPTION);\r\n      if (savedState) {\r\n        this.subscriptionState = JSON.parse(savedState);\r\n      } else {\r\n        this.subscriptionState = {\r\n          isSubscribed: false,\r\n          plan: null,\r\n          expiryDate: null,\r\n          paymentMethod: null,\r\n          subscriptionId: null\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading subscription state:', error);\r\n      // Default state if error\r\n      this.subscriptionState = {\r\n        isSubscribed: false,\r\n        plan: null,\r\n        expiryDate: null,\r\n        paymentMethod: null,\r\n        subscriptionId: null\r\n      };\r\n    }\r\n  }\r\n  \r\n  saveSubscriptionState() {\r\n    try {\r\n      localStorage.setItem(storageKeys.USER_SUBSCRIPTION, JSON.stringify(this.subscriptionState));\r\n    } catch (error) {\r\n      console.error('Error saving subscription state:', error);\r\n    }\r\n  }\r\n  \r\n  getSubscriptionState() {\r\n    return { ...this.subscriptionState };\r\n  }\r\n  \r\n  // Check if a user still has free signals available (3 total)\r\n  checkFreeSignalAvailability(userId) {\r\n    try {\r\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\r\n      if (!userSignals) {\r\n        return { available: true, remaining: 3 };\r\n      }\r\n      \r\n      const signalData = JSON.parse(userSignals);\r\n      const remaining = Math.max(0, 3 - signalData.count);\r\n      \r\n      return { \r\n        available: remaining > 0, \r\n        remaining,\r\n        used: signalData.count \r\n      };\r\n    } catch (error) {\r\n      console.error('Error checking free signal availability:', error);\r\n      return { available: false, remaining: 0, error: true };\r\n    }\r\n  }\r\n  \r\n  // Record usage of a free signal (increment count)\r\n  useFreeSignal(userId) {\r\n    if (this.subscriptionState.isSubscribed) {\r\n      return { success: true, unlimited: true }; // Subscribed users don't count\r\n    }\r\n    \r\n    try {\r\n      const userSignals = localStorage.getItem(`user_signals_${userId}`);\r\n      const signalData = userSignals ? JSON.parse(userSignals) : { \r\n        count: 0, \r\n        firstUsed: Date.now() \r\n      };\r\n      \r\n      if (signalData.count >= 3) {\r\n        return { success: false, reason: 'No free signals remaining' };\r\n      }\r\n      \r\n      signalData.count++;\r\n      signalData.lastUsed = Date.now();\r\n      \r\n      localStorage.setItem(`user_signals_${userId}`, JSON.stringify(signalData));\r\n      \r\n      return { \r\n        success: true, \r\n        remaining: 3 - signalData.count,\r\n        used: signalData.count\r\n      };\r\n    } catch (error) {\r\n      console.error('Error using free signal:', error);\r\n      return { success: false, reason: 'Error processing request' };\r\n    }\r\n  }\r\n  \r\n  // Reset a user's free signals (when they subscribe)\r\n  resetFreeSignals(userId) {\r\n    try {\r\n      // When a user subscribes, we can reset their signal count\r\n      localStorage.removeItem(`user_signals_${userId}`);\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error resetting free signals:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n  \r\n  async startSubscription(plan, userId) {\r\n    try {\r\n      // Detect platform for payment method\r\n      const deviceInfo = deviceDetection();\r\n      const platform = deviceInfo.isIOS ? 'ios' : \r\n                      deviceInfo.isAndroid ? 'android' : 'web';\r\n                      \r\n      // Select payment handler based on platform\r\n      const handler = this.paymentHandlers[platform] || this.paymentHandlers.web;\r\n      const result = await handler(plan);\r\n      \r\n      if (result.success) {\r\n        // Reset free signals when user subscribes\r\n        this.resetFreeSignals(userId);\r\n        \r\n        // Update subscription state\r\n        this.subscriptionState.isSubscribed = true;\r\n        this.subscriptionState.plan = plan;\r\n        this.subscriptionState.expiryDate = result.expiryDate;\r\n        this.subscriptionState.paymentMethod = result.paymentMethod;\r\n        this.subscriptionState.subscriptionId = result.subscriptionId;\r\n        this.saveSubscriptionState();\r\n        \r\n        return { success: true, subscription: this.subscriptionState };\r\n      }\r\n      \r\n      return { success: false, error: result.error };\r\n    } catch (error) {\r\n      console.error('Error starting subscription:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n  \r\n  async cancelSubscription() {\r\n    // Logic to cancel subscription\r\n    try {\r\n      // API call to cancel subscription with payment provider\r\n      const result = await fetch('/api/subscription/cancel', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          subscriptionId: this.subscriptionState.subscriptionId\r\n        })\r\n      });\r\n      \r\n      if (result.ok) {\r\n        // Update local state\r\n        this.subscriptionState.isSubscribed = false;\r\n        this.subscriptionState.plan = null;\r\n        this.subscriptionState.expiryDate = null;\r\n        this.subscriptionState.subscriptionId = null;\r\n        this.saveSubscriptionState();\r\n        return { success: true };\r\n      }\r\n      \r\n      const data = await result.json();\r\n      return { success: false, error: data.message };\r\n    } catch (error) {\r\n      console.error('Error canceling subscription:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n  \r\n  // Platform-specific payment handlers\r\n  async handleGooglePayment(plan) {\r\n    // Google Pay implementation\r\n    // For testing, we'll return a mock successful result\r\n    return {\r\n      success: true,\r\n      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n      paymentMethod: 'google_pay',\r\n      subscriptionId: 'gp_' + Math.random().toString(36).substring(2, 15)\r\n    };\r\n  }\r\n  \r\n  async handleApplePayment(plan) {\r\n    // Apple Pay implementation\r\n    return {\r\n      success: true,\r\n      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n      paymentMethod: 'apple_pay',\r\n      subscriptionId: 'ap_' + Math.random().toString(36).substring(2, 15)\r\n    };\r\n  }\r\n  \r\n  async handleWebPayment(plan) {\r\n    // Stripe/PayPal implementation for web\r\n    return {\r\n      success: true,\r\n      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n      paymentMethod: 'stripe',\r\n      subscriptionId: 'st_' + Math.random().toString(36).substring(2, 15)\r\n    };\r\n  }\r\n  \r\n  // Check if subscription is about to expire\r\n  isSubscriptionExpiringSoon() {\r\n    if (!this.subscriptionState.isSubscribed || !this.subscriptionState.expiryDate) {\r\n      return false;\r\n    }\r\n    \r\n    const expiryDate = new Date(this.subscriptionState.expiryDate);\r\n    const now = new Date();\r\n    const daysUntilExpiry = Math.floor((expiryDate - now) / (1000 * 60 * 60 * 24));\r\n    \r\n    return daysUntilExpiry <= 3; // Consider \"soon\" as 3 days or less\r\n  }\r\n  \r\n  // Get subscription details for display\r\n  getFormattedSubscriptionDetails() {\r\n    if (!this.subscriptionState.isSubscribed) {\r\n      return { status: 'Not subscribed' };\r\n    }\r\n    \r\n    const expiryDate = new Date(this.subscriptionState.expiryDate);\r\n    \r\n    return {\r\n      status: 'Active',\r\n      plan: this.subscriptionState.plan,\r\n      expiryDate: expiryDate.toLocaleDateString(),\r\n      daysRemaining: Math.max(0, Math.floor((expiryDate - new Date()) / (1000 * 60 * 60 * 24))),\r\n      paymentMethod: this.subscriptionState.paymentMethod\r\n    };\r\n  }\r\n}\r\n\r\nexport default new SubscriptionService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}