{"ast":null,"code":"// server/services/subscriptionService.js\n\nconst crypto = require('crypto');\nconst {\n  db\n} = require('../database'); // Your database connection\nconst appleReceiptVerifier = require('./platforms/appleReceiptVerifier');\nconst googleReceiptVerifier = require('./platforms/googleReceiptVerifier');\n\n/**\r\n * Service for managing subscriptions without user accounts\r\n */\nclass SubscriptionService {\n  /**\r\n   * Create a new subscription from web purchase\r\n   */\n  async createSubscription(email, plan, paymentId) {\n    try {\n      // Generate a unique access token\n      const accessToken = this.generateToken();\n\n      // Store minimal subscription info\n      const subscription = {\n        email,\n        // Only for receipts & support, not for authentication\n        plan,\n        paymentId,\n        // Reference to payment processor's transaction ID\n        accessToken,\n        createdAt: new Date(),\n        expiresAt: this.calculateExpiryDate(plan),\n        active: true\n      };\n\n      // Save to database\n      await db.subscriptions.insertOne(subscription);\n\n      // Generate a code that can be used on mobile devices\n      const mobileAccessCode = this.generateMobileAccessCode(accessToken);\n      return {\n        success: true,\n        accessToken,\n        mobileAccessCode,\n        expiresAt: subscription.expiresAt\n      };\n    } catch (error) {\n      console.error('Failed to create subscription:', error);\n      return {\n        success: false,\n        error: 'Subscription creation failed'\n      };\n    }\n  }\n\n  /**\r\n   * Verify a web subscription token\r\n   */\n  async verifyToken(token) {\n    try {\n      const subscription = await db.subscriptions.findOne({\n        accessToken: token\n      });\n      if (!subscription) {\n        return {\n          valid: false\n        };\n      }\n\n      // Check if subscription is active and not expired\n      const isValid = subscription.active && new Date(subscription.expiresAt) > new Date();\n      return {\n        valid: isValid,\n        plan: subscription.plan,\n        expiresAt: subscription.expiresAt\n      };\n    } catch (error) {\n      console.error('Token verification failed:', error);\n      return {\n        valid: false,\n        error: 'Verification failed'\n      };\n    }\n  }\n\n  /**\r\n   * Verify an Apple receipt\r\n   */\n  async verifyAppleReceipt(receipt) {\n    try {\n      // Use Apple's verification endpoint\n      const verificationResult = await appleReceiptVerifier.verify(receipt);\n      if (verificationResult.valid) {\n        // Store the verified receipt for future reference\n        await this.storeVerifiedReceipt('ios', verificationResult);\n        return {\n          verified: true,\n          expiresAt: verificationResult.expiresAt,\n          productId: verificationResult.productId\n        };\n      }\n      return {\n        verified: false\n      };\n    } catch (error) {\n      console.error('Apple receipt verification failed:', error);\n      return {\n        verified: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\r\n   * Verify a Google Play receipt\r\n   */\n  async verifyGoogleReceipt(receipt) {\n    try {\n      // Parse the receipt JSON string\n      const receiptData = typeof receipt === 'string' ? JSON.parse(receipt) : receipt;\n\n      // Use Google's API to verify the purchase\n      const verificationResult = await googleReceiptVerifier.verify(receiptData.packageName, receiptData.productId, receiptData.purchaseToken);\n      if (verificationResult.valid) {\n        // Store the verified receipt\n        await this.storeVerifiedReceipt('android', verificationResult);\n        return {\n          verified: true,\n          expiresAt: verificationResult.expiresAt,\n          productId: receiptData.productId\n        };\n      }\n      return {\n        verified: false\n      };\n    } catch (error) {\n      console.error('Google receipt verification failed:', error);\n      return {\n        verified: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\r\n   * Activate subscription on mobile with web access code\r\n   */\n  async activateWithCode(accessCode, platform) {\n    try {\n      // Find the subscription by mobile access code\n      const subscription = await db.subscriptions.findOne({\n        mobileAccessCode: accessCode\n      });\n      if (!subscription || !subscription.active || new Date(subscription.expiresAt) <= new Date()) {\n        return {\n          success: false,\n          error: 'Invalid or expired code'\n        };\n      }\n\n      // Create a \"web receipt\" that can be stored on the mobile device\n      const webReceipt = JSON.stringify({\n        accessToken: subscription.accessToken,\n        code: accessCode,\n        platform\n      });\n      return {\n        success: true,\n        webReceipt,\n        plan: subscription.plan,\n        expiresAt: subscription.expiresAt\n      };\n    } catch (error) {\n      console.error('Code activation failed:', error);\n      return {\n        success: false,\n        error: 'Activation failed'\n      };\n    }\n  }\n\n  /**\r\n   * Verify a \"web receipt\" from mobile device\r\n   */\n  async verifyWebReceipt(webReceipt) {\n    try {\n      // Parse the receipt\n      const receiptData = typeof webReceipt === 'string' ? JSON.parse(webReceipt) : webReceipt;\n\n      // Verify the access token\n      const verificationResult = await this.verifyToken(receiptData.accessToken);\n      if (verificationResult.valid) {\n        return {\n          verified: true,\n          expiresAt: verificationResult.expiresAt,\n          plan: verificationResult.plan\n        };\n      }\n      return {\n        verified: false\n      };\n    } catch (error) {\n      console.error('Web receipt verification failed:', error);\n      return {\n        verified: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\r\n   * Store verified receipt information\r\n   */\n  async storeVerifiedReceipt(platform, verification) {\n    try {\n      await db.verifiedReceipts.insertOne({\n        platform,\n        productId: verification.productId,\n        purchaseToken: verification.purchaseToken,\n        expiresAt: verification.expiresAt,\n        verifiedAt: new Date()\n      });\n    } catch (error) {\n      console.error('Failed to store verified receipt:', error);\n    }\n  }\n\n  /**\r\n   * Generate a secure random token\r\n   */\n  generateToken() {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  /**\r\n   * Generate a user-friendly code for mobile access\r\n   */\n  generateMobileAccessCode(token) {\n    // Create a short, memorable code from the token\n    // Format: XXXX-XXXX-XXXX (12 alphanumeric characters in groups of 4)\n    const hash = crypto.createHash('sha256').update(token).digest('hex');\n    const code = hash.substring(0, 12).toUpperCase();\n    return `${code.substring(0, 4)}-${code.substring(4, 8)}-${code.substring(8, 12)}`;\n  }\n\n  /**\r\n   * Calculate subscription expiry date based on plan\r\n   */\n  calculateExpiryDate(plan) {\n    const now = new Date();\n    if (plan.includes('monthly')) {\n      return new Date(now.setMonth(now.getMonth() + 1));\n    } else if (plan.includes('yearly')) {\n      return new Date(now.setFullYear(now.getFullYear() + 1));\n    } else if (plan.includes('lifetime')) {\n      // Set a very far future date for \"lifetime\" plans\n      return new Date(now.setFullYear(now.getFullYear() + 99));\n    }\n\n    // Default to 1 month if plan is unknown\n    return new Date(now.setMonth(now.getMonth() + 1));\n  }\n}\nmodule.exports = new SubscriptionService();","map":{"version":3,"names":["crypto","require","db","appleReceiptVerifier","googleReceiptVerifier","SubscriptionService","createSubscription","email","plan","paymentId","accessToken","generateToken","subscription","createdAt","Date","expiresAt","calculateExpiryDate","active","subscriptions","insertOne","mobileAccessCode","generateMobileAccessCode","success","error","console","verifyToken","token","findOne","valid","isValid","verifyAppleReceipt","receipt","verificationResult","verify","storeVerifiedReceipt","verified","productId","message","verifyGoogleReceipt","receiptData","JSON","parse","packageName","purchaseToken","activateWithCode","accessCode","platform","webReceipt","stringify","code","verifyWebReceipt","verification","verifiedReceipts","verifiedAt","randomBytes","toString","hash","createHash","update","digest","substring","toUpperCase","now","includes","setMonth","getMonth","setFullYear","getFullYear","module","exports"],"sources":["C:/Users/juliu/Desktop/web/src/services/SubscriptionService.js"],"sourcesContent":["// server/services/subscriptionService.js\r\n\r\nconst crypto = require('crypto');\r\nconst { db } = require('../database');  // Your database connection\r\nconst appleReceiptVerifier = require('./platforms/appleReceiptVerifier');\r\nconst googleReceiptVerifier = require('./platforms/googleReceiptVerifier');\r\n\r\n/**\r\n * Service for managing subscriptions without user accounts\r\n */\r\nclass SubscriptionService {\r\n  /**\r\n   * Create a new subscription from web purchase\r\n   */\r\n  async createSubscription(email, plan, paymentId) {\r\n    try {\r\n      // Generate a unique access token\r\n      const accessToken = this.generateToken();\r\n      \r\n      // Store minimal subscription info\r\n      const subscription = {\r\n        email,          // Only for receipts & support, not for authentication\r\n        plan,\r\n        paymentId,      // Reference to payment processor's transaction ID\r\n        accessToken,\r\n        createdAt: new Date(),\r\n        expiresAt: this.calculateExpiryDate(plan),\r\n        active: true\r\n      };\r\n      \r\n      // Save to database\r\n      await db.subscriptions.insertOne(subscription);\r\n      \r\n      // Generate a code that can be used on mobile devices\r\n      const mobileAccessCode = this.generateMobileAccessCode(accessToken);\r\n      \r\n      return {\r\n        success: true,\r\n        accessToken,\r\n        mobileAccessCode,\r\n        expiresAt: subscription.expiresAt\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to create subscription:', error);\r\n      return { success: false, error: 'Subscription creation failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a web subscription token\r\n   */\r\n  async verifyToken(token) {\r\n    try {\r\n      const subscription = await db.subscriptions.findOne({ accessToken: token });\r\n      \r\n      if (!subscription) {\r\n        return { valid: false };\r\n      }\r\n      \r\n      // Check if subscription is active and not expired\r\n      const isValid = subscription.active && new Date(subscription.expiresAt) > new Date();\r\n      \r\n      return {\r\n        valid: isValid,\r\n        plan: subscription.plan,\r\n        expiresAt: subscription.expiresAt\r\n      };\r\n    } catch (error) {\r\n      console.error('Token verification failed:', error);\r\n      return { valid: false, error: 'Verification failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify an Apple receipt\r\n   */\r\n  async verifyAppleReceipt(receipt) {\r\n    try {\r\n      // Use Apple's verification endpoint\r\n      const verificationResult = await appleReceiptVerifier.verify(receipt);\r\n      \r\n      if (verificationResult.valid) {\r\n        // Store the verified receipt for future reference\r\n        await this.storeVerifiedReceipt('ios', verificationResult);\r\n        \r\n        return {\r\n          verified: true,\r\n          expiresAt: verificationResult.expiresAt,\r\n          productId: verificationResult.productId\r\n        };\r\n      }\r\n      \r\n      return { verified: false };\r\n    } catch (error) {\r\n      console.error('Apple receipt verification failed:', error);\r\n      return { verified: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a Google Play receipt\r\n   */\r\n  async verifyGoogleReceipt(receipt) {\r\n    try {\r\n      // Parse the receipt JSON string\r\n      const receiptData = typeof receipt === 'string' ? JSON.parse(receipt) : receipt;\r\n      \r\n      // Use Google's API to verify the purchase\r\n      const verificationResult = await googleReceiptVerifier.verify(\r\n        receiptData.packageName,\r\n        receiptData.productId,\r\n        receiptData.purchaseToken\r\n      );\r\n      \r\n      if (verificationResult.valid) {\r\n        // Store the verified receipt\r\n        await this.storeVerifiedReceipt('android', verificationResult);\r\n        \r\n        return {\r\n          verified: true,\r\n          expiresAt: verificationResult.expiresAt,\r\n          productId: receiptData.productId\r\n        };\r\n      }\r\n      \r\n      return { verified: false };\r\n    } catch (error) {\r\n      console.error('Google receipt verification failed:', error);\r\n      return { verified: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate subscription on mobile with web access code\r\n   */\r\n  async activateWithCode(accessCode, platform) {\r\n    try {\r\n      // Find the subscription by mobile access code\r\n      const subscription = await db.subscriptions.findOne({ mobileAccessCode: accessCode });\r\n      \r\n      if (!subscription || !subscription.active || new Date(subscription.expiresAt) <= new Date()) {\r\n        return { success: false, error: 'Invalid or expired code' };\r\n      }\r\n      \r\n      // Create a \"web receipt\" that can be stored on the mobile device\r\n      const webReceipt = JSON.stringify({\r\n        accessToken: subscription.accessToken,\r\n        code: accessCode,\r\n        platform\r\n      });\r\n      \r\n      return {\r\n        success: true,\r\n        webReceipt,\r\n        plan: subscription.plan,\r\n        expiresAt: subscription.expiresAt\r\n      };\r\n    } catch (error) {\r\n      console.error('Code activation failed:', error);\r\n      return { success: false, error: 'Activation failed' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a \"web receipt\" from mobile device\r\n   */\r\n  async verifyWebReceipt(webReceipt) {\r\n    try {\r\n      // Parse the receipt\r\n      const receiptData = typeof webReceipt === 'string' ? JSON.parse(webReceipt) : webReceipt;\r\n      \r\n      // Verify the access token\r\n      const verificationResult = await this.verifyToken(receiptData.accessToken);\r\n      \r\n      if (verificationResult.valid) {\r\n        return {\r\n          verified: true,\r\n          expiresAt: verificationResult.expiresAt,\r\n          plan: verificationResult.plan\r\n        };\r\n      }\r\n      \r\n      return { verified: false };\r\n    } catch (error) {\r\n      console.error('Web receipt verification failed:', error);\r\n      return { verified: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Store verified receipt information\r\n   */\r\n  async storeVerifiedReceipt(platform, verification) {\r\n    try {\r\n      await db.verifiedReceipts.insertOne({\r\n        platform,\r\n        productId: verification.productId,\r\n        purchaseToken: verification.purchaseToken,\r\n        expiresAt: verification.expiresAt,\r\n        verifiedAt: new Date()\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to store verified receipt:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a secure random token\r\n   */\r\n  generateToken() {\r\n    return crypto.randomBytes(32).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Generate a user-friendly code for mobile access\r\n   */\r\n  generateMobileAccessCode(token) {\r\n    // Create a short, memorable code from the token\r\n    // Format: XXXX-XXXX-XXXX (12 alphanumeric characters in groups of 4)\r\n    const hash = crypto.createHash('sha256').update(token).digest('hex');\r\n    const code = hash.substring(0, 12).toUpperCase();\r\n    return `${code.substring(0, 4)}-${code.substring(4, 8)}-${code.substring(8, 12)}`;\r\n  }\r\n\r\n  /**\r\n   * Calculate subscription expiry date based on plan\r\n   */\r\n  calculateExpiryDate(plan) {\r\n    const now = new Date();\r\n    \r\n    if (plan.includes('monthly')) {\r\n      return new Date(now.setMonth(now.getMonth() + 1));\r\n    } else if (plan.includes('yearly')) {\r\n      return new Date(now.setFullYear(now.getFullYear() + 1));\r\n    } else if (plan.includes('lifetime')) {\r\n      // Set a very far future date for \"lifetime\" plans\r\n      return new Date(now.setFullYear(now.getFullYear() + 99));\r\n    }\r\n    \r\n    // Default to 1 month if plan is unknown\r\n    return new Date(now.setMonth(now.getMonth() + 1));\r\n  }\r\n}\r\n\r\nmodule.exports = new SubscriptionService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}