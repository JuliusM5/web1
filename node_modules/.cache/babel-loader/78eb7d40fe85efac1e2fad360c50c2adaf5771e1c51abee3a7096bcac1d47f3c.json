{"ast":null,"code":"import notificationService from './notificationService';\nimport dealDetectionService from './dealDetectionService';\nimport analyticsService from './analyticsService';\n\n/**\r\n * Service for managing and sending flight deal alerts\r\n */\nclass DealAlertService {\n  constructor() {\n    this.userAlerts = new Map();\n    this.dealCache = new Map();\n    this.lastCheckTime = new Map();\n    this.minimumCheckInterval = 3 * 60 * 60 * 1000; // 3 hours minimum between checks\n\n    // Load saved alerts from localStorage\n    this.loadSavedAlerts();\n  }\n\n  /**\r\n   * Load saved alerts from localStorage\r\n   */\n  loadSavedAlerts() {\n    try {\n      const savedAlerts = localStorage.getItem('deal_alerts');\n      if (savedAlerts) {\n        const parsedAlerts = JSON.parse(savedAlerts);\n\n        // Convert back to Map - userId -> alerts[]\n        Object.entries(parsedAlerts).forEach(([userId, alerts]) => {\n          this.userAlerts.set(userId, alerts);\n        });\n        console.log(`Loaded ${this.userAlerts.size} user alert configurations`);\n      }\n    } catch (error) {\n      console.error('Error loading saved alerts:', error);\n    }\n  }\n\n  /**\r\n   * Save alerts to localStorage\r\n   */\n  saveAlerts() {\n    try {\n      // Convert Map to object for storage\n      const alertsObj = {};\n      this.userAlerts.forEach((alerts, userId) => {\n        alertsObj[userId] = alerts;\n      });\n      localStorage.setItem('deal_alerts', JSON.stringify(alertsObj));\n    } catch (error) {\n      console.error('Error saving alerts:', error);\n    }\n  }\n\n  /**\r\n   * Get all alerts for a user\r\n   */\n  getUserAlerts(userId) {\n    return this.userAlerts.get(userId) || [];\n  }\n\n  /**\r\n   * Create a new alert for a user\r\n   */\n  createAlert(userId, alertData) {\n    if (!alertData.origin) {\n      throw new Error('Origin is required');\n    }\n\n    // Get existing alerts for user\n    const userAlerts = this.getUserAlerts(userId);\n\n    // Check if alert already exists\n    const existingAlertIndex = userAlerts.findIndex(alert => alert.origin === alertData.origin && alert.destination === alertData.destination && alert.dateType === alertData.dateType);\n    const newAlert = {\n      id: `alert-${Date.now()}`,\n      userId,\n      origin: alertData.origin,\n      destination: alertData.destination || 'anywhere',\n      dateType: alertData.dateType || 'flexible',\n      startDate: alertData.startDate || null,\n      endDate: alertData.endDate || null,\n      tripLength: alertData.tripLength || {\n        min: 3,\n        max: 14\n      },\n      maxPrice: alertData.maxPrice || null,\n      active: true,\n      createdAt: new Date().toISOString(),\n      lastChecked: null,\n      lastNotified: null\n    };\n\n    // Replace existing alert or add new one\n    if (existingAlertIndex >= 0) {\n      userAlerts[existingAlertIndex] = newAlert;\n    } else {\n      userAlerts.push(newAlert);\n    }\n\n    // Save updated alerts\n    this.userAlerts.set(userId, userAlerts);\n    this.saveAlerts();\n\n    // Track alert creation\n    analyticsService.trackEvent('alert_created', {\n      alert_id: newAlert.id,\n      origin: newAlert.origin,\n      destination: newAlert.destination,\n      date_type: newAlert.dateType\n    });\n    return newAlert;\n  }\n\n  /**\r\n   * Update an existing alert\r\n   */\n  updateAlert(userId, alertId, updates) {\n    const userAlerts = this.getUserAlerts(userId);\n    const alertIndex = userAlerts.findIndex(alert => alert.id === alertId);\n    if (alertIndex === -1) {\n      throw new Error('Alert not found');\n    }\n\n    // Update the alert\n    userAlerts[alertIndex] = {\n      ...userAlerts[alertIndex],\n      ...updates,\n      lastChecked: updates.active !== false ? userAlerts[alertIndex].lastChecked : null\n    };\n\n    // Save updated alerts\n    this.userAlerts.set(userId, userAlerts);\n    this.saveAlerts();\n    return userAlerts[alertIndex];\n  }\n\n  /**\r\n   * Delete an alert\r\n   */\n  deleteAlert(userId, alertId) {\n    const userAlerts = this.getUserAlerts(userId);\n    const filteredAlerts = userAlerts.filter(alert => alert.id !== alertId);\n    if (filteredAlerts.length === userAlerts.length) {\n      throw new Error('Alert not found');\n    }\n\n    // Save updated alerts\n    this.userAlerts.set(userId, filteredAlerts);\n    this.saveAlerts();\n\n    // Track alert deletion\n    analyticsService.trackEvent('alert_deleted', {\n      alert_id: alertId\n    });\n    return true;\n  }\n\n  /**\r\n   * Check for deals that match an alert\r\n   */\n  async checkAlert(alert) {\n    // Skip inactive alerts\n    if (!alert.active) return [];\n\n    // Check if we've checked this alert recently\n    const lastCheck = this.lastCheckTime.get(alert.id);\n    const now = Date.now();\n    if (lastCheck && now - lastCheck < this.minimumCheckInterval) {\n      return [];\n    }\n    try {\n      // Update last check time\n      this.lastCheckTime.set(alert.id, now);\n      let deals = [];\n\n      // Check if destination is \"anywhere\" or a specific place\n      if (alert.destination === 'anywhere') {\n        deals = await dealDetectionService.findDealsFromOrigin(alert.origin);\n      } else {\n        deals = await dealDetectionService.findDealsForRoute(alert.origin, alert.destination, {\n          departure: alert.startDate,\n          return: alert.endDate\n        });\n      }\n\n      // Filter deals based on alert criteria\n      let matchingDeals = deals.filter(deal => {\n        // Filter by max price if set\n        if (alert.maxPrice && deal.price > alert.maxPrice) {\n          return false;\n        }\n\n        // Filter by date range if specific dates\n        if (alert.dateType === 'specific') {\n          if (!alert.startDate || !alert.endDate) return true;\n          const dealDate = new Date(deal.departureDate);\n          const startDate = new Date(alert.startDate);\n          const endDate = new Date(alert.endDate);\n          return dealDate >= startDate && dealDate <= endDate;\n        }\n        return true;\n      });\n\n      // Update last checked time for the alert\n      this.updateAlert(alert.userId, alert.id, {\n        lastChecked: new Date().toISOString()\n      });\n\n      // Cache and return the matching deals\n      this.dealCache.set(alert.id, matchingDeals);\n      return matchingDeals;\n    } catch (error) {\n      console.error(`Error checking alert ${alert.id}:`, error);\n      return [];\n    }\n  }\n\n  /**\r\n   * Check all alerts for a user and return matching deals\r\n   */\n  async checkAllAlertsForUser(userId) {\n    const userAlerts = this.getUserAlerts(userId);\n    const allDeals = [];\n\n    // Check each active alert\n    for (const alert of userAlerts) {\n      if (alert.active) {\n        const alertDeals = await this.checkAlert(alert);\n\n        // Add alert info to each deal\n        alertDeals.forEach(deal => {\n          deal.alertId = alert.id;\n        });\n        allDeals.push(...alertDeals);\n      }\n    }\n    return allDeals;\n  }\n\n  /**\r\n   * Send notifications for new deals\r\n   */\n  async notifyUserOfDeals(userId, deals, options = {}) {\n    if (!deals || deals.length === 0) return [];\n    const notifiedDeals = [];\n    const userAlerts = this.getUserAlerts(userId);\n    for (const deal of deals) {\n      // Find the corresponding alert\n      const alert = userAlerts.find(a => a.id === deal.alertId);\n      if (!alert) continue;\n\n      // Check if we've already notified for this deal recently\n      // This prevents repeated notifications for the same deal\n      if (this.hasRecentlyNotified(alert, deal)) {\n        continue;\n      }\n\n      // Prepare notification message\n      const title = `Flight Deal: ${deal.origin} to ${deal.destinationName}`;\n      let message = `${deal.discountPercent}% off! `;\n      message += `${deal.currency} ${deal.price} (Usually ${deal.currency} ${deal.averagePrice})`;\n      if (deal.departureDate) {\n        const date = new Date(deal.departureDate);\n        message += ` on ${date.toLocaleDateString()}`;\n      }\n\n      // Send browser notification\n      const notificationSent = await notificationService.showNotification(title, {\n        body: message,\n        icon: '/logo192.png',\n        data: {\n          dealId: deal.id,\n          deepLink: deal.deepLink\n        },\n        requireInteraction: true,\n        actions: [{\n          action: 'view',\n          title: 'View Deal'\n        }, {\n          action: 'dismiss',\n          title: 'Dismiss'\n        }]\n      });\n      if (notificationSent) {\n        // Update alert with last notification time\n        this.updateAlert(userId, alert.id, {\n          lastNotified: new Date().toISOString()\n        });\n\n        // Track notification sent\n        analyticsService.trackEvent('deal_notification_sent', {\n          alert_id: alert.id,\n          deal_id: deal.id,\n          price: deal.price,\n          discount: deal.discountPercent\n        });\n        notifiedDeals.push(deal);\n      }\n    }\n    return notifiedDeals;\n  }\n\n  /**\r\n   * Check if we've recently notified about a similar deal\r\n   */\n  hasRecentlyNotified(alert, deal) {\n    if (!alert.lastNotified) return false;\n    const lastNotification = new Date(alert.lastNotified);\n    const now = new Date();\n\n    // Don't notify more than once per day for the same route\n    const oneDayAgo = new Date(now);\n    oneDayAgo.setDate(oneDayAgo.getDate() - 1);\n    return lastNotification > oneDayAgo;\n  }\n\n  /**\r\n   * Get cached deals for an alert\r\n   */\n  getCachedDealsForAlert(alertId) {\n    return this.dealCache.get(alertId) || [];\n  }\n\n  /**\r\n   * Process alerts in the background at regular intervals\r\n   */\n  startBackgroundProcessing(intervalMinutes = 180) {\n    // Schedule periodic checks\n    setInterval(() => {\n      this.processAllAlerts();\n    }, intervalMinutes * 60 * 1000);\n\n    // Also do an initial check\n    setTimeout(() => {\n      this.processAllAlerts();\n    }, 5000);\n    console.log(`Background alert processing started, interval: ${intervalMinutes} minutes`);\n  }\n\n  /**\r\n   * Process all active alerts\r\n   */\n  async processAllAlerts() {\n    console.log('Processing all alerts...');\n\n    // Process alerts for each user\n    for (const [userId, alerts] of this.userAlerts.entries()) {\n      const activeAlerts = alerts.filter(alert => alert.active);\n      if (activeAlerts.length === 0) continue;\n\n      // Check for new deals\n      const deals = await this.checkAllAlertsForUser(userId);\n\n      // Send notifications if there are deals\n      if (deals.length > 0) {\n        await this.notifyUserOfDeals(userId, deals);\n      }\n    }\n    console.log('Alert processing completed');\n  }\n}\nexport default new DealAlertService();","map":{"version":3,"names":["notificationService","dealDetectionService","analyticsService","DealAlertService","constructor","userAlerts","Map","dealCache","lastCheckTime","minimumCheckInterval","loadSavedAlerts","savedAlerts","localStorage","getItem","parsedAlerts","JSON","parse","Object","entries","forEach","userId","alerts","set","console","log","size","error","saveAlerts","alertsObj","setItem","stringify","getUserAlerts","get","createAlert","alertData","origin","Error","existingAlertIndex","findIndex","alert","destination","dateType","newAlert","id","Date","now","startDate","endDate","tripLength","min","max","maxPrice","active","createdAt","toISOString","lastChecked","lastNotified","push","trackEvent","alert_id","date_type","updateAlert","alertId","updates","alertIndex","deleteAlert","filteredAlerts","filter","length","checkAlert","lastCheck","deals","findDealsFromOrigin","findDealsForRoute","departure","return","matchingDeals","deal","price","dealDate","departureDate","checkAllAlertsForUser","allDeals","alertDeals","notifyUserOfDeals","options","notifiedDeals","find","a","hasRecentlyNotified","title","destinationName","message","discountPercent","currency","averagePrice","date","toLocaleDateString","notificationSent","showNotification","body","icon","data","dealId","deepLink","requireInteraction","actions","action","deal_id","discount","lastNotification","oneDayAgo","setDate","getDate","getCachedDealsForAlert","startBackgroundProcessing","intervalMinutes","setInterval","processAllAlerts","setTimeout","activeAlerts"],"sources":["C:/Users/juliu/Desktop/web/src/services/dealAlertService.js"],"sourcesContent":["\r\nimport notificationService from './notificationService';\r\nimport dealDetectionService from './dealDetectionService';\r\nimport analyticsService from './analyticsService';\r\n\r\n/**\r\n * Service for managing and sending flight deal alerts\r\n */\r\nclass DealAlertService {\r\n  constructor() {\r\n    this.userAlerts = new Map();\r\n    this.dealCache = new Map();\r\n    this.lastCheckTime = new Map();\r\n    this.minimumCheckInterval = 3 * 60 * 60 * 1000; // 3 hours minimum between checks\r\n    \r\n    // Load saved alerts from localStorage\r\n    this.loadSavedAlerts();\r\n  }\r\n  \r\n  /**\r\n   * Load saved alerts from localStorage\r\n   */\r\n  loadSavedAlerts() {\r\n    try {\r\n      const savedAlerts = localStorage.getItem('deal_alerts');\r\n      if (savedAlerts) {\r\n        const parsedAlerts = JSON.parse(savedAlerts);\r\n        \r\n        // Convert back to Map - userId -> alerts[]\r\n        Object.entries(parsedAlerts).forEach(([userId, alerts]) => {\r\n          this.userAlerts.set(userId, alerts);\r\n        });\r\n        \r\n        console.log(`Loaded ${this.userAlerts.size} user alert configurations`);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading saved alerts:', error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Save alerts to localStorage\r\n   */\r\n  saveAlerts() {\r\n    try {\r\n      // Convert Map to object for storage\r\n      const alertsObj = {};\r\n      this.userAlerts.forEach((alerts, userId) => {\r\n        alertsObj[userId] = alerts;\r\n      });\r\n      \r\n      localStorage.setItem('deal_alerts', JSON.stringify(alertsObj));\r\n    } catch (error) {\r\n      console.error('Error saving alerts:', error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get all alerts for a user\r\n   */\r\n  getUserAlerts(userId) {\r\n    return this.userAlerts.get(userId) || [];\r\n  }\r\n  \r\n  /**\r\n   * Create a new alert for a user\r\n   */\r\n  createAlert(userId, alertData) {\r\n    if (!alertData.origin) {\r\n      throw new Error('Origin is required');\r\n    }\r\n    \r\n    // Get existing alerts for user\r\n    const userAlerts = this.getUserAlerts(userId);\r\n    \r\n    // Check if alert already exists\r\n    const existingAlertIndex = userAlerts.findIndex(alert => \r\n      alert.origin === alertData.origin && \r\n      alert.destination === alertData.destination &&\r\n      alert.dateType === alertData.dateType\r\n    );\r\n    \r\n    const newAlert = {\r\n      id: `alert-${Date.now()}`,\r\n      userId,\r\n      origin: alertData.origin,\r\n      destination: alertData.destination || 'anywhere',\r\n      dateType: alertData.dateType || 'flexible',\r\n      startDate: alertData.startDate || null,\r\n      endDate: alertData.endDate || null,\r\n      tripLength: alertData.tripLength || { min: 3, max: 14 },\r\n      maxPrice: alertData.maxPrice || null,\r\n      active: true,\r\n      createdAt: new Date().toISOString(),\r\n      lastChecked: null,\r\n      lastNotified: null\r\n    };\r\n    \r\n    // Replace existing alert or add new one\r\n    if (existingAlertIndex >= 0) {\r\n      userAlerts[existingAlertIndex] = newAlert;\r\n    } else {\r\n      userAlerts.push(newAlert);\r\n    }\r\n    \r\n    // Save updated alerts\r\n    this.userAlerts.set(userId, userAlerts);\r\n    this.saveAlerts();\r\n    \r\n    // Track alert creation\r\n    analyticsService.trackEvent('alert_created', {\r\n      alert_id: newAlert.id,\r\n      origin: newAlert.origin,\r\n      destination: newAlert.destination,\r\n      date_type: newAlert.dateType\r\n    });\r\n    \r\n    return newAlert;\r\n  }\r\n  \r\n  /**\r\n   * Update an existing alert\r\n   */\r\n  updateAlert(userId, alertId, updates) {\r\n    const userAlerts = this.getUserAlerts(userId);\r\n    const alertIndex = userAlerts.findIndex(alert => alert.id === alertId);\r\n    \r\n    if (alertIndex === -1) {\r\n      throw new Error('Alert not found');\r\n    }\r\n    \r\n    // Update the alert\r\n    userAlerts[alertIndex] = {\r\n      ...userAlerts[alertIndex],\r\n      ...updates,\r\n      lastChecked: updates.active !== false ? userAlerts[alertIndex].lastChecked : null\r\n    };\r\n    \r\n    // Save updated alerts\r\n    this.userAlerts.set(userId, userAlerts);\r\n    this.saveAlerts();\r\n    \r\n    return userAlerts[alertIndex];\r\n  }\r\n  \r\n  /**\r\n   * Delete an alert\r\n   */\r\n  deleteAlert(userId, alertId) {\r\n    const userAlerts = this.getUserAlerts(userId);\r\n    const filteredAlerts = userAlerts.filter(alert => alert.id !== alertId);\r\n    \r\n    if (filteredAlerts.length === userAlerts.length) {\r\n      throw new Error('Alert not found');\r\n    }\r\n    \r\n    // Save updated alerts\r\n    this.userAlerts.set(userId, filteredAlerts);\r\n    this.saveAlerts();\r\n    \r\n    // Track alert deletion\r\n    analyticsService.trackEvent('alert_deleted', {\r\n      alert_id: alertId\r\n    });\r\n    \r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Check for deals that match an alert\r\n   */\r\n  async checkAlert(alert) {\r\n    // Skip inactive alerts\r\n    if (!alert.active) return [];\r\n    \r\n    // Check if we've checked this alert recently\r\n    const lastCheck = this.lastCheckTime.get(alert.id);\r\n    const now = Date.now();\r\n    \r\n    if (lastCheck && (now - lastCheck < this.minimumCheckInterval)) {\r\n      return [];\r\n    }\r\n    \r\n    try {\r\n      // Update last check time\r\n      this.lastCheckTime.set(alert.id, now);\r\n      \r\n      let deals = [];\r\n      \r\n      // Check if destination is \"anywhere\" or a specific place\r\n      if (alert.destination === 'anywhere') {\r\n        deals = await dealDetectionService.findDealsFromOrigin(alert.origin);\r\n      } else {\r\n        deals = await dealDetectionService.findDealsForRoute(\r\n          alert.origin, \r\n          alert.destination,\r\n          {\r\n            departure: alert.startDate,\r\n            return: alert.endDate\r\n          }\r\n        );\r\n      }\r\n      \r\n      // Filter deals based on alert criteria\r\n      let matchingDeals = deals.filter(deal => {\r\n        // Filter by max price if set\r\n        if (alert.maxPrice && deal.price > alert.maxPrice) {\r\n          return false;\r\n        }\r\n        \r\n        // Filter by date range if specific dates\r\n        if (alert.dateType === 'specific') {\r\n          if (!alert.startDate || !alert.endDate) return true;\r\n          \r\n          const dealDate = new Date(deal.departureDate);\r\n          const startDate = new Date(alert.startDate);\r\n          const endDate = new Date(alert.endDate);\r\n          \r\n          return dealDate >= startDate && dealDate <= endDate;\r\n        }\r\n        \r\n        return true;\r\n      });\r\n      \r\n      // Update last checked time for the alert\r\n      this.updateAlert(alert.userId, alert.id, {\r\n        lastChecked: new Date().toISOString()\r\n      });\r\n      \r\n      // Cache and return the matching deals\r\n      this.dealCache.set(alert.id, matchingDeals);\r\n      \r\n      return matchingDeals;\r\n    } catch (error) {\r\n      console.error(`Error checking alert ${alert.id}:`, error);\r\n      return [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Check all alerts for a user and return matching deals\r\n   */\r\n  async checkAllAlertsForUser(userId) {\r\n    const userAlerts = this.getUserAlerts(userId);\r\n    const allDeals = [];\r\n    \r\n    // Check each active alert\r\n    for (const alert of userAlerts) {\r\n      if (alert.active) {\r\n        const alertDeals = await this.checkAlert(alert);\r\n        \r\n        // Add alert info to each deal\r\n        alertDeals.forEach(deal => {\r\n          deal.alertId = alert.id;\r\n        });\r\n        \r\n        allDeals.push(...alertDeals);\r\n      }\r\n    }\r\n    \r\n    return allDeals;\r\n  }\r\n  \r\n  /**\r\n   * Send notifications for new deals\r\n   */\r\n  async notifyUserOfDeals(userId, deals, options = {}) {\r\n    if (!deals || deals.length === 0) return [];\r\n    \r\n    const notifiedDeals = [];\r\n    const userAlerts = this.getUserAlerts(userId);\r\n    \r\n    for (const deal of deals) {\r\n      // Find the corresponding alert\r\n      const alert = userAlerts.find(a => a.id === deal.alertId);\r\n      if (!alert) continue;\r\n      \r\n      // Check if we've already notified for this deal recently\r\n      // This prevents repeated notifications for the same deal\r\n      if (this.hasRecentlyNotified(alert, deal)) {\r\n        continue;\r\n      }\r\n      \r\n      // Prepare notification message\r\n      const title = `Flight Deal: ${deal.origin} to ${deal.destinationName}`;\r\n      let message = `${deal.discountPercent}% off! `;\r\n      message += `${deal.currency} ${deal.price} (Usually ${deal.currency} ${deal.averagePrice})`;\r\n      \r\n      if (deal.departureDate) {\r\n        const date = new Date(deal.departureDate);\r\n        message += ` on ${date.toLocaleDateString()}`;\r\n      }\r\n      \r\n      // Send browser notification\r\n      const notificationSent = await notificationService.showNotification(title, {\r\n        body: message,\r\n        icon: '/logo192.png',\r\n        data: {\r\n          dealId: deal.id,\r\n          deepLink: deal.deepLink\r\n        },\r\n        requireInteraction: true,\r\n        actions: [\r\n          { action: 'view', title: 'View Deal' },\r\n          { action: 'dismiss', title: 'Dismiss' }\r\n        ]\r\n      });\r\n      \r\n      if (notificationSent) {\r\n        // Update alert with last notification time\r\n        this.updateAlert(userId, alert.id, {\r\n          lastNotified: new Date().toISOString()\r\n        });\r\n        \r\n        // Track notification sent\r\n        analyticsService.trackEvent('deal_notification_sent', {\r\n          alert_id: alert.id,\r\n          deal_id: deal.id,\r\n          price: deal.price,\r\n          discount: deal.discountPercent\r\n        });\r\n        \r\n        notifiedDeals.push(deal);\r\n      }\r\n    }\r\n    \r\n    return notifiedDeals;\r\n  }\r\n  \r\n  /**\r\n   * Check if we've recently notified about a similar deal\r\n   */\r\n  hasRecentlyNotified(alert, deal) {\r\n    if (!alert.lastNotified) return false;\r\n    \r\n    const lastNotification = new Date(alert.lastNotified);\r\n    const now = new Date();\r\n    \r\n    // Don't notify more than once per day for the same route\r\n    const oneDayAgo = new Date(now);\r\n    oneDayAgo.setDate(oneDayAgo.getDate() - 1);\r\n    \r\n    return lastNotification > oneDayAgo;\r\n  }\r\n  \r\n  /**\r\n   * Get cached deals for an alert\r\n   */\r\n  getCachedDealsForAlert(alertId) {\r\n    return this.dealCache.get(alertId) || [];\r\n  }\r\n  \r\n  /**\r\n   * Process alerts in the background at regular intervals\r\n   */\r\n  startBackgroundProcessing(intervalMinutes = 180) {\r\n    // Schedule periodic checks\r\n    setInterval(() => {\r\n      this.processAllAlerts();\r\n    }, intervalMinutes * 60 * 1000);\r\n    \r\n    // Also do an initial check\r\n    setTimeout(() => {\r\n      this.processAllAlerts();\r\n    }, 5000);\r\n    \r\n    console.log(`Background alert processing started, interval: ${intervalMinutes} minutes`);\r\n  }\r\n  \r\n  /**\r\n   * Process all active alerts\r\n   */\r\n  async processAllAlerts() {\r\n    console.log('Processing all alerts...');\r\n    \r\n    // Process alerts for each user\r\n    for (const [userId, alerts] of this.userAlerts.entries()) {\r\n      const activeAlerts = alerts.filter(alert => alert.active);\r\n      \r\n      if (activeAlerts.length === 0) continue;\r\n      \r\n      // Check for new deals\r\n      const deals = await this.checkAllAlertsForUser(userId);\r\n      \r\n      // Send notifications if there are deals\r\n      if (deals.length > 0) {\r\n        await this.notifyUserOfDeals(userId, deals);\r\n      }\r\n    }\r\n    \r\n    console.log('Alert processing completed');\r\n  }\r\n}\r\n\r\nexport default new DealAlertService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}