{"ast":null,"code":"// src/services/skyscannerService.js\n\nimport { storageKeys } from '../constants/storageKeys';\nimport { API_CONFIG } from '../constants/apiEndpoints';\nclass SkyScannerService {\n  constructor() {\n    this.apiKey = API_CONFIG.RAPIDAPI_KEY;\n    this.apiHost = API_CONFIG.RAPIDAPI_HOST;\n    this.baseUrl = 'https://skyscanner89.p.rapidapi.com';\n    this.requestQueue = [];\n    this.isProcessingQueue = false;\n    this.requestsThisSecond = 0;\n    this.lastRequestTime = Date.now();\n    this.MAX_REQUESTS_PER_SECOND = 5; // Setting conservative rate limit\n\n    // Advanced caching\n    this.cache = new Map();\n    this.CACHE_EXPIRY = 3600000; // 1 hour cache\n  }\n\n  // Search for one-way flights\n  async searchOneWayFlights(origin, destination, originId, destinationId, date = null) {\n    const dateParam = date ? `&date=${date}` : '';\n    const cacheKey = `oneway-${origin}-${destination}-${originId}-${destinationId}${dateParam}`;\n\n    // Check cache first to reduce API calls\n    const cachedResult = this.getFromCache(cacheKey);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    // Queue the request\n    return new Promise((resolve, reject) => {\n      this.addToQueue({\n        endpoint: `/flights/one-way/list`,\n        params: {\n          origin,\n          destination,\n          originId,\n          destinationId,\n          ...(date && {\n            date\n          })\n        },\n        resolve,\n        reject,\n        cacheKey\n      });\n    });\n  }\n\n  // Location autocomplete - for searching airports/cities globally\n  async locationAutocomplete(query) {\n    const cacheKey = `location-${query.toLowerCase()}`;\n\n    // Check cache first\n    const cachedResult = this.getFromCache(cacheKey);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    // Queue the request\n    return new Promise((resolve, reject) => {\n      this.addToQueue({\n        endpoint: '/locations/search',\n        params: {\n          query\n        },\n        resolve,\n        reject,\n        cacheKey\n      });\n    });\n  }\n\n  // Search for airports near given coordinates\n  async searchNearbyAirports(latitude, longitude) {\n    const endpoint = '/locations/nearby';\n    const params = {\n      latitude,\n      longitude\n    };\n    const cacheKey = `nearby-${latitude.toFixed(2)}-${longitude.toFixed(2)}`;\n\n    // Check cache first\n    const cachedResult = this.getFromCache(cacheKey);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    // Queue the request\n    return new Promise((resolve, reject) => {\n      this.addToQueue({\n        endpoint,\n        params,\n        resolve,\n        reject,\n        cacheKey\n      });\n    });\n  }\n  getFromCache(key) {\n    if (this.cache.has(key)) {\n      const {\n        data,\n        timestamp\n      } = this.cache.get(key);\n      // Check if cache is still valid\n      if (Date.now() - timestamp < this.CACHE_EXPIRY) {\n        return Promise.resolve(data);\n      }\n      this.cache.delete(key); // Expired, remove it\n    }\n\n    // Also check localStorage for persistent cache\n    try {\n      const storedCacheJson = localStorage.getItem(storageKeys.FLIGHT_CACHE);\n      if (storedCacheJson) {\n        const storedCache = JSON.parse(storedCacheJson);\n        if (storedCache[key]) {\n          const {\n            data,\n            timestamp\n          } = storedCache[key];\n          if (Date.now() - timestamp < this.CACHE_EXPIRY) {\n            // Add to memory cache too\n            this.cache.set(key, {\n              data,\n              timestamp\n            });\n            return Promise.resolve(data);\n          } else {\n            // Remove expired entry from localStorage\n            delete storedCache[key];\n            localStorage.setItem(storageKeys.FLIGHT_CACHE, JSON.stringify(storedCache));\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error checking localStorage cache:', error);\n    }\n    return null;\n  }\n  addToCache(key, data) {\n    // Add to memory cache\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n\n    // Also persist to localStorage for offline access and sharing between sessions\n    try {\n      const cachedData = JSON.parse(localStorage.getItem(storageKeys.FLIGHT_CACHE) || '{}');\n      cachedData[key] = {\n        data,\n        timestamp: Date.now()\n      };\n      localStorage.setItem(storageKeys.FLIGHT_CACHE, JSON.stringify(cachedData));\n    } catch (error) {\n      console.error('Error saving to localStorage:', error);\n    }\n  }\n  addToQueue(request) {\n    this.requestQueue.push(request);\n    if (!this.isProcessingQueue) {\n      this.processQueue();\n    }\n  }\n  async processQueue() {\n    if (this.requestQueue.length === 0) {\n      this.isProcessingQueue = false;\n      return;\n    }\n    this.isProcessingQueue = true;\n\n    // Respect rate limits\n    const now = Date.now();\n    const timeElapsed = now - this.lastRequestTime;\n    if (timeElapsed < 1000) {\n      // Within the same second\n      if (this.requestsThisSecond >= this.MAX_REQUESTS_PER_SECOND) {\n        // Wait until the next second starts\n        await new Promise(resolve => setTimeout(resolve, 1000 - timeElapsed));\n        this.requestsThisSecond = 0;\n      }\n    } else {\n      // Reset counter for new second\n      this.requestsThisSecond = 0;\n    }\n\n    // Process the next request\n    const request = this.requestQueue.shift();\n    this.requestsThisSecond++;\n    this.lastRequestTime = Date.now();\n    try {\n      // Build URL with query parameters\n      const url = new URL(`${this.baseUrl}${request.endpoint}`);\n      if (request.params) {\n        Object.keys(request.params).forEach(key => url.searchParams.append(key, request.params[key]));\n      }\n\n      // Make the request with RapidAPI headers\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'x-rapidapi-host': this.apiHost,\n          'x-rapidapi-key': this.apiKey\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Cache successful response\n      if (request.cacheKey) {\n        this.addToCache(request.cacheKey, data);\n      }\n      request.resolve(data);\n    } catch (error) {\n      console.error('Error making RapidAPI request:', error);\n      request.reject(error);\n    }\n\n    // Continue processing queue\n    this.processQueue();\n  }\n\n  // Method to preload common routes to minimize API calls\n  async preloadPopularRoutes(popularRoutes) {\n    console.log('Preloading popular routes to minimize API calls...');\n    const preloadPromises = popularRoutes.map(route => this.searchOneWayFlights(route.origin, route.destination, route.originId, route.destinationId).catch(err => {\n      // Silently fail - this is just preloading\n      console.warn(`Failed to preload route ${route.origin} to ${route.destination}:`, err);\n      return null;\n    }));\n    await Promise.allSettled(preloadPromises);\n    console.log('Preloading complete');\n  }\n\n  // Get API usage statistics\n  getApiUsageStats() {\n    return {\n      requestsThisSecond: this.requestsThisSecond,\n      queueLength: this.requestQueue.length,\n      cacheSize: this.cache.size,\n      lastRequestTime: this.lastRequestTime\n    };\n  }\n\n  // Clear cache (useful for testing or if API response format changes)\n  clearCache() {\n    this.cache.clear();\n    localStorage.removeItem(storageKeys.FLIGHT_CACHE);\n    console.log('Flight data cache cleared');\n  }\n}\nexport default new SkyScannerService();","map":{"version":3,"names":["storageKeys","API_CONFIG","SkyScannerService","constructor","apiKey","RAPIDAPI_KEY","apiHost","RAPIDAPI_HOST","baseUrl","requestQueue","isProcessingQueue","requestsThisSecond","lastRequestTime","Date","now","MAX_REQUESTS_PER_SECOND","cache","Map","CACHE_EXPIRY","searchOneWayFlights","origin","destination","originId","destinationId","date","dateParam","cacheKey","cachedResult","getFromCache","Promise","resolve","reject","addToQueue","endpoint","params","locationAutocomplete","query","toLowerCase","searchNearbyAirports","latitude","longitude","toFixed","key","has","data","timestamp","get","delete","storedCacheJson","localStorage","getItem","FLIGHT_CACHE","storedCache","JSON","parse","set","setItem","stringify","error","console","addToCache","cachedData","request","push","processQueue","length","timeElapsed","setTimeout","shift","url","URL","Object","keys","forEach","searchParams","append","response","fetch","method","headers","ok","Error","status","json","preloadPopularRoutes","popularRoutes","log","preloadPromises","map","route","catch","err","warn","allSettled","getApiUsageStats","queueLength","cacheSize","size","clearCache","clear","removeItem"],"sources":["C:/Users/juliu/Desktop/web/src/services/skyscannerService.js"],"sourcesContent":["// src/services/skyscannerService.js\r\n\r\nimport { storageKeys } from '../constants/storageKeys';\r\nimport { API_CONFIG } from '../constants/apiEndpoints';\r\n\r\nclass SkyScannerService {\r\n  constructor() {\r\n    this.apiKey = API_CONFIG.RAPIDAPI_KEY;\r\n    this.apiHost = API_CONFIG.RAPIDAPI_HOST;\r\n    this.baseUrl = 'https://skyscanner89.p.rapidapi.com';\r\n    this.requestQueue = [];\r\n    this.isProcessingQueue = false;\r\n    this.requestsThisSecond = 0;\r\n    this.lastRequestTime = Date.now();\r\n    this.MAX_REQUESTS_PER_SECOND = 5; // Setting conservative rate limit\r\n    \r\n    // Advanced caching\r\n    this.cache = new Map();\r\n    this.CACHE_EXPIRY = 3600000; // 1 hour cache\r\n  }\r\n\r\n  // Search for one-way flights\r\n  async searchOneWayFlights(origin, destination, originId, destinationId, date = null) {\r\n    const dateParam = date ? `&date=${date}` : '';\r\n    const cacheKey = `oneway-${origin}-${destination}-${originId}-${destinationId}${dateParam}`;\r\n    \r\n    // Check cache first to reduce API calls\r\n    const cachedResult = this.getFromCache(cacheKey);\r\n    if (cachedResult) {\r\n      return cachedResult;\r\n    }\r\n    \r\n    // Queue the request\r\n    return new Promise((resolve, reject) => {\r\n      this.addToQueue({\r\n        endpoint: `/flights/one-way/list`,\r\n        params: { \r\n          origin, \r\n          destination, \r\n          originId, \r\n          destinationId,\r\n          ...(date && { date })\r\n        },\r\n        resolve,\r\n        reject,\r\n        cacheKey\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Location autocomplete - for searching airports/cities globally\r\n  async locationAutocomplete(query) {\r\n    const cacheKey = `location-${query.toLowerCase()}`;\r\n    \r\n    // Check cache first\r\n    const cachedResult = this.getFromCache(cacheKey);\r\n    if (cachedResult) {\r\n      return cachedResult;\r\n    }\r\n    \r\n    // Queue the request\r\n    return new Promise((resolve, reject) => {\r\n      this.addToQueue({\r\n        endpoint: '/locations/search',\r\n        params: { query },\r\n        resolve,\r\n        reject,\r\n        cacheKey\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Search for airports near given coordinates\r\n  async searchNearbyAirports(latitude, longitude) {\r\n    const endpoint = '/locations/nearby';\r\n    const params = { latitude, longitude };\r\n    \r\n    const cacheKey = `nearby-${latitude.toFixed(2)}-${longitude.toFixed(2)}`;\r\n    \r\n    // Check cache first\r\n    const cachedResult = this.getFromCache(cacheKey);\r\n    if (cachedResult) {\r\n      return cachedResult;\r\n    }\r\n    \r\n    // Queue the request\r\n    return new Promise((resolve, reject) => {\r\n      this.addToQueue({\r\n        endpoint,\r\n        params,\r\n        resolve,\r\n        reject,\r\n        cacheKey\r\n      });\r\n    });\r\n  }\r\n  \r\n  getFromCache(key) {\r\n    if (this.cache.has(key)) {\r\n      const { data, timestamp } = this.cache.get(key);\r\n      // Check if cache is still valid\r\n      if (Date.now() - timestamp < this.CACHE_EXPIRY) {\r\n        return Promise.resolve(data);\r\n      }\r\n      this.cache.delete(key); // Expired, remove it\r\n    }\r\n    \r\n    // Also check localStorage for persistent cache\r\n    try {\r\n      const storedCacheJson = localStorage.getItem(storageKeys.FLIGHT_CACHE);\r\n      if (storedCacheJson) {\r\n        const storedCache = JSON.parse(storedCacheJson);\r\n        if (storedCache[key]) {\r\n          const { data, timestamp } = storedCache[key];\r\n          if (Date.now() - timestamp < this.CACHE_EXPIRY) {\r\n            // Add to memory cache too\r\n            this.cache.set(key, { data, timestamp });\r\n            return Promise.resolve(data);\r\n          } else {\r\n            // Remove expired entry from localStorage\r\n            delete storedCache[key];\r\n            localStorage.setItem(storageKeys.FLIGHT_CACHE, JSON.stringify(storedCache));\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error checking localStorage cache:', error);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n  \r\n  addToCache(key, data) {\r\n    // Add to memory cache\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    // Also persist to localStorage for offline access and sharing between sessions\r\n    try {\r\n      const cachedData = JSON.parse(localStorage.getItem(storageKeys.FLIGHT_CACHE) || '{}');\r\n      cachedData[key] = {\r\n        data,\r\n        timestamp: Date.now()\r\n      };\r\n      localStorage.setItem(storageKeys.FLIGHT_CACHE, JSON.stringify(cachedData));\r\n    } catch (error) {\r\n      console.error('Error saving to localStorage:', error);\r\n    }\r\n  }\r\n\r\n  addToQueue(request) {\r\n    this.requestQueue.push(request);\r\n    if (!this.isProcessingQueue) {\r\n      this.processQueue();\r\n    }\r\n  }\r\n\r\n  async processQueue() {\r\n    if (this.requestQueue.length === 0) {\r\n      this.isProcessingQueue = false;\r\n      return;\r\n    }\r\n    \r\n    this.isProcessingQueue = true;\r\n    \r\n    // Respect rate limits\r\n    const now = Date.now();\r\n    const timeElapsed = now - this.lastRequestTime;\r\n    \r\n    if (timeElapsed < 1000) { // Within the same second\r\n      if (this.requestsThisSecond >= this.MAX_REQUESTS_PER_SECOND) {\r\n        // Wait until the next second starts\r\n        await new Promise(resolve => setTimeout(resolve, 1000 - timeElapsed));\r\n        this.requestsThisSecond = 0;\r\n      }\r\n    } else {\r\n      // Reset counter for new second\r\n      this.requestsThisSecond = 0;\r\n    }\r\n    \r\n    // Process the next request\r\n    const request = this.requestQueue.shift();\r\n    this.requestsThisSecond++;\r\n    this.lastRequestTime = Date.now();\r\n    \r\n    try {\r\n      // Build URL with query parameters\r\n      const url = new URL(`${this.baseUrl}${request.endpoint}`);\r\n      \r\n      if (request.params) {\r\n        Object.keys(request.params).forEach(key => \r\n          url.searchParams.append(key, request.params[key])\r\n        );\r\n      }\r\n      \r\n      // Make the request with RapidAPI headers\r\n      const response = await fetch(url, {\r\n        method: 'GET',\r\n        headers: {\r\n          'x-rapidapi-host': this.apiHost,\r\n          'x-rapidapi-key': this.apiKey\r\n        }\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API error: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      \r\n      // Cache successful response\r\n      if (request.cacheKey) {\r\n        this.addToCache(request.cacheKey, data);\r\n      }\r\n      \r\n      request.resolve(data);\r\n    } catch (error) {\r\n      console.error('Error making RapidAPI request:', error);\r\n      request.reject(error);\r\n    }\r\n    \r\n    // Continue processing queue\r\n    this.processQueue();\r\n  }\r\n  \r\n  // Method to preload common routes to minimize API calls\r\n  async preloadPopularRoutes(popularRoutes) {\r\n    console.log('Preloading popular routes to minimize API calls...');\r\n    const preloadPromises = popularRoutes.map(route => \r\n      this.searchOneWayFlights(\r\n        route.origin, \r\n        route.destination, \r\n        route.originId, \r\n        route.destinationId\r\n      ).catch(err => {\r\n        // Silently fail - this is just preloading\r\n        console.warn(`Failed to preload route ${route.origin} to ${route.destination}:`, err);\r\n        return null;\r\n      })\r\n    );\r\n    \r\n    await Promise.allSettled(preloadPromises);\r\n    console.log('Preloading complete');\r\n  }\r\n  \r\n  // Get API usage statistics\r\n  getApiUsageStats() {\r\n    return {\r\n      requestsThisSecond: this.requestsThisSecond,\r\n      queueLength: this.requestQueue.length,\r\n      cacheSize: this.cache.size,\r\n      lastRequestTime: this.lastRequestTime\r\n    };\r\n  }\r\n  \r\n  // Clear cache (useful for testing or if API response format changes)\r\n  clearCache() {\r\n    this.cache.clear();\r\n    localStorage.removeItem(storageKeys.FLIGHT_CACHE);\r\n    console.log('Flight data cache cleared');\r\n  }\r\n}\r\n\r\nexport default new SkyScannerService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}