{"ast":null,"code":"// src/services/subscriptionService.js\n\nimport authService from './authService';\nclass SubscriptionService {\n  constructor() {\n    this.apiUrl = 'http://localhost:5000/api/subscriptions';\n    this.plans = {\n      MONTHLY: {\n        id: 'monthly',\n        name: 'Monthly Plan',\n        price: 4.99,\n        interval: 'month',\n        features: ['Unlimited flight alerts', 'No ads', 'Priority notifications', 'Price history graphs']\n      },\n      YEARLY: {\n        id: 'yearly',\n        name: 'Annual Plan',\n        price: 39.99,\n        interval: 'year',\n        features: ['Unlimited flight alerts', 'No ads', 'Priority notifications', 'Price history graphs', 'Personalized deal recommendations', '2 months free']\n      }\n    };\n  }\n\n  // Get available subscription plans\n  getPlans() {\n    return Object.values(this.plans);\n  }\n\n  // Get current subscription status\n  async getSubscriptionStatus() {\n    try {\n      const response = await fetch(this.apiUrl, {\n        headers: authService.getAuthHeaders()\n      });\n      if (!response.ok) {\n        throw new Error('Failed to get subscription status');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting subscription status:', error);\n\n      // Check if stored locally\n      const storedStatus = localStorage.getItem('subscription_status');\n      if (storedStatus) {\n        try {\n          return JSON.parse(storedStatus);\n        } catch (e) {\n          console.error('Error parsing stored subscription status:', e);\n        }\n      }\n\n      // Default status if nothing available\n      return {\n        isActive: false,\n        plan: null,\n        expiresAt: null,\n        freeAlertsUsed: 0,\n        freeAlertsLimit: 3\n      };\n    }\n  }\n\n  // Start a new subscription\n  async subscribe(planId, paymentMethod) {\n    try {\n      const response = await fetch(`${this.apiUrl}/create`, {\n        method: 'POST',\n        headers: authService.getAuthHeaders(),\n        body: JSON.stringify({\n          planId,\n          paymentMethod\n        })\n      });\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Subscription creation failed');\n      }\n      const subscriptionData = await response.json();\n\n      // Store locally for offline access\n      localStorage.setItem('subscription_status', JSON.stringify({\n        isActive: true,\n        plan: subscriptionData.plan,\n        expiresAt: subscriptionData.expiresAt,\n        freeAlertsUsed: 0,\n        freeAlertsLimit: 3\n      }));\n      return subscriptionData;\n    } catch (error) {\n      console.error('Subscription creation error:', error);\n      throw error;\n    }\n  }\n\n  // Cancel current subscription\n  async cancelSubscription() {\n    try {\n      const response = await fetch(`${this.apiUrl}/cancel`, {\n        method: 'POST',\n        headers: authService.getAuthHeaders()\n      });\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Subscription cancellation failed');\n      }\n      const result = await response.json();\n\n      // Update local storage\n      const storedStatus = localStorage.getItem('subscription_status');\n      if (storedStatus) {\n        try {\n          const status = JSON.parse(storedStatus);\n          status.isActive = false;\n          localStorage.setItem('subscription_status', JSON.stringify(status));\n        } catch (e) {\n          console.error('Error updating stored subscription status:', e);\n        }\n      }\n      return result;\n    } catch (error) {\n      console.error('Subscription cancellation error:', error);\n      throw error;\n    }\n  }\n\n  // Check if user has any free alerts remaining\n  async hasFreeAlertsRemaining() {\n    const status = await this.getSubscriptionStatus();\n    if (status.isActive) {\n      return true; // Subscribed users have unlimited alerts\n    }\n    return status.freeAlertsUsed < status.freeAlertsLimit;\n  }\n\n  // Use a free alert\n  async useFreeAlert() {\n    try {\n      const response = await fetch(`${this.apiUrl}/use-free-alert`, {\n        method: 'POST',\n        headers: authService.getAuthHeaders()\n      });\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Failed to use free alert');\n      }\n      const result = await response.json();\n\n      // Update local storage\n      const storedStatus = localStorage.getItem('subscription_status');\n      if (storedStatus) {\n        try {\n          const status = JSON.parse(storedStatus);\n          status.freeAlertsUsed = result.freeAlertsUsed;\n          localStorage.setItem('subscription_status', JSON.stringify(status));\n        } catch (e) {\n          console.error('Error updating stored free alerts:', e);\n        }\n      }\n      return result;\n    } catch (error) {\n      console.error('Error using free alert:', error);\n\n      // Fallback to updating locally if offline\n      if (!navigator.onLine) {\n        const storedStatus = localStorage.getItem('subscription_status');\n        if (storedStatus) {\n          try {\n            const status = JSON.parse(storedStatus);\n            if (status.freeAlertsUsed < status.freeAlertsLimit) {\n              status.freeAlertsUsed++;\n              localStorage.setItem('subscription_status', JSON.stringify(status));\n              return {\n                success: true,\n                freeAlertsUsed: status.freeAlertsUsed,\n                freeAlertsLimit: status.freeAlertsLimit\n              };\n            }\n          } catch (e) {\n            console.error('Error updating stored free alerts:', e);\n          }\n        }\n      }\n      throw error;\n    }\n  }\n\n  // Get remaining free alerts count\n  async getRemainingFreeAlerts() {\n    const status = await this.getSubscriptionStatus();\n    if (status.isActive) {\n      return Infinity; // Subscribed users have unlimited alerts\n    }\n    return Math.max(0, status.freeAlertsLimit - status.freeAlertsUsed);\n  }\n\n  // Get payment methods\n  async getPaymentMethods() {\n    try {\n      const response = await fetch(`${this.apiUrl}/payment-methods`, {\n        headers: authService.getAuthHeaders()\n      });\n      if (!response.ok) {\n        throw new Error('Failed to get payment methods');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting payment methods:', error);\n      return {\n        paymentMethods: []\n      };\n    }\n  }\n\n  // Add payment method\n  async addPaymentMethod(paymentDetails) {\n    try {\n      const response = await fetch(`${this.apiUrl}/payment-methods`, {\n        method: 'POST',\n        headers: authService.getAuthHeaders(),\n        body: JSON.stringify(paymentDetails)\n      });\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Failed to add payment method');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error adding payment method:', error);\n      throw error;\n    }\n  }\n\n  // Get subscription history\n  async getSubscriptionHistory() {\n    try {\n      const response = await fetch(`${this.apiUrl}/history`, {\n        headers: authService.getAuthHeaders()\n      });\n      if (!response.ok) {\n        throw new Error('Failed to get subscription history');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting subscription history:', error);\n      return {\n        history: []\n      };\n    }\n  }\n\n  // Apply promo code\n  async applyPromoCode(code) {\n    try {\n      const response = await fetch(`${this.apiUrl}/promo`, {\n        method: 'POST',\n        headers: authService.getAuthHeaders(),\n        body: JSON.stringify({\n          code\n        })\n      });\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Invalid promo code');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error applying promo code:', error);\n      throw error;\n    }\n  }\n\n  // Create mock payment method UI data for frontend\n  getMockPaymentUI() {\n    // In a real implementation, this would integrate with Stripe, PayPal, etc.\n    return {\n      paymentMethods: [{\n        type: 'credit_card',\n        name: 'Visa',\n        iconUrl: '/icons/visa.svg'\n      }, {\n        type: 'credit_card',\n        name: 'Mastercard',\n        iconUrl: '/icons/mastercard.svg'\n      }, {\n        type: 'paypal',\n        name: 'PayPal',\n        iconUrl: '/icons/paypal.svg'\n      }, {\n        type: 'apple_pay',\n        name: 'Apple Pay',\n        iconUrl: '/icons/apple-pay.svg'\n      }, {\n        type: 'google_pay',\n        name: 'Google Pay',\n        iconUrl: '/icons/google-pay.svg'\n      }]\n    };\n  }\n}\nexport default new SubscriptionService();","map":{"version":3,"names":["authService","SubscriptionService","constructor","apiUrl","plans","MONTHLY","id","name","price","interval","features","YEARLY","getPlans","Object","values","getSubscriptionStatus","response","fetch","headers","getAuthHeaders","ok","Error","json","error","console","storedStatus","localStorage","getItem","JSON","parse","e","isActive","plan","expiresAt","freeAlertsUsed","freeAlertsLimit","subscribe","planId","paymentMethod","method","body","stringify","message","subscriptionData","setItem","cancelSubscription","result","status","hasFreeAlertsRemaining","useFreeAlert","navigator","onLine","success","getRemainingFreeAlerts","Infinity","Math","max","getPaymentMethods","paymentMethods","addPaymentMethod","paymentDetails","getSubscriptionHistory","history","applyPromoCode","code","getMockPaymentUI","type","iconUrl"],"sources":["C:/Users/juliu/Desktop/web/src/services/SubscriptionService.js"],"sourcesContent":["// src/services/subscriptionService.js\r\n\r\nimport authService from './authService';\r\n\r\nclass SubscriptionService {\r\n  constructor() {\r\n    this.apiUrl = 'http://localhost:5000/api/subscriptions';\r\n    this.plans = {\r\n      MONTHLY: {\r\n        id: 'monthly',\r\n        name: 'Monthly Plan',\r\n        price: 4.99,\r\n        interval: 'month',\r\n        features: [\r\n          'Unlimited flight alerts',\r\n          'No ads',\r\n          'Priority notifications',\r\n          'Price history graphs'\r\n        ]\r\n      },\r\n      YEARLY: {\r\n        id: 'yearly',\r\n        name: 'Annual Plan',\r\n        price: 39.99,\r\n        interval: 'year',\r\n        features: [\r\n          'Unlimited flight alerts',\r\n          'No ads',\r\n          'Priority notifications',\r\n          'Price history graphs',\r\n          'Personalized deal recommendations',\r\n          '2 months free'\r\n        ]\r\n      }\r\n    };\r\n  }\r\n  \r\n  // Get available subscription plans\r\n  getPlans() {\r\n    return Object.values(this.plans);\r\n  }\r\n  \r\n  // Get current subscription status\r\n  async getSubscriptionStatus() {\r\n    try {\r\n      const response = await fetch(this.apiUrl, {\r\n        headers: authService.getAuthHeaders()\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error('Failed to get subscription status');\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('Error getting subscription status:', error);\r\n      \r\n      // Check if stored locally\r\n      const storedStatus = localStorage.getItem('subscription_status');\r\n      if (storedStatus) {\r\n        try {\r\n          return JSON.parse(storedStatus);\r\n        } catch (e) {\r\n          console.error('Error parsing stored subscription status:', e);\r\n        }\r\n      }\r\n      \r\n      // Default status if nothing available\r\n      return {\r\n        isActive: false,\r\n        plan: null,\r\n        expiresAt: null,\r\n        freeAlertsUsed: 0,\r\n        freeAlertsLimit: 3\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Start a new subscription\r\n  async subscribe(planId, paymentMethod) {\r\n    try {\r\n      const response = await fetch(`${this.apiUrl}/create`, {\r\n        method: 'POST',\r\n        headers: authService.getAuthHeaders(),\r\n        body: JSON.stringify({\r\n          planId,\r\n          paymentMethod\r\n        })\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const error = await response.json();\r\n        throw new Error(error.message || 'Subscription creation failed');\r\n      }\r\n      \r\n      const subscriptionData = await response.json();\r\n      \r\n      // Store locally for offline access\r\n      localStorage.setItem('subscription_status', JSON.stringify({\r\n        isActive: true,\r\n        plan: subscriptionData.plan,\r\n        expiresAt: subscriptionData.expiresAt,\r\n        freeAlertsUsed: 0,\r\n        freeAlertsLimit: 3\r\n      }));\r\n      \r\n      return subscriptionData;\r\n    } catch (error) {\r\n      console.error('Subscription creation error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Cancel current subscription\r\n  async cancelSubscription() {\r\n    try {\r\n      const response = await fetch(`${this.apiUrl}/cancel`, {\r\n        method: 'POST',\r\n        headers: authService.getAuthHeaders()\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const error = await response.json();\r\n        throw new Error(error.message || 'Subscription cancellation failed');\r\n      }\r\n      \r\n      const result = await response.json();\r\n      \r\n      // Update local storage\r\n      const storedStatus = localStorage.getItem('subscription_status');\r\n      if (storedStatus) {\r\n        try {\r\n          const status = JSON.parse(storedStatus);\r\n          status.isActive = false;\r\n          localStorage.setItem('subscription_status', JSON.stringify(status));\r\n        } catch (e) {\r\n          console.error('Error updating stored subscription status:', e);\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Subscription cancellation error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Check if user has any free alerts remaining\r\n  async hasFreeAlertsRemaining() {\r\n    const status = await this.getSubscriptionStatus();\r\n    \r\n    if (status.isActive) {\r\n      return true; // Subscribed users have unlimited alerts\r\n    }\r\n    \r\n    return status.freeAlertsUsed < status.freeAlertsLimit;\r\n  }\r\n  \r\n  // Use a free alert\r\n  async useFreeAlert() {\r\n    try {\r\n      const response = await fetch(`${this.apiUrl}/use-free-alert`, {\r\n        method: 'POST',\r\n        headers: authService.getAuthHeaders()\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const error = await response.json();\r\n        throw new Error(error.message || 'Failed to use free alert');\r\n      }\r\n      \r\n      const result = await response.json();\r\n      \r\n      // Update local storage\r\n      const storedStatus = localStorage.getItem('subscription_status');\r\n      if (storedStatus) {\r\n        try {\r\n          const status = JSON.parse(storedStatus);\r\n          status.freeAlertsUsed = result.freeAlertsUsed;\r\n          localStorage.setItem('subscription_status', JSON.stringify(status));\r\n        } catch (e) {\r\n          console.error('Error updating stored free alerts:', e);\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error using free alert:', error);\r\n      \r\n      // Fallback to updating locally if offline\r\n      if (!navigator.onLine) {\r\n        const storedStatus = localStorage.getItem('subscription_status');\r\n        if (storedStatus) {\r\n          try {\r\n            const status = JSON.parse(storedStatus);\r\n            if (status.freeAlertsUsed < status.freeAlertsLimit) {\r\n              status.freeAlertsUsed++;\r\n              localStorage.setItem('subscription_status', JSON.stringify(status));\r\n              return {\r\n                success: true,\r\n                freeAlertsUsed: status.freeAlertsUsed,\r\n                freeAlertsLimit: status.freeAlertsLimit\r\n              };\r\n            }\r\n          } catch (e) {\r\n            console.error('Error updating stored free alerts:', e);\r\n          }\r\n        }\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Get remaining free alerts count\r\n  async getRemainingFreeAlerts() {\r\n    const status = await this.getSubscriptionStatus();\r\n    \r\n    if (status.isActive) {\r\n      return Infinity; // Subscribed users have unlimited alerts\r\n    }\r\n    \r\n    return Math.max(0, status.freeAlertsLimit - status.freeAlertsUsed);\r\n  }\r\n  \r\n  // Get payment methods\r\n  async getPaymentMethods() {\r\n    try {\r\n      const response = await fetch(`${this.apiUrl}/payment-methods`, {\r\n        headers: authService.getAuthHeaders()\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error('Failed to get payment methods');\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('Error getting payment methods:', error);\r\n      return { paymentMethods: [] };\r\n    }\r\n  }\r\n  \r\n  // Add payment method\r\n  async addPaymentMethod(paymentDetails) {\r\n    try {\r\n      const response = await fetch(`${this.apiUrl}/payment-methods`, {\r\n        method: 'POST',\r\n        headers: authService.getAuthHeaders(),\r\n        body: JSON.stringify(paymentDetails)\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const error = await response.json();\r\n        throw new Error(error.message || 'Failed to add payment method');\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('Error adding payment method:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Get subscription history\r\n  async getSubscriptionHistory() {\r\n    try {\r\n      const response = await fetch(`${this.apiUrl}/history`, {\r\n        headers: authService.getAuthHeaders()\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error('Failed to get subscription history');\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('Error getting subscription history:', error);\r\n      return { history: [] };\r\n    }\r\n  }\r\n  \r\n  // Apply promo code\r\n  async applyPromoCode(code) {\r\n    try {\r\n      const response = await fetch(`${this.apiUrl}/promo`, {\r\n        method: 'POST',\r\n        headers: authService.getAuthHeaders(),\r\n        body: JSON.stringify({ code })\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const error = await response.json();\r\n        throw new Error(error.message || 'Invalid promo code');\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('Error applying promo code:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Create mock payment method UI data for frontend\r\n  getMockPaymentUI() {\r\n    // In a real implementation, this would integrate with Stripe, PayPal, etc.\r\n    return {\r\n      paymentMethods: [\r\n        { type: 'credit_card', name: 'Visa', iconUrl: '/icons/visa.svg' },\r\n        { type: 'credit_card', name: 'Mastercard', iconUrl: '/icons/mastercard.svg' },\r\n        { type: 'paypal', name: 'PayPal', iconUrl: '/icons/paypal.svg' },\r\n        { type: 'apple_pay', name: 'Apple Pay', iconUrl: '/icons/apple-pay.svg' },\r\n        { type: 'google_pay', name: 'Google Pay', iconUrl: '/icons/google-pay.svg' }\r\n      ]\r\n    };\r\n  }\r\n}\r\n\r\nexport default new SubscriptionService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}