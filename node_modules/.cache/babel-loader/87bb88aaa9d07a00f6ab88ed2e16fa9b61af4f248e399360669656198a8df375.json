{"ast":null,"code":"// src/services/offlineDataService.js\n\nclass OfflineDataService {\n  constructor() {\n    this.dbName = 'travelPlannerDB';\n    this.dbVersion = 1;\n    this.db = null;\n    this.initPromise = this.initDB();\n  }\n  async initDB() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n\n        // Create stores if they don't exist\n        if (!db.objectStoreNames.contains('trips')) {\n          const tripsStore = db.createObjectStore('trips', {\n            keyPath: 'id'\n          });\n          tripsStore.createIndex('userId', 'userId', {\n            unique: false\n          });\n        }\n        if (!db.objectStoreNames.contains('flightBookmarks')) {\n          const bookmarksStore = db.createObjectStore('flightBookmarks', {\n            keyPath: 'id'\n          });\n          bookmarksStore.createIndex('userId', 'userId', {\n            unique: false\n          });\n        }\n        if (!db.objectStoreNames.contains('pendingChanges')) {\n          db.createObjectStore('pendingChanges', {\n            keyPath: 'id',\n            autoIncrement: true\n          });\n        }\n      };\n      request.onsuccess = event => {\n        this.db = event.target.result;\n        console.log('IndexedDB initialized successfully');\n        resolve();\n      };\n      request.onerror = event => {\n        console.error('IndexedDB initialization error:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  // Ensure database is initialized before any operation\n  async ensureDB() {\n    if (!this.db) {\n      await this.initPromise;\n    }\n    return this.db;\n  }\n\n  // Trips CRUD operations\n  async getTrips(userId) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('trips', 'readonly');\n      const store = transaction.objectStore('trips');\n      const index = store.index('userId');\n      const request = index.getAll(userId);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async getTrip(tripId) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('trips', 'readonly');\n      const store = transaction.objectStore('trips');\n      const request = store.get(tripId);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async saveTrip(trip) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('trips', 'readwrite');\n      const store = transaction.objectStore('trips');\n      const request = store.put(trip);\n      request.onsuccess = () => {\n        // Add to pending changes if offline\n        if (!navigator.onLine) {\n          this.addPendingChange({\n            type: 'SAVE_TRIP',\n            data: trip,\n            timestamp: Date.now()\n          });\n        }\n        resolve(trip);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async deleteTrip(tripId) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('trips', 'readwrite');\n      const store = transaction.objectStore('trips');\n      const request = store.delete(tripId);\n      request.onsuccess = () => {\n        // Add to pending changes if offline\n        if (!navigator.onLine) {\n          this.addPendingChange({\n            type: 'DELETE_TRIP',\n            data: {\n              id: tripId\n            },\n            timestamp: Date.now()\n          });\n        }\n        resolve();\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Flight bookmarks operations\n  async getFlightBookmarks(userId) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('flightBookmarks', 'readonly');\n      const store = transaction.objectStore('flightBookmarks');\n      const index = store.index('userId');\n      const request = index.getAll(userId);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async saveFlightBookmark(bookmark) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('flightBookmarks', 'readwrite');\n      const store = transaction.objectStore('flightBookmarks');\n      const request = store.put(bookmark);\n      request.onsuccess = () => {\n        // Add to pending changes if offline\n        if (!navigator.onLine) {\n          this.addPendingChange({\n            type: 'SAVE_BOOKMARK',\n            data: bookmark,\n            timestamp: Date.now()\n          });\n        }\n        resolve(bookmark);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async deleteFlightBookmark(bookmarkId) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('flightBookmarks', 'readwrite');\n      const store = transaction.objectStore('flightBookmarks');\n      const request = store.delete(bookmarkId);\n      request.onsuccess = () => {\n        // Add to pending changes if offline\n        if (!navigator.onLine) {\n          this.addPendingChange({\n            type: 'DELETE_BOOKMARK',\n            data: {\n              id: bookmarkId\n            },\n            timestamp: Date.now()\n          });\n        }\n        resolve();\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Pending changes management\n  async addPendingChange(change) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('pendingChanges', 'readwrite');\n      const store = transaction.objectStore('pendingChanges');\n      const request = store.add(change);\n      request.onsuccess = () => {\n        // Register for sync when back online\n        if ('serviceWorker' in navigator && 'SyncManager' in window) {\n          navigator.serviceWorker.ready.then(registration => {\n            registration.sync.register('sync-trips');\n          });\n        }\n        resolve();\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async getPendingChanges() {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('pendingChanges', 'readonly');\n      const store = transaction.objectStore('pendingChanges');\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async clearPendingChange(changeId) {\n    await this.ensureDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction('pendingChanges', 'readwrite');\n      const store = transaction.objectStore('pendingChanges');\n      const request = store.delete(changeId);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Sync changes with server when online\n  async syncChanges() {\n    if (!navigator.onLine) {\n      return {\n        success: false,\n        reason: 'offline'\n      };\n    }\n    try {\n      const changes = await this.getPendingChanges();\n      if (changes.length === 0) {\n        return {\n          success: true,\n          syncedCount: 0\n        };\n      }\n      let successCount = 0;\n      for (const change of changes) {\n        try {\n          // Process based on change type\n          switch (change.type) {\n            case 'SAVE_TRIP':\n              await fetch('/api/trips', {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(change.data)\n              });\n              break;\n            case 'DELETE_TRIP':\n              await fetch(`/api/trips/${change.data.id}`, {\n                method: 'DELETE'\n              });\n              break;\n            case 'SAVE_BOOKMARK':\n              await fetch('/api/bookmarks', {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(change.data)\n              });\n              break;\n            case 'DELETE_BOOKMARK':\n              await fetch(`/api/bookmarks/${change.data.id}`, {\n                method: 'DELETE'\n              });\n              break;\n          }\n\n          // If successful, remove from pending changes\n          await this.clearPendingChange(change.id);\n          successCount++;\n        } catch (error) {\n          console.error('Error syncing change:', error);\n        }\n      }\n      return {\n        success: true,\n        syncedCount: successCount,\n        totalCount: changes.length\n      };\n    } catch (error) {\n      console.error('Error in syncChanges:', error);\n      return {\n        success: false,\n        error\n      };\n    }\n  }\n}\nexport default new OfflineDataService();","map":{"version":3,"names":["OfflineDataService","constructor","dbName","dbVersion","db","initPromise","initDB","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","tripsStore","createObjectStore","keyPath","createIndex","unique","bookmarksStore","autoIncrement","onsuccess","console","log","onerror","error","ensureDB","getTrips","userId","transaction","store","objectStore","index","getAll","getTrip","tripId","get","saveTrip","trip","put","navigator","onLine","addPendingChange","type","data","timestamp","Date","now","deleteTrip","delete","id","getFlightBookmarks","saveFlightBookmark","bookmark","deleteFlightBookmark","bookmarkId","change","add","window","serviceWorker","ready","then","registration","sync","register","getPendingChanges","clearPendingChange","changeId","syncChanges","success","reason","changes","length","syncedCount","successCount","fetch","method","headers","body","JSON","stringify","totalCount"],"sources":["C:/Users/juliu/Desktop/web/src/services/offlineDataService.js"],"sourcesContent":["// src/services/offlineDataService.js\r\n\r\nclass OfflineDataService {\r\n    constructor() {\r\n      this.dbName = 'travelPlannerDB';\r\n      this.dbVersion = 1;\r\n      this.db = null;\r\n      this.initPromise = this.initDB();\r\n    }\r\n    \r\n    async initDB() {\r\n      return new Promise((resolve, reject) => {\r\n        const request = indexedDB.open(this.dbName, this.dbVersion);\r\n        \r\n        request.onupgradeneeded = (event) => {\r\n          const db = event.target.result;\r\n          \r\n          // Create stores if they don't exist\r\n          if (!db.objectStoreNames.contains('trips')) {\r\n            const tripsStore = db.createObjectStore('trips', { keyPath: 'id' });\r\n            tripsStore.createIndex('userId', 'userId', { unique: false });\r\n          }\r\n          \r\n          if (!db.objectStoreNames.contains('flightBookmarks')) {\r\n            const bookmarksStore = db.createObjectStore('flightBookmarks', { keyPath: 'id' });\r\n            bookmarksStore.createIndex('userId', 'userId', { unique: false });\r\n          }\r\n          \r\n          if (!db.objectStoreNames.contains('pendingChanges')) {\r\n            db.createObjectStore('pendingChanges', { keyPath: 'id', autoIncrement: true });\r\n          }\r\n        };\r\n        \r\n        request.onsuccess = (event) => {\r\n          this.db = event.target.result;\r\n          console.log('IndexedDB initialized successfully');\r\n          resolve();\r\n        };\r\n        \r\n        request.onerror = (event) => {\r\n          console.error('IndexedDB initialization error:', event.target.error);\r\n          reject(event.target.error);\r\n        };\r\n      });\r\n    }\r\n    \r\n    // Ensure database is initialized before any operation\r\n    async ensureDB() {\r\n      if (!this.db) {\r\n        await this.initPromise;\r\n      }\r\n      return this.db;\r\n    }\r\n    \r\n    // Trips CRUD operations\r\n    async getTrips(userId) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('trips', 'readonly');\r\n        const store = transaction.objectStore('trips');\r\n        const index = store.index('userId');\r\n        const request = index.getAll(userId);\r\n        \r\n        request.onsuccess = () => resolve(request.result);\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    async getTrip(tripId) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('trips', 'readonly');\r\n        const store = transaction.objectStore('trips');\r\n        const request = store.get(tripId);\r\n        \r\n        request.onsuccess = () => resolve(request.result);\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    async saveTrip(trip) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('trips', 'readwrite');\r\n        const store = transaction.objectStore('trips');\r\n        const request = store.put(trip);\r\n        \r\n        request.onsuccess = () => {\r\n          // Add to pending changes if offline\r\n          if (!navigator.onLine) {\r\n            this.addPendingChange({\r\n              type: 'SAVE_TRIP',\r\n              data: trip,\r\n              timestamp: Date.now()\r\n            });\r\n          }\r\n          resolve(trip);\r\n        };\r\n        \r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    async deleteTrip(tripId) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('trips', 'readwrite');\r\n        const store = transaction.objectStore('trips');\r\n        const request = store.delete(tripId);\r\n        \r\n        request.onsuccess = () => {\r\n          // Add to pending changes if offline\r\n          if (!navigator.onLine) {\r\n            this.addPendingChange({\r\n              type: 'DELETE_TRIP',\r\n              data: { id: tripId },\r\n              timestamp: Date.now()\r\n            });\r\n          }\r\n          resolve();\r\n        };\r\n        \r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    // Flight bookmarks operations\r\n    async getFlightBookmarks(userId) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('flightBookmarks', 'readonly');\r\n        const store = transaction.objectStore('flightBookmarks');\r\n        const index = store.index('userId');\r\n        const request = index.getAll(userId);\r\n        \r\n        request.onsuccess = () => resolve(request.result);\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    async saveFlightBookmark(bookmark) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('flightBookmarks', 'readwrite');\r\n        const store = transaction.objectStore('flightBookmarks');\r\n        const request = store.put(bookmark);\r\n        \r\n        request.onsuccess = () => {\r\n          // Add to pending changes if offline\r\n          if (!navigator.onLine) {\r\n            this.addPendingChange({\r\n              type: 'SAVE_BOOKMARK',\r\n              data: bookmark,\r\n              timestamp: Date.now()\r\n            });\r\n          }\r\n          resolve(bookmark);\r\n        };\r\n        \r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    async deleteFlightBookmark(bookmarkId) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('flightBookmarks', 'readwrite');\r\n        const store = transaction.objectStore('flightBookmarks');\r\n        const request = store.delete(bookmarkId);\r\n        \r\n        request.onsuccess = () => {\r\n          // Add to pending changes if offline\r\n          if (!navigator.onLine) {\r\n            this.addPendingChange({\r\n              type: 'DELETE_BOOKMARK',\r\n              data: { id: bookmarkId },\r\n              timestamp: Date.now()\r\n            });\r\n          }\r\n          resolve();\r\n        };\r\n        \r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    // Pending changes management\r\n    async addPendingChange(change) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('pendingChanges', 'readwrite');\r\n        const store = transaction.objectStore('pendingChanges');\r\n        const request = store.add(change);\r\n        \r\n        request.onsuccess = () => {\r\n          // Register for sync when back online\r\n          if ('serviceWorker' in navigator && 'SyncManager' in window) {\r\n            navigator.serviceWorker.ready.then(registration => {\r\n              registration.sync.register('sync-trips');\r\n            });\r\n          }\r\n          resolve();\r\n        };\r\n        \r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    async getPendingChanges() {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('pendingChanges', 'readonly');\r\n        const store = transaction.objectStore('pendingChanges');\r\n        const request = store.getAll();\r\n        \r\n        request.onsuccess = () => resolve(request.result);\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    async clearPendingChange(changeId) {\r\n      await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = this.db.transaction('pendingChanges', 'readwrite');\r\n        const store = transaction.objectStore('pendingChanges');\r\n        const request = store.delete(changeId);\r\n        \r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    }\r\n    \r\n    // Sync changes with server when online\r\n    async syncChanges() {\r\n      if (!navigator.onLine) {\r\n        return { success: false, reason: 'offline' };\r\n      }\r\n      \r\n      try {\r\n        const changes = await this.getPendingChanges();\r\n        \r\n        if (changes.length === 0) {\r\n          return { success: true, syncedCount: 0 };\r\n        }\r\n        \r\n        let successCount = 0;\r\n        \r\n        for (const change of changes) {\r\n          try {\r\n            // Process based on change type\r\n            switch (change.type) {\r\n              case 'SAVE_TRIP':\r\n                await fetch('/api/trips', {\r\n                  method: 'POST',\r\n                  headers: {\r\n                    'Content-Type': 'application/json'\r\n                  },\r\n                  body: JSON.stringify(change.data)\r\n                });\r\n                break;\r\n                \r\n              case 'DELETE_TRIP':\r\n                await fetch(`/api/trips/${change.data.id}`, {\r\n                  method: 'DELETE'\r\n                });\r\n                break;\r\n                \r\n              case 'SAVE_BOOKMARK':\r\n                await fetch('/api/bookmarks', {\r\n                  method: 'POST',\r\n                  headers: {\r\n                    'Content-Type': 'application/json'\r\n                  },\r\n                  body: JSON.stringify(change.data)\r\n                });\r\n                break;\r\n                \r\n              case 'DELETE_BOOKMARK':\r\n                await fetch(`/api/bookmarks/${change.data.id}`, {\r\n                  method: 'DELETE'\r\n                });\r\n                break;\r\n            }\r\n            \r\n            // If successful, remove from pending changes\r\n            await this.clearPendingChange(change.id);\r\n            successCount++;\r\n          } catch (error) {\r\n            console.error('Error syncing change:', error);\r\n          }\r\n        }\r\n        \r\n        return { \r\n          success: true, \r\n          syncedCount: successCount,\r\n          totalCount: changes.length\r\n        };\r\n      } catch (error) {\r\n        console.error('Error in syncChanges:', error);\r\n        return { success: false, error };\r\n      }\r\n    }\r\n  }\r\n  \r\n  export default new OfflineDataService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}