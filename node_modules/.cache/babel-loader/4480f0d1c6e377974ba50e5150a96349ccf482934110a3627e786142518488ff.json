{"ast":null,"code":"// Check if service workers are supported\nexport function register() {\n  if ('serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n      registerValidSW(swUrl);\n    });\n  }\n}\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker.register(swUrl).then(registration => {\n    // Successfully registered\n    console.log('Service Worker registered with scope:', registration.scope);\n    registration.onupdatefound = () => {\n      const installingWorker = registration.installing;\n      if (installingWorker == null) {\n        return;\n      }\n      installingWorker.onstatechange = () => {\n        if (installingWorker.state === 'installed') {\n          if (navigator.serviceWorker.controller) {\n            // At this point, the updated SW has been installed, but the previous\n            // version is still controlling the page - reload to use the new version\n            console.log('New service worker available. Refresh the page to use it.');\n\n            // Dispatch event for the app to show an update notification\n            const event = new CustomEvent('serviceWorkerUpdated');\n            window.dispatchEvent(event);\n          } else {\n            // At this point, everything has been pre-cached\n            console.log('Service Worker installed. Content is cached for offline use.');\n\n            // Dispatch event for the app to show offline-ready notification\n            const event = new CustomEvent('serviceWorkerInstalled');\n            window.dispatchEvent(event);\n          }\n        }\n      };\n    };\n  }).catch(error => {\n    console.error('Error during service worker registration:', error);\n  });\n}\n\n// Function to check if we need to update the service worker\nexport function checkForUpdates() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.update();\n    });\n  }\n}\n\n// Function to unregister the service worker\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    }).catch(error => {\n      console.error(error.message);\n    });\n  }\n}\n\n// Function to trigger sync when online\nexport function triggerSync() {\n  if ('serviceWorker' in navigator && 'SyncManager' in window) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.sync.register('sync-trips').then(() => {\n        console.log('Sync registered');\n      }).catch(err => {\n        console.log('Sync registration failed:', err);\n\n        // Fallback for browsers that don't support background sync\n        // Immediately try to sync data\n        syncDataImmediately();\n      });\n    });\n  } else {\n    // Fallback for browsers that don't support service workers or sync\n    syncDataImmediately();\n  }\n}\n\n// Fallback sync function for browsers without background sync support\nfunction syncDataImmediately() {\n  // In a real app, this would call an API endpoint\n  console.log('Performing immediate sync');\n\n  // Get unsynchronized data from localStorage\n  const unsynced = JSON.parse(localStorage.getItem('unsyncedChanges') || '[]');\n  if (unsynced.length === 0) {\n    console.log('No unsynced changes to process');\n    return;\n  }\n  console.log(`Syncing ${unsynced.length} unsynced changes`);\n\n  // Mark as synced\n  localStorage.setItem('unsyncedChanges', '[]');\n\n  // Update the last sync time\n  localStorage.setItem('lastSyncTime', new Date().toISOString());\n  console.log('Immediate sync completed');\n}\n\n// Function to handle offline changes\nexport function saveOfflineChange(changeType, data) {\n  // Get existing unsynced changes\n  const unsynced = JSON.parse(localStorage.getItem('unsyncedChanges') || '[]');\n\n  // Add new change\n  unsynced.push({\n    type: changeType,\n    // 'add', 'update', 'delete'\n    data: data,\n    timestamp: new Date().toISOString()\n  });\n\n  // Save back to localStorage\n  localStorage.setItem('unsyncedChanges', JSON.stringify(unsynced));\n\n  // If online, trigger sync\n  if (navigator.onLine) {\n    triggerSync();\n  }\n}","map":{"version":3,"names":["register","navigator","window","addEventListener","swUrl","process","env","PUBLIC_URL","registerValidSW","serviceWorker","then","registration","console","log","scope","onupdatefound","installingWorker","installing","onstatechange","state","controller","event","CustomEvent","dispatchEvent","catch","error","checkForUpdates","ready","update","unregister","message","triggerSync","sync","err","syncDataImmediately","unsynced","JSON","parse","localStorage","getItem","length","setItem","Date","toISOString","saveOfflineChange","changeType","data","push","type","timestamp","stringify","onLine"],"sources":["C:/Users/juliu/Desktop/web/src/serviceWorkerRegistration.js"],"sourcesContent":["// Check if service workers are supported\r\nexport function register() {\r\n    if ('serviceWorker' in navigator) {\r\n      window.addEventListener('load', () => {\r\n        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n        \r\n        registerValidSW(swUrl);\r\n      });\r\n    }\r\n  }\r\n  \r\n  function registerValidSW(swUrl) {\r\n    navigator.serviceWorker\r\n      .register(swUrl)\r\n      .then(registration => {\r\n        // Successfully registered\r\n        console.log('Service Worker registered with scope:', registration.scope);\r\n        \r\n        registration.onupdatefound = () => {\r\n          const installingWorker = registration.installing;\r\n          if (installingWorker == null) {\r\n            return;\r\n          }\r\n          \r\n          installingWorker.onstatechange = () => {\r\n            if (installingWorker.state === 'installed') {\r\n              if (navigator.serviceWorker.controller) {\r\n                // At this point, the updated SW has been installed, but the previous\r\n                // version is still controlling the page - reload to use the new version\r\n                console.log('New service worker available. Refresh the page to use it.');\r\n                \r\n                // Dispatch event for the app to show an update notification\r\n                const event = new CustomEvent('serviceWorkerUpdated');\r\n                window.dispatchEvent(event);\r\n              } else {\r\n                // At this point, everything has been pre-cached\r\n                console.log('Service Worker installed. Content is cached for offline use.');\r\n                \r\n                // Dispatch event for the app to show offline-ready notification\r\n                const event = new CustomEvent('serviceWorkerInstalled');\r\n                window.dispatchEvent(event);\r\n              }\r\n            }\r\n          };\r\n        };\r\n      })\r\n      .catch(error => {\r\n        console.error('Error during service worker registration:', error);\r\n      });\r\n  }\r\n  \r\n  // Function to check if we need to update the service worker\r\n  export function checkForUpdates() {\r\n    if ('serviceWorker' in navigator) {\r\n      navigator.serviceWorker.ready.then(registration => {\r\n        registration.update();\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Function to unregister the service worker\r\n  export function unregister() {\r\n    if ('serviceWorker' in navigator) {\r\n      navigator.serviceWorker.ready\r\n        .then(registration => {\r\n          registration.unregister();\r\n        })\r\n        .catch(error => {\r\n          console.error(error.message);\r\n        });\r\n    }\r\n  }\r\n  \r\n  // Function to trigger sync when online\r\n  export function triggerSync() {\r\n    if ('serviceWorker' in navigator && 'SyncManager' in window) {\r\n      navigator.serviceWorker.ready.then(registration => {\r\n        registration.sync.register('sync-trips')\r\n          .then(() => {\r\n            console.log('Sync registered');\r\n          })\r\n          .catch(err => {\r\n            console.log('Sync registration failed:', err);\r\n            \r\n            // Fallback for browsers that don't support background sync\r\n            // Immediately try to sync data\r\n            syncDataImmediately();\r\n          });\r\n      });\r\n    } else {\r\n      // Fallback for browsers that don't support service workers or sync\r\n      syncDataImmediately();\r\n    }\r\n  }\r\n  \r\n  // Fallback sync function for browsers without background sync support\r\n  function syncDataImmediately() {\r\n    // In a real app, this would call an API endpoint\r\n    console.log('Performing immediate sync');\r\n    \r\n    // Get unsynchronized data from localStorage\r\n    const unsynced = JSON.parse(localStorage.getItem('unsyncedChanges') || '[]');\r\n    \r\n    if (unsynced.length === 0) {\r\n      console.log('No unsynced changes to process');\r\n      return;\r\n    }\r\n    \r\n    console.log(`Syncing ${unsynced.length} unsynced changes`);\r\n    \r\n    // Mark as synced\r\n    localStorage.setItem('unsyncedChanges', '[]');\r\n    \r\n    // Update the last sync time\r\n    localStorage.setItem('lastSyncTime', new Date().toISOString());\r\n    \r\n    console.log('Immediate sync completed');\r\n  }\r\n  \r\n  // Function to handle offline changes\r\n  export function saveOfflineChange(changeType, data) {\r\n    // Get existing unsynced changes\r\n    const unsynced = JSON.parse(localStorage.getItem('unsyncedChanges') || '[]');\r\n    \r\n    // Add new change\r\n    unsynced.push({\r\n      type: changeType, // 'add', 'update', 'delete'\r\n      data: data,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n    // Save back to localStorage\r\n    localStorage.setItem('unsyncedChanges', JSON.stringify(unsynced));\r\n    \r\n    // If online, trigger sync\r\n    if (navigator.onLine) {\r\n      triggerSync();\r\n    }\r\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}