{"ast":null,"code":"// src/data/mongoProvider.js\nconst mongoose = require('mongoose');\nconst {\n  Schema\n} = mongoose;\n\n// Load environment variables\nrequire('dotenv').config();\n\n// Connection URI\nconst MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/travel_planner';\n\n// Connect to MongoDB\nmongoose.connect(MONGODB_URI, {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n});\n\n// Connection events\nmongoose.connection.on('connected', () => {\n  console.log('Connected to MongoDB');\n});\nmongoose.connection.on('error', err => {\n  console.error('MongoDB connection error:', err);\n});\n\n// Define schemas\nconst SubscriptionSchema = new Schema({\n  accessCode: {\n    type: String,\n    unique: true,\n    index: true\n  },\n  platform: {\n    type: String,\n    enum: ['web', 'ios', 'android']\n  },\n  originalTransactionId: {\n    type: String,\n    unique: true,\n    sparse: true\n  },\n  receiptData: String,\n  status: {\n    type: String,\n    enum: ['active', 'expired', 'cancelled', 'trial']\n  },\n  expiresAt: Date,\n  createdAt: {\n    type: Date,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    default: Date.now\n  },\n  planId: String,\n  deviceId: String,\n  activations: [{\n    deviceId: String,\n    platform: String,\n    activatedAt: Date\n  }],\n  maxActivations: {\n    type: Number,\n    default: 3\n  }\n});\n\n// Add pre-save middleware to update 'updatedAt' field\nSubscriptionSchema.pre('save', function (next) {\n  this.updatedAt = new Date();\n  next();\n});\n\n// Create models\nconst SubscriptionModel = mongoose.model('Subscription', SubscriptionSchema);\n\n// Define CRUD operations\nconst mongoProvider = {\n  // Subscription methods\n  async createSubscription(subscriptionData) {\n    try {\n      const subscription = new SubscriptionModel(subscriptionData);\n      await subscription.save();\n      return subscription;\n    } catch (error) {\n      console.error('Error creating subscription:', error);\n      throw error;\n    }\n  },\n  async getSubscriptionByAccessCode(accessCode) {\n    try {\n      return await SubscriptionModel.findOne({\n        accessCode\n      });\n    } catch (error) {\n      console.error('Error finding subscription by access code:', error);\n      throw error;\n    }\n  },\n  async getSubscriptionByTransactionId(transactionId) {\n    try {\n      return await SubscriptionModel.findOne({\n        originalTransactionId: transactionId\n      });\n    } catch (error) {\n      console.error('Error finding subscription by transaction ID:', error);\n      throw error;\n    }\n  },\n  async updateSubscription(accessCode, updates) {\n    try {\n      return await SubscriptionModel.findOneAndUpdate({\n        accessCode\n      }, updates, {\n        new: true\n      });\n    } catch (error) {\n      console.error('Error updating subscription:', error);\n      throw error;\n    }\n  },\n  async activateSubscriptionOnDevice(accessCode, deviceId, platform) {\n    try {\n      const subscription = await SubscriptionModel.findOne({\n        accessCode\n      });\n      if (!subscription) {\n        throw new Error('Subscription not found');\n      }\n\n      // Check if maximum activations reached\n      if (subscription.activations.length >= subscription.maxActivations) {\n        throw new Error('Maximum device activations reached');\n      }\n\n      // Check if device is already activated\n      const isDeviceActivated = subscription.activations.some(a => a.deviceId === deviceId);\n      if (!isDeviceActivated) {\n        subscription.activations.push({\n          deviceId,\n          platform,\n          activatedAt: new Date()\n        });\n        await subscription.save();\n      }\n      return subscription;\n    } catch (error) {\n      console.error('Error activating subscription on device:', error);\n      throw error;\n    }\n  },\n  async deactivateSubscriptionOnDevice(accessCode, deviceId) {\n    try {\n      const subscription = await SubscriptionModel.findOne({\n        accessCode\n      });\n      if (!subscription) {\n        throw new Error('Subscription not found');\n      }\n      subscription.activations = subscription.activations.filter(a => a.deviceId !== deviceId);\n      await subscription.save();\n      return subscription;\n    } catch (error) {\n      console.error('Error deactivating subscription on device:', error);\n      throw error;\n    }\n  },\n  async getAllSubscriptions() {\n    try {\n      return await SubscriptionModel.find({});\n    } catch (error) {\n      console.error('Error getting all subscriptions:', error);\n      throw error;\n    }\n  },\n  async getActiveSubscriptions() {\n    try {\n      return await SubscriptionModel.find({\n        status: 'active'\n      });\n    } catch (error) {\n      console.error('Error getting active subscriptions:', error);\n      throw error;\n    }\n  }\n};\nmodule.exports = mongoProvider;","map":{"version":3,"names":["mongoose","require","Schema","config","MONGODB_URI","process","env","connect","useNewUrlParser","useUnifiedTopology","connection","on","console","log","err","error","SubscriptionSchema","accessCode","type","String","unique","index","platform","enum","originalTransactionId","sparse","receiptData","status","expiresAt","Date","createdAt","default","now","updatedAt","planId","deviceId","activations","activatedAt","maxActivations","Number","pre","next","SubscriptionModel","model","mongoProvider","createSubscription","subscriptionData","subscription","save","getSubscriptionByAccessCode","findOne","getSubscriptionByTransactionId","transactionId","updateSubscription","updates","findOneAndUpdate","new","activateSubscriptionOnDevice","Error","length","isDeviceActivated","some","a","push","deactivateSubscriptionOnDevice","filter","getAllSubscriptions","find","getActiveSubscriptions","module","exports"],"sources":["C:/Users/juliu/Desktop/web/src/data/mongoProvider.js"],"sourcesContent":["// src/data/mongoProvider.js\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\n\r\n// Load environment variables\r\nrequire('dotenv').config();\r\n\r\n// Connection URI\r\nconst MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/travel_planner';\r\n\r\n// Connect to MongoDB\r\nmongoose.connect(MONGODB_URI, {\r\n  useNewUrlParser: true,\r\n  useUnifiedTopology: true,\r\n});\r\n\r\n// Connection events\r\nmongoose.connection.on('connected', () => {\r\n  console.log('Connected to MongoDB');\r\n});\r\n\r\nmongoose.connection.on('error', (err) => {\r\n  console.error('MongoDB connection error:', err);\r\n});\r\n\r\n// Define schemas\r\nconst SubscriptionSchema = new Schema({\r\n  accessCode: { type: String, unique: true, index: true },\r\n  platform: { type: String, enum: ['web', 'ios', 'android'] },\r\n  originalTransactionId: { type: String, unique: true, sparse: true },\r\n  receiptData: String,\r\n  status: { type: String, enum: ['active', 'expired', 'cancelled', 'trial'] },\r\n  expiresAt: Date,\r\n  createdAt: { type: Date, default: Date.now },\r\n  updatedAt: { type: Date, default: Date.now },\r\n  planId: String,\r\n  deviceId: String,\r\n  activations: [{ \r\n    deviceId: String, \r\n    platform: String, \r\n    activatedAt: Date \r\n  }],\r\n  maxActivations: { type: Number, default: 3 }\r\n});\r\n\r\n// Add pre-save middleware to update 'updatedAt' field\r\nSubscriptionSchema.pre('save', function(next) {\r\n  this.updatedAt = new Date();\r\n  next();\r\n});\r\n\r\n// Create models\r\nconst SubscriptionModel = mongoose.model('Subscription', SubscriptionSchema);\r\n\r\n// Define CRUD operations\r\nconst mongoProvider = {\r\n  // Subscription methods\r\n  async createSubscription(subscriptionData) {\r\n    try {\r\n      const subscription = new SubscriptionModel(subscriptionData);\r\n      await subscription.save();\r\n      return subscription;\r\n    } catch (error) {\r\n      console.error('Error creating subscription:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getSubscriptionByAccessCode(accessCode) {\r\n    try {\r\n      return await SubscriptionModel.findOne({ accessCode });\r\n    } catch (error) {\r\n      console.error('Error finding subscription by access code:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getSubscriptionByTransactionId(transactionId) {\r\n    try {\r\n      return await SubscriptionModel.findOne({ originalTransactionId: transactionId });\r\n    } catch (error) {\r\n      console.error('Error finding subscription by transaction ID:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async updateSubscription(accessCode, updates) {\r\n    try {\r\n      return await SubscriptionModel.findOneAndUpdate(\r\n        { accessCode },\r\n        updates,\r\n        { new: true }\r\n      );\r\n    } catch (error) {\r\n      console.error('Error updating subscription:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async activateSubscriptionOnDevice(accessCode, deviceId, platform) {\r\n    try {\r\n      const subscription = await SubscriptionModel.findOne({ accessCode });\r\n      if (!subscription) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n\r\n      // Check if maximum activations reached\r\n      if (subscription.activations.length >= subscription.maxActivations) {\r\n        throw new Error('Maximum device activations reached');\r\n      }\r\n\r\n      // Check if device is already activated\r\n      const isDeviceActivated = subscription.activations.some(a => a.deviceId === deviceId);\r\n      if (!isDeviceActivated) {\r\n        subscription.activations.push({\r\n          deviceId,\r\n          platform,\r\n          activatedAt: new Date()\r\n        });\r\n        await subscription.save();\r\n      }\r\n\r\n      return subscription;\r\n    } catch (error) {\r\n      console.error('Error activating subscription on device:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async deactivateSubscriptionOnDevice(accessCode, deviceId) {\r\n    try {\r\n      const subscription = await SubscriptionModel.findOne({ accessCode });\r\n      if (!subscription) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n\r\n      subscription.activations = subscription.activations.filter(a => a.deviceId !== deviceId);\r\n      await subscription.save();\r\n      return subscription;\r\n    } catch (error) {\r\n      console.error('Error deactivating subscription on device:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getAllSubscriptions() {\r\n    try {\r\n      return await SubscriptionModel.find({});\r\n    } catch (error) {\r\n      console.error('Error getting all subscriptions:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getActiveSubscriptions() {\r\n    try {\r\n      return await SubscriptionModel.find({ status: 'active' });\r\n    } catch (error) {\r\n      console.error('Error getting active subscriptions:', error);\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = mongoProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}