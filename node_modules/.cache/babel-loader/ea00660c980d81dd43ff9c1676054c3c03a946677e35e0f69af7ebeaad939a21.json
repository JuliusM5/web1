{"ast":null,"code":"// src/utils/errorMonitoring.js\n// Browser-compatible error monitoring\n// Error storage for debugging\nconst errorLog = [];\nconst MAX_ERRORS = 100;\nconst initErrorMonitoring = () => {\n  // Set up global error handler\n  window.addEventListener('error', event => {\n    captureError(event.error || new Error(event.message));\n  });\n\n  // Handle unhandled promise rejections\n  window.addEventListener('unhandledrejection', event => {\n    captureError(event.reason || new Error('Unhandled promise rejection'));\n  });\n  console.log('Error monitoring initialized');\n};\nexport const captureError = (error, extraInfo = {}) => {\n  console.error('Error captured:', error, extraInfo);\n\n  // Store error in the log\n  errorLog.unshift({\n    message: error.message,\n    stack: error.stack,\n    timestamp: new Date().toISOString(),\n    extra: extraInfo\n  });\n\n  // Keep the log size manageable\n  if (errorLog.length > MAX_ERRORS) {\n    errorLog.pop();\n  }\n\n  // In production, you would send this to your server\n  if (process.env.NODE_ENV === 'production') {\n    try {\n      // Simple error reporting via fetch\n      fetch('/api/errors', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message: error.message,\n          stack: error.stack,\n          timestamp: new Date().toISOString(),\n          extra: extraInfo,\n          userAgent: navigator.userAgent,\n          url: window.location.href\n        }),\n        // Don't wait for response\n        keepalive: true\n      }).catch(() => {\n        // Ignore errors in error reporting\n      });\n    } catch (e) {\n      // Fail silently - we don't want error reporting to cause more errors\n    }\n  }\n};\nexport const setErrorUser = user => {\n  // Store user info in localStorage for error reporting\n  if (user) {\n    try {\n      localStorage.setItem('error_user', JSON.stringify({\n        id: user.id,\n        subscription: user.hasSubscription ? 'active' : 'inactive'\n      }));\n    } catch (e) {\n      // Ignore storage errors\n    }\n  }\n};\nexport const clearErrorUser = () => {\n  try {\n    localStorage.removeItem('error_user');\n  } catch (e) {\n    // Ignore storage errors\n  }\n};\n\n// For debugging - allows viewing recent errors\nexport const getErrorLog = () => [...errorLog];\nexport default initErrorMonitoring;","map":{"version":3,"names":["errorLog","MAX_ERRORS","initErrorMonitoring","window","addEventListener","event","captureError","error","Error","message","reason","console","log","extraInfo","unshift","stack","timestamp","Date","toISOString","extra","length","pop","process","env","NODE_ENV","fetch","method","headers","body","JSON","stringify","userAgent","navigator","url","location","href","keepalive","catch","e","setErrorUser","user","localStorage","setItem","id","subscription","hasSubscription","clearErrorUser","removeItem","getErrorLog"],"sources":["C:/Users/juliu/Desktop/web/src/utils/errorMonitoring.js"],"sourcesContent":["// src/utils/errorMonitoring.js\r\n// Browser-compatible error monitoring\r\n// Error storage for debugging\r\nconst errorLog = [];\r\nconst MAX_ERRORS = 100;\r\n\r\nconst initErrorMonitoring = () => {\r\n  // Set up global error handler\r\n  window.addEventListener('error', (event) => {\r\n    captureError(event.error || new Error(event.message));\r\n  });\r\n  \r\n  // Handle unhandled promise rejections\r\n  window.addEventListener('unhandledrejection', (event) => {\r\n    captureError(event.reason || new Error('Unhandled promise rejection'));\r\n  });\r\n  \r\n  console.log('Error monitoring initialized');\r\n};\r\n\r\nexport const captureError = (error, extraInfo = {}) => {\r\n  console.error('Error captured:', error, extraInfo);\r\n  \r\n  // Store error in the log\r\n  errorLog.unshift({\r\n    message: error.message,\r\n    stack: error.stack,\r\n    timestamp: new Date().toISOString(),\r\n    extra: extraInfo\r\n  });\r\n  \r\n  // Keep the log size manageable\r\n  if (errorLog.length > MAX_ERRORS) {\r\n    errorLog.pop();\r\n  }\r\n  \r\n  // In production, you would send this to your server\r\n  if (process.env.NODE_ENV === 'production') {\r\n    try {\r\n      // Simple error reporting via fetch\r\n      fetch('/api/errors', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          message: error.message,\r\n          stack: error.stack,\r\n          timestamp: new Date().toISOString(),\r\n          extra: extraInfo,\r\n          userAgent: navigator.userAgent,\r\n          url: window.location.href\r\n        }),\r\n        // Don't wait for response\r\n        keepalive: true\r\n      }).catch(() => {\r\n        // Ignore errors in error reporting\r\n      });\r\n    } catch (e) {\r\n      // Fail silently - we don't want error reporting to cause more errors\r\n    }\r\n  }\r\n};\r\n\r\nexport const setErrorUser = (user) => {\r\n  // Store user info in localStorage for error reporting\r\n  if (user) {\r\n    try {\r\n      localStorage.setItem('error_user', JSON.stringify({\r\n        id: user.id,\r\n        subscription: user.hasSubscription ? 'active' : 'inactive'\r\n      }));\r\n    } catch (e) {\r\n      // Ignore storage errors\r\n    }\r\n  }\r\n};\r\n\r\nexport const clearErrorUser = () => {\r\n  try {\r\n    localStorage.removeItem('error_user');\r\n  } catch (e) {\r\n    // Ignore storage errors\r\n  }\r\n};\r\n\r\n// For debugging - allows viewing recent errors\r\nexport const getErrorLog = () => [...errorLog];\r\n\r\nexport default initErrorMonitoring;"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,QAAQ,GAAG,EAAE;AACnB,MAAMC,UAAU,GAAG,GAAG;AAEtB,MAAMC,mBAAmB,GAAGA,CAAA,KAAM;EAChC;EACAC,MAAM,CAACC,gBAAgB,CAAC,OAAO,EAAGC,KAAK,IAAK;IAC1CC,YAAY,CAACD,KAAK,CAACE,KAAK,IAAI,IAAIC,KAAK,CAACH,KAAK,CAACI,OAAO,CAAC,CAAC;EACvD,CAAC,CAAC;;EAEF;EACAN,MAAM,CAACC,gBAAgB,CAAC,oBAAoB,EAAGC,KAAK,IAAK;IACvDC,YAAY,CAACD,KAAK,CAACK,MAAM,IAAI,IAAIF,KAAK,CAAC,6BAA6B,CAAC,CAAC;EACxE,CAAC,CAAC;EAEFG,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;AAC7C,CAAC;AAED,OAAO,MAAMN,YAAY,GAAGA,CAACC,KAAK,EAAEM,SAAS,GAAG,CAAC,CAAC,KAAK;EACrDF,OAAO,CAACJ,KAAK,CAAC,iBAAiB,EAAEA,KAAK,EAAEM,SAAS,CAAC;;EAElD;EACAb,QAAQ,CAACc,OAAO,CAAC;IACfL,OAAO,EAAEF,KAAK,CAACE,OAAO;IACtBM,KAAK,EAAER,KAAK,CAACQ,KAAK;IAClBC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACnCC,KAAK,EAAEN;EACT,CAAC,CAAC;;EAEF;EACA,IAAIb,QAAQ,CAACoB,MAAM,GAAGnB,UAAU,EAAE;IAChCD,QAAQ,CAACqB,GAAG,CAAC,CAAC;EAChB;;EAEA;EACA,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC,IAAI;MACF;MACAC,KAAK,CAAC,aAAa,EAAE;QACnBC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UAAE,cAAc,EAAE;QAAmB,CAAC;QAC/CC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBrB,OAAO,EAAEF,KAAK,CAACE,OAAO;UACtBM,KAAK,EAAER,KAAK,CAACQ,KAAK;UAClBC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACnCC,KAAK,EAAEN,SAAS;UAChBkB,SAAS,EAAEC,SAAS,CAACD,SAAS;UAC9BE,GAAG,EAAE9B,MAAM,CAAC+B,QAAQ,CAACC;QACvB,CAAC,CAAC;QACF;QACAC,SAAS,EAAE;MACb,CAAC,CAAC,CAACC,KAAK,CAAC,MAAM;QACb;MAAA,CACD,CAAC;IACJ,CAAC,CAAC,OAAOC,CAAC,EAAE;MACV;IAAA;EAEJ;AACF,CAAC;AAED,OAAO,MAAMC,YAAY,GAAIC,IAAI,IAAK;EACpC;EACA,IAAIA,IAAI,EAAE;IACR,IAAI;MACFC,YAAY,CAACC,OAAO,CAAC,YAAY,EAAEb,IAAI,CAACC,SAAS,CAAC;QAChDa,EAAE,EAAEH,IAAI,CAACG,EAAE;QACXC,YAAY,EAAEJ,IAAI,CAACK,eAAe,GAAG,QAAQ,GAAG;MAClD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,OAAOP,CAAC,EAAE;MACV;IAAA;EAEJ;AACF,CAAC;AAED,OAAO,MAAMQ,cAAc,GAAGA,CAAA,KAAM;EAClC,IAAI;IACFL,YAAY,CAACM,UAAU,CAAC,YAAY,CAAC;EACvC,CAAC,CAAC,OAAOT,CAAC,EAAE;IACV;EAAA;AAEJ,CAAC;;AAED;AACA,OAAO,MAAMU,WAAW,GAAGA,CAAA,KAAM,CAAC,GAAGhD,QAAQ,CAAC;AAE9C,eAAeE,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}