{"ast":null,"code":"// src/data/inMemoryProvider.js\n// Browser-compatible version without fs/path dependencies\n\n// In-memory storage\nconst subscriptions = [];\nconst inMemoryProvider = {\n  // Subscription methods\n  async createSubscription(subscriptionData) {\n    try {\n      // Generate an ID if not provided\n      if (!subscriptionData.id) {\n        subscriptionData.id = Math.random().toString(36).substring(2, 15);\n      }\n\n      // Add timestamps\n      subscriptionData.createdAt = subscriptionData.createdAt || new Date();\n      subscriptionData.updatedAt = new Date();\n\n      // Store in memory\n      subscriptions.push(subscriptionData);\n      return {\n        ...subscriptionData\n      };\n    } catch (error) {\n      console.error('Error creating subscription:', error);\n      throw error;\n    }\n  },\n  async getSubscriptionByAccessCode(accessCode) {\n    try {\n      return subscriptions.find(sub => sub.accessCode === accessCode) || null;\n    } catch (error) {\n      console.error('Error finding subscription by access code:', error);\n      throw error;\n    }\n  },\n  async getSubscriptionByTransactionId(transactionId) {\n    try {\n      return subscriptions.find(sub => sub.originalTransactionId === transactionId) || null;\n    } catch (error) {\n      console.error('Error finding subscription by transaction ID:', error);\n      throw error;\n    }\n  },\n  async updateSubscription(accessCode, updates) {\n    try {\n      const index = subscriptions.findIndex(sub => sub.accessCode === accessCode);\n      if (index === -1) {\n        throw new Error('Subscription not found');\n      }\n\n      // Update the subscription\n      const updatedSubscription = {\n        ...subscriptions[index],\n        ...updates,\n        updatedAt: new Date()\n      };\n      subscriptions[index] = updatedSubscription;\n      return {\n        ...updatedSubscription\n      };\n    } catch (error) {\n      console.error('Error updating subscription:', error);\n      throw error;\n    }\n  },\n  async activateSubscriptionOnDevice(accessCode, deviceId, platform) {\n    try {\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\n      if (!subscription) {\n        throw new Error('Subscription not found');\n      }\n\n      // Check if maximum activations reached\n      if (subscription.activations && subscription.activations.length >= (subscription.maxActivations || 3)) {\n        throw new Error('Maximum device activations reached');\n      }\n\n      // Initialize activations array if it doesn't exist\n      if (!subscription.activations) {\n        subscription.activations = [];\n      }\n\n      // Check if device is already activated\n      const isDeviceActivated = subscription.activations.some(a => a.deviceId === deviceId);\n      if (!isDeviceActivated) {\n        subscription.activations.push({\n          deviceId,\n          platform,\n          activatedAt: new Date()\n        });\n      }\n\n      // Update the subscription\n      return await this.updateSubscription(accessCode, {\n        activations: subscription.activations\n      });\n    } catch (error) {\n      console.error('Error activating subscription on device:', error);\n      throw error;\n    }\n  },\n  async deactivateSubscriptionOnDevice(accessCode, deviceId) {\n    try {\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\n      if (!subscription) {\n        throw new Error('Subscription not found');\n      }\n\n      // Filter out the device\n      const activations = (subscription.activations || []).filter(a => a.deviceId !== deviceId);\n\n      // Update the subscription\n      return await this.updateSubscription(accessCode, {\n        activations\n      });\n    } catch (error) {\n      console.error('Error deactivating subscription on device:', error);\n      throw error;\n    }\n  },\n  async getAllSubscriptions() {\n    try {\n      return [...subscriptions];\n    } catch (error) {\n      console.error('Error getting all subscriptions:', error);\n      throw error;\n    }\n  },\n  async getActiveSubscriptions() {\n    try {\n      return subscriptions.filter(sub => sub.status === 'active');\n    } catch (error) {\n      console.error('Error getting active subscriptions:', error);\n      throw error;\n    }\n  },\n  // For development/testing only\n  _clearSubscriptions() {\n    subscriptions.length = 0;\n  }\n};\nexport default inMemoryProvider;","map":{"version":3,"names":["subscriptions","inMemoryProvider","createSubscription","subscriptionData","id","Math","random","toString","substring","createdAt","Date","updatedAt","push","error","console","getSubscriptionByAccessCode","accessCode","find","sub","getSubscriptionByTransactionId","transactionId","originalTransactionId","updateSubscription","updates","index","findIndex","Error","updatedSubscription","activateSubscriptionOnDevice","deviceId","platform","subscription","activations","length","maxActivations","isDeviceActivated","some","a","activatedAt","deactivateSubscriptionOnDevice","filter","getAllSubscriptions","getActiveSubscriptions","status","_clearSubscriptions"],"sources":["C:/Users/juliu/Desktop/web/src/data/inMemoryProvider.js"],"sourcesContent":["// src/data/inMemoryProvider.js\r\n// Browser-compatible version without fs/path dependencies\r\n\r\n// In-memory storage\r\nconst subscriptions = [];\r\n\r\nconst inMemoryProvider = {\r\n  // Subscription methods\r\n  async createSubscription(subscriptionData) {\r\n    try {\r\n      // Generate an ID if not provided\r\n      if (!subscriptionData.id) {\r\n        subscriptionData.id = Math.random().toString(36).substring(2, 15);\r\n      }\r\n      \r\n      // Add timestamps\r\n      subscriptionData.createdAt = subscriptionData.createdAt || new Date();\r\n      subscriptionData.updatedAt = new Date();\r\n      \r\n      // Store in memory\r\n      subscriptions.push(subscriptionData);\r\n      \r\n      return { ...subscriptionData };\r\n    } catch (error) {\r\n      console.error('Error creating subscription:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getSubscriptionByAccessCode(accessCode) {\r\n    try {\r\n      return subscriptions.find(sub => sub.accessCode === accessCode) || null;\r\n    } catch (error) {\r\n      console.error('Error finding subscription by access code:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getSubscriptionByTransactionId(transactionId) {\r\n    try {\r\n      return subscriptions.find(sub => sub.originalTransactionId === transactionId) || null;\r\n    } catch (error) {\r\n      console.error('Error finding subscription by transaction ID:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async updateSubscription(accessCode, updates) {\r\n    try {\r\n      const index = subscriptions.findIndex(sub => sub.accessCode === accessCode);\r\n      \r\n      if (index === -1) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n      \r\n      // Update the subscription\r\n      const updatedSubscription = {\r\n        ...subscriptions[index],\r\n        ...updates,\r\n        updatedAt: new Date()\r\n      };\r\n      \r\n      subscriptions[index] = updatedSubscription;\r\n      \r\n      return { ...updatedSubscription };\r\n    } catch (error) {\r\n      console.error('Error updating subscription:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async activateSubscriptionOnDevice(accessCode, deviceId, platform) {\r\n    try {\r\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n      \r\n      // Check if maximum activations reached\r\n      if (subscription.activations && subscription.activations.length >= (subscription.maxActivations || 3)) {\r\n        throw new Error('Maximum device activations reached');\r\n      }\r\n      \r\n      // Initialize activations array if it doesn't exist\r\n      if (!subscription.activations) {\r\n        subscription.activations = [];\r\n      }\r\n      \r\n      // Check if device is already activated\r\n      const isDeviceActivated = subscription.activations.some(a => a.deviceId === deviceId);\r\n      \r\n      if (!isDeviceActivated) {\r\n        subscription.activations.push({\r\n          deviceId,\r\n          platform,\r\n          activatedAt: new Date()\r\n        });\r\n      }\r\n      \r\n      // Update the subscription\r\n      return await this.updateSubscription(accessCode, {\r\n        activations: subscription.activations\r\n      });\r\n    } catch (error) {\r\n      console.error('Error activating subscription on device:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async deactivateSubscriptionOnDevice(accessCode, deviceId) {\r\n    try {\r\n      const subscription = await this.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription) {\r\n        throw new Error('Subscription not found');\r\n      }\r\n      \r\n      // Filter out the device\r\n      const activations = (subscription.activations || []).filter(a => a.deviceId !== deviceId);\r\n      \r\n      // Update the subscription\r\n      return await this.updateSubscription(accessCode, {\r\n        activations\r\n      });\r\n    } catch (error) {\r\n      console.error('Error deactivating subscription on device:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getAllSubscriptions() {\r\n    try {\r\n      return [...subscriptions];\r\n    } catch (error) {\r\n      console.error('Error getting all subscriptions:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getActiveSubscriptions() {\r\n    try {\r\n      return subscriptions.filter(sub => sub.status === 'active');\r\n    } catch (error) {\r\n      console.error('Error getting active subscriptions:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // For development/testing only\r\n  _clearSubscriptions() {\r\n    subscriptions.length = 0;\r\n  }\r\n};\r\n\r\nexport default inMemoryProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}