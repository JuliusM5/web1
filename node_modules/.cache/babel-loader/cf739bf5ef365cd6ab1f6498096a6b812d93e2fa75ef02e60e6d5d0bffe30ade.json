{"ast":null,"code":"// src/models/TokenizedSubscription.js\n\n/**\r\n * Client-side utility for handling subscription tokens\r\n * For development purposes only\r\n */\nclass TokenizedSubscription {\n  /**\r\n   * Generate a secure random token\r\n   * @returns {string} Generated token\r\n   */\n  static generateToken() {\n    // In a browser environment, use a simple random string\n    return 'token_' + Math.random().toString(36).substring(2) + Date.now().toString(36);\n  }\n\n  /**\r\n   * Generate a mobile access code\r\n   * @returns {string} Formatted mobile code (XXXX-XXXX-XXXX)\r\n   */\n  static generateMobileAccessCode() {\n    // Create readable code in XXXX-XXXX-XXXX format\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Omit similar-looking characters\n    let code = '';\n\n    // Generate 12 characters\n    for (let i = 0; i < 12; i++) {\n      const randomIndex = Math.floor(Math.random() * chars.length);\n      code += chars[randomIndex];\n\n      // Add dashes after every 4 characters (except at the end)\n      if ((i + 1) % 4 === 0 && i < 11) {\n        code += '-';\n      }\n    }\n    return code;\n  }\n\n  /**\r\n   * Verify a subscription token\r\n   * @param {string} token - Token to verify\r\n   * @returns {Object} Verification result\r\n   */\n  static async verifyToken(token) {\n    if (!token) return {\n      valid: false\n    };\n\n    // For development, check localStorage manually\n    // In production, this would be a server call\n    const storedToken = localStorage.getItem('subscription_token');\n    const expiryDate = localStorage.getItem('subscription_expiry');\n    if (token !== storedToken) return {\n      valid: false\n    };\n\n    // Check if token is expired\n    const isExpired = expiryDate && new Date(expiryDate) <= new Date();\n    if (isExpired) return {\n      valid: false\n    };\n    return {\n      valid: true,\n      plan: 'monthly_premium',\n      // For development - in production this would come from the server\n      expiresAt: expiryDate\n    };\n  }\n\n  /**\r\n   * Verify a mobile access code\r\n   * @param {string} code - Mobile access code to verify\r\n   * @returns {Object} Verification result\r\n   */\n  static async verifyMobileCode(code) {\n    // For development, always return success\n    // In production, this would verify against your database\n    return {\n      valid: true,\n      plan: 'monthly_premium',\n      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n      accessToken: 'token_' + Math.random().toString(36).substring(2)\n    };\n  }\n}\nexport default TokenizedSubscription;","map":{"version":3,"names":["TokenizedSubscription","generateToken","Math","random","toString","substring","Date","now","generateMobileAccessCode","chars","code","i","randomIndex","floor","length","verifyToken","token","valid","storedToken","localStorage","getItem","expiryDate","isExpired","plan","expiresAt","verifyMobileCode","toISOString","accessToken"],"sources":["C:/Users/juliu/Desktop/web/src/components/Subscription/PremiumContentGuard.jsx"],"sourcesContent":["// src/models/TokenizedSubscription.js\r\n\r\n/**\r\n * Client-side utility for handling subscription tokens\r\n * For development purposes only\r\n */\r\nclass TokenizedSubscription {\r\n  /**\r\n   * Generate a secure random token\r\n   * @returns {string} Generated token\r\n   */\r\n  static generateToken() {\r\n    // In a browser environment, use a simple random string\r\n    return 'token_' + Math.random().toString(36).substring(2) + Date.now().toString(36);\r\n  }\r\n\r\n  /**\r\n   * Generate a mobile access code\r\n   * @returns {string} Formatted mobile code (XXXX-XXXX-XXXX)\r\n   */\r\n  static generateMobileAccessCode() {\r\n    // Create readable code in XXXX-XXXX-XXXX format\r\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Omit similar-looking characters\r\n    let code = '';\r\n    \r\n    // Generate 12 characters\r\n    for (let i = 0; i < 12; i++) {\r\n      const randomIndex = Math.floor(Math.random() * chars.length);\r\n      code += chars[randomIndex];\r\n      \r\n      // Add dashes after every 4 characters (except at the end)\r\n      if ((i + 1) % 4 === 0 && i < 11) {\r\n        code += '-';\r\n      }\r\n    }\r\n    \r\n    return code;\r\n  }\r\n\r\n  /**\r\n   * Verify a subscription token\r\n   * @param {string} token - Token to verify\r\n   * @returns {Object} Verification result\r\n   */\r\n  static async verifyToken(token) {\r\n    if (!token) return { valid: false };\r\n    \r\n    // For development, check localStorage manually\r\n    // In production, this would be a server call\r\n    const storedToken = localStorage.getItem('subscription_token');\r\n    const expiryDate = localStorage.getItem('subscription_expiry');\r\n    \r\n    if (token !== storedToken) return { valid: false };\r\n    \r\n    // Check if token is expired\r\n    const isExpired = expiryDate && new Date(expiryDate) <= new Date();\r\n    if (isExpired) return { valid: false };\r\n    \r\n    return {\r\n      valid: true,\r\n      plan: 'monthly_premium', // For development - in production this would come from the server\r\n      expiresAt: expiryDate\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verify a mobile access code\r\n   * @param {string} code - Mobile access code to verify\r\n   * @returns {Object} Verification result\r\n   */\r\n  static async verifyMobileCode(code) {\r\n    // For development, always return success\r\n    // In production, this would verify against your database\r\n    return {\r\n      valid: true,\r\n      plan: 'monthly_premium',\r\n      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\r\n      accessToken: 'token_' + Math.random().toString(36).substring(2)\r\n    };\r\n  }\r\n}\r\n\r\nexport default TokenizedSubscription;"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA,MAAMA,qBAAqB,CAAC;EAC1B;AACF;AACA;AACA;EACE,OAAOC,aAAaA,CAAA,EAAG;IACrB;IACA,OAAO,QAAQ,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAACH,QAAQ,CAAC,EAAE,CAAC;EACrF;;EAEA;AACF;AACA;AACA;EACE,OAAOI,wBAAwBA,CAAA,EAAG;IAChC;IACA,MAAMC,KAAK,GAAG,kCAAkC,CAAC,CAAC;IAClD,IAAIC,IAAI,GAAG,EAAE;;IAEb;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MAC3B,MAAMC,WAAW,GAAGV,IAAI,CAACW,KAAK,CAACX,IAAI,CAACC,MAAM,CAAC,CAAC,GAAGM,KAAK,CAACK,MAAM,CAAC;MAC5DJ,IAAI,IAAID,KAAK,CAACG,WAAW,CAAC;;MAE1B;MACA,IAAI,CAACD,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAIA,CAAC,GAAG,EAAE,EAAE;QAC/BD,IAAI,IAAI,GAAG;MACb;IACF;IAEA,OAAOA,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACE,aAAaK,WAAWA,CAACC,KAAK,EAAE;IAC9B,IAAI,CAACA,KAAK,EAAE,OAAO;MAAEC,KAAK,EAAE;IAAM,CAAC;;IAEnC;IACA;IACA,MAAMC,WAAW,GAAGC,YAAY,CAACC,OAAO,CAAC,oBAAoB,CAAC;IAC9D,MAAMC,UAAU,GAAGF,YAAY,CAACC,OAAO,CAAC,qBAAqB,CAAC;IAE9D,IAAIJ,KAAK,KAAKE,WAAW,EAAE,OAAO;MAAED,KAAK,EAAE;IAAM,CAAC;;IAElD;IACA,MAAMK,SAAS,GAAGD,UAAU,IAAI,IAAIf,IAAI,CAACe,UAAU,CAAC,IAAI,IAAIf,IAAI,CAAC,CAAC;IAClE,IAAIgB,SAAS,EAAE,OAAO;MAAEL,KAAK,EAAE;IAAM,CAAC;IAEtC,OAAO;MACLA,KAAK,EAAE,IAAI;MACXM,IAAI,EAAE,iBAAiB;MAAE;MACzBC,SAAS,EAAEH;IACb,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACE,aAAaI,gBAAgBA,CAACf,IAAI,EAAE;IAClC;IACA;IACA,OAAO;MACLO,KAAK,EAAE,IAAI;MACXM,IAAI,EAAE,iBAAiB;MACvBC,SAAS,EAAE,IAAIlB,IAAI,CAACA,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAACmB,WAAW,CAAC,CAAC;MACxEC,WAAW,EAAE,QAAQ,GAAGzB,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC;IAChE,CAAC;EACH;AACF;AAEA,eAAeL,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}