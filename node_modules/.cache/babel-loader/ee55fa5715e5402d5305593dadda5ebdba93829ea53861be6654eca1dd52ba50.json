{"ast":null,"code":"// src/models/TokenizedSubscription.js\n\n/**\r\n * Client-side utility for handling subscription tokens\r\n */\nclass TokenizedSubscription {\n  /**\r\n   * Generate a secure random token\r\n   * @returns {string} Generated token\r\n   */\n  static generateToken() {\n    // Create a more secure token with random bytes\n    const randomBytes = new Uint8Array(24);\n    window.crypto.getRandomValues(randomBytes);\n\n    // Convert to hex string and add timestamp\n    const tokenBase = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Add timestamp to ensure uniqueness\n    const timestamp = Date.now().toString(36);\n    return `tok_${tokenBase}_${timestamp}`;\n  }\n\n  /**\r\n   * Generate a mobile access code\r\n   * @returns {string} Formatted mobile code (XXXX-XXXX-XXXX)\r\n   */\n  static generateMobileAccessCode() {\n    // Create readable code in XXXX-XXXX-XXXX format\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Omit similar-looking characters\n\n    // Generate random values\n    const randomBytes = new Uint8Array(12);\n    window.crypto.getRandomValues(randomBytes);\n\n    // Convert to code\n    let code = '';\n    for (let i = 0; i < 12; i++) {\n      const randomIndex = randomBytes[i] % chars.length;\n      code += chars[randomIndex];\n\n      // Add dashes after every 4 characters (except at the end)\n      if ((i + 1) % 4 === 0 && i < 11) {\n        code += '-';\n      }\n    }\n    return code;\n  }\n\n  /**\r\n   * Store subscription details securely\r\n   * @param {string} token - Access token\r\n   * @param {string} plan - Subscription plan\r\n   * @param {Date} expiryDate - Expiration date\r\n   * @returns {Object} Stored subscription info\r\n   */\n  static storeSubscription(token, plan, expiryDate) {\n    // Store basic subscription info\n    localStorage.setItem('subscription_token', token);\n    localStorage.setItem('subscription_expiry', expiryDate.toISOString());\n    localStorage.setItem('subscription_plan', plan);\n\n    // Store creation timestamp for reference\n    localStorage.setItem('subscription_created_at', new Date().toISOString());\n\n    // Create a validation hash to detect tampering\n    const validationHash = this.createValidationHash(token, plan, expiryDate);\n    localStorage.setItem('subscription_validation', validationHash);\n    return {\n      token,\n      plan,\n      expiresAt: expiryDate.toISOString()\n    };\n  }\n\n  /**\r\n   * Create a validation hash to detect tampering\r\n   * @private\r\n   */\n  static createValidationHash(token, plan, expiryDate) {\n    // Simple validation hash based on token and expiry\n    // In a real app, this would use proper cryptographic hashing\n    const expiry = expiryDate instanceof Date ? expiryDate.toISOString() : expiryDate;\n    return btoa(`${token}:${plan}:${expiry}`);\n  }\n\n  /**\r\n   * Verify a subscription token\r\n   * @param {string} token - Token to verify\r\n   * @returns {Object} Verification result\r\n   */\n  static async verifyToken(token) {\n    if (!token) return {\n      valid: false,\n      reason: 'missing_token'\n    };\n    try {\n      // Get stored subscription data\n      const storedToken = localStorage.getItem('subscription_token');\n      const expiryDate = localStorage.getItem('subscription_expiry');\n      const plan = localStorage.getItem('subscription_plan');\n      const validationHash = localStorage.getItem('subscription_validation');\n\n      // Verify token matches\n      if (token !== storedToken) {\n        return {\n          valid: false,\n          reason: 'invalid_token'\n        };\n      }\n\n      // Check if token is expired\n      const isExpired = expiryDate && new Date(expiryDate) <= new Date();\n      if (isExpired) {\n        return {\n          valid: false,\n          reason: 'expired'\n        };\n      }\n\n      // Verify hash to detect tampering\n      const expectedHash = this.createValidationHash(token, plan, expiryDate);\n      if (validationHash !== expectedHash) {\n        return {\n          valid: false,\n          reason: 'tampered'\n        };\n      }\n\n      // Token is valid\n      return {\n        valid: true,\n        plan,\n        expiresAt: expiryDate,\n        daysRemaining: this.calculateDaysRemaining(expiryDate)\n      };\n    } catch (error) {\n      console.error('Token verification failed:', error);\n      return {\n        valid: false,\n        error: error.message,\n        reason: 'error'\n      };\n    }\n  }\n\n  /**\r\n   * Calculate days remaining in subscription\r\n   * @private\r\n   */\n  static calculateDaysRemaining(expiryDateStr) {\n    const expiryDate = new Date(expiryDateStr);\n    const now = new Date();\n\n    // Calculate difference in days\n    const diffTime = expiryDate - now;\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    return Math.max(0, diffDays);\n  }\n\n  /**\r\n   * Verify a mobile access code\r\n   * @param {string} code - Mobile access code to verify\r\n   * @returns {Object} Verification result\r\n   */\n  static async verifyMobileCode(code) {\n    try {\n      // Validate code format first\n      if (!code || !/^[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(code)) {\n        return {\n          valid: false,\n          error: 'Invalid code format'\n        };\n      }\n\n      // In a real app, this would call a server endpoint to verify the code\n      // For development, we'll create a mock successful response\n\n      // Generate a new token for the mobile device\n      const accessToken = this.generateToken();\n\n      // Set expiry date (30 days from now for development)\n      const expiryDate = new Date();\n      expiryDate.setDate(expiryDate.getDate() + 30);\n      return {\n        valid: true,\n        accessToken,\n        plan: 'monthly_premium',\n        // Assume monthly plan\n        expiresAt: expiryDate.toISOString()\n      };\n    } catch (error) {\n      console.error('Code verification failed:', error);\n      return {\n        valid: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\r\n   * Clear subscription data from storage\r\n   */\n  static clearSubscription() {\n    localStorage.removeItem('subscription_token');\n    localStorage.removeItem('subscription_expiry');\n    localStorage.removeItem('subscription_plan');\n    localStorage.removeItem('subscription_created_at');\n    localStorage.removeItem('subscription_validation');\n  }\n\n  /**\r\n   * Check if the subscription is about to expire\r\n   * @returns {boolean} True if subscription expires in less than 7 days\r\n   */\n  static isAboutToExpire() {\n    const expiryDate = localStorage.getItem('subscription_expiry');\n    if (!expiryDate) return false;\n    const daysRemaining = this.calculateDaysRemaining(expiryDate);\n    return daysRemaining > 0 && daysRemaining <= 7;\n  }\n}\nexport default TokenizedSubscription;","map":{"version":3,"names":["TokenizedSubscription","generateToken","randomBytes","Uint8Array","window","crypto","getRandomValues","tokenBase","Array","from","map","b","toString","padStart","join","timestamp","Date","now","generateMobileAccessCode","chars","code","i","randomIndex","length","storeSubscription","token","plan","expiryDate","localStorage","setItem","toISOString","validationHash","createValidationHash","expiresAt","expiry","btoa","verifyToken","valid","reason","storedToken","getItem","isExpired","expectedHash","daysRemaining","calculateDaysRemaining","error","console","message","expiryDateStr","diffTime","diffDays","Math","ceil","max","verifyMobileCode","test","accessToken","setDate","getDate","clearSubscription","removeItem","isAboutToExpire"],"sources":["C:/Users/juliu/Desktop/web/src/models/TokenizedSubscription.js"],"sourcesContent":["// src/models/TokenizedSubscription.js\r\n\r\n/**\r\n * Client-side utility for handling subscription tokens\r\n */\r\nclass TokenizedSubscription {\r\n  /**\r\n   * Generate a secure random token\r\n   * @returns {string} Generated token\r\n   */\r\n  static generateToken() {\r\n    // Create a more secure token with random bytes\r\n    const randomBytes = new Uint8Array(24);\r\n    window.crypto.getRandomValues(randomBytes);\r\n    \r\n    // Convert to hex string and add timestamp\r\n    const tokenBase = Array.from(randomBytes)\r\n      .map(b => b.toString(16).padStart(2, '0'))\r\n      .join('');\r\n    \r\n    // Add timestamp to ensure uniqueness\r\n    const timestamp = Date.now().toString(36);\r\n    \r\n    return `tok_${tokenBase}_${timestamp}`;\r\n  }\r\n\r\n  /**\r\n   * Generate a mobile access code\r\n   * @returns {string} Formatted mobile code (XXXX-XXXX-XXXX)\r\n   */\r\n  static generateMobileAccessCode() {\r\n    // Create readable code in XXXX-XXXX-XXXX format\r\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Omit similar-looking characters\r\n    \r\n    // Generate random values\r\n    const randomBytes = new Uint8Array(12);\r\n    window.crypto.getRandomValues(randomBytes);\r\n    \r\n    // Convert to code\r\n    let code = '';\r\n    for (let i = 0; i < 12; i++) {\r\n      const randomIndex = randomBytes[i] % chars.length;\r\n      code += chars[randomIndex];\r\n      \r\n      // Add dashes after every 4 characters (except at the end)\r\n      if ((i + 1) % 4 === 0 && i < 11) {\r\n        code += '-';\r\n      }\r\n    }\r\n    \r\n    return code;\r\n  }\r\n\r\n  /**\r\n   * Store subscription details securely\r\n   * @param {string} token - Access token\r\n   * @param {string} plan - Subscription plan\r\n   * @param {Date} expiryDate - Expiration date\r\n   * @returns {Object} Stored subscription info\r\n   */\r\n  static storeSubscription(token, plan, expiryDate) {\r\n    // Store basic subscription info\r\n    localStorage.setItem('subscription_token', token);\r\n    localStorage.setItem('subscription_expiry', expiryDate.toISOString());\r\n    localStorage.setItem('subscription_plan', plan);\r\n    \r\n    // Store creation timestamp for reference\r\n    localStorage.setItem('subscription_created_at', new Date().toISOString());\r\n    \r\n    // Create a validation hash to detect tampering\r\n    const validationHash = this.createValidationHash(token, plan, expiryDate);\r\n    localStorage.setItem('subscription_validation', validationHash);\r\n    \r\n    return {\r\n      token,\r\n      plan,\r\n      expiresAt: expiryDate.toISOString()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a validation hash to detect tampering\r\n   * @private\r\n   */\r\n  static createValidationHash(token, plan, expiryDate) {\r\n    // Simple validation hash based on token and expiry\r\n    // In a real app, this would use proper cryptographic hashing\r\n    const expiry = expiryDate instanceof Date ? expiryDate.toISOString() : expiryDate;\r\n    return btoa(`${token}:${plan}:${expiry}`);\r\n  }\r\n\r\n  /**\r\n   * Verify a subscription token\r\n   * @param {string} token - Token to verify\r\n   * @returns {Object} Verification result\r\n   */\r\n  static async verifyToken(token) {\r\n    if (!token) return { valid: false, reason: 'missing_token' };\r\n    \r\n    try {\r\n      // Get stored subscription data\r\n      const storedToken = localStorage.getItem('subscription_token');\r\n      const expiryDate = localStorage.getItem('subscription_expiry');\r\n      const plan = localStorage.getItem('subscription_plan');\r\n      const validationHash = localStorage.getItem('subscription_validation');\r\n      \r\n      // Verify token matches\r\n      if (token !== storedToken) {\r\n        return { valid: false, reason: 'invalid_token' };\r\n      }\r\n      \r\n      // Check if token is expired\r\n      const isExpired = expiryDate && new Date(expiryDate) <= new Date();\r\n      if (isExpired) {\r\n        return { valid: false, reason: 'expired' };\r\n      }\r\n      \r\n      // Verify hash to detect tampering\r\n      const expectedHash = this.createValidationHash(token, plan, expiryDate);\r\n      if (validationHash !== expectedHash) {\r\n        return { valid: false, reason: 'tampered' };\r\n      }\r\n      \r\n      // Token is valid\r\n      return {\r\n        valid: true,\r\n        plan,\r\n        expiresAt: expiryDate,\r\n        daysRemaining: this.calculateDaysRemaining(expiryDate)\r\n      };\r\n    } catch (error) {\r\n      console.error('Token verification failed:', error);\r\n      return { valid: false, error: error.message, reason: 'error' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate days remaining in subscription\r\n   * @private\r\n   */\r\n  static calculateDaysRemaining(expiryDateStr) {\r\n    const expiryDate = new Date(expiryDateStr);\r\n    const now = new Date();\r\n    \r\n    // Calculate difference in days\r\n    const diffTime = expiryDate - now;\r\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\r\n    \r\n    return Math.max(0, diffDays);\r\n  }\r\n\r\n  /**\r\n   * Verify a mobile access code\r\n   * @param {string} code - Mobile access code to verify\r\n   * @returns {Object} Verification result\r\n   */\r\n  static async verifyMobileCode(code) {\r\n    try {\r\n      // Validate code format first\r\n      if (!code || !/^[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(code)) {\r\n        return { valid: false, error: 'Invalid code format' };\r\n      }\r\n      \r\n      // In a real app, this would call a server endpoint to verify the code\r\n      // For development, we'll create a mock successful response\r\n      \r\n      // Generate a new token for the mobile device\r\n      const accessToken = this.generateToken();\r\n      \r\n      // Set expiry date (30 days from now for development)\r\n      const expiryDate = new Date();\r\n      expiryDate.setDate(expiryDate.getDate() + 30);\r\n      \r\n      return {\r\n        valid: true,\r\n        accessToken,\r\n        plan: 'monthly_premium', // Assume monthly plan\r\n        expiresAt: expiryDate.toISOString()\r\n      };\r\n    } catch (error) {\r\n      console.error('Code verification failed:', error);\r\n      return { valid: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear subscription data from storage\r\n   */\r\n  static clearSubscription() {\r\n    localStorage.removeItem('subscription_token');\r\n    localStorage.removeItem('subscription_expiry');\r\n    localStorage.removeItem('subscription_plan');\r\n    localStorage.removeItem('subscription_created_at');\r\n    localStorage.removeItem('subscription_validation');\r\n  }\r\n\r\n  /**\r\n   * Check if the subscription is about to expire\r\n   * @returns {boolean} True if subscription expires in less than 7 days\r\n   */\r\n  static isAboutToExpire() {\r\n    const expiryDate = localStorage.getItem('subscription_expiry');\r\n    if (!expiryDate) return false;\r\n    \r\n    const daysRemaining = this.calculateDaysRemaining(expiryDate);\r\n    return daysRemaining > 0 && daysRemaining <= 7;\r\n  }\r\n}\r\n\r\nexport default TokenizedSubscription;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}