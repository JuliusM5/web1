{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useSubscription.js\n\nimport { useState, useEffect } from 'react';\nimport { storageKeys } from '../constants/storageKeys';\n\n/**\r\n * Hook for handling subscription state in a token-based system\r\n * Without requiring user accounts\r\n */\nexport const useSubscription = () => {\n  _s();\n  const [subscription, setSubscription] = useState({\n    isSubscribed: false,\n    isLoading: true,\n    plan: null,\n    expiresAt: null\n  });\n\n  // Check subscription status on mount\n  useEffect(() => {\n    checkSubscriptionStatus();\n  }, []);\n\n  // Check subscription status based on localStorage tokens\n  const checkSubscriptionStatus = () => {\n    const token = localStorage.getItem(storageKeys.SUBSCRIPTION_TOKEN);\n    const expiryDate = localStorage.getItem(storageKeys.SUBSCRIPTION_EXPIRY);\n\n    // Not subscribed if no token or expiry date\n    if (!token || !expiryDate) {\n      setSubscription({\n        isSubscribed: false,\n        isLoading: false,\n        plan: null,\n        expiresAt: null\n      });\n      return;\n    }\n\n    // Check if subscription is expired\n    const isExpired = new Date(expiryDate) <= new Date();\n    if (isExpired) {\n      // Clear expired tokens\n      localStorage.removeItem(storageKeys.SUBSCRIPTION_TOKEN);\n      localStorage.removeItem(storageKeys.SUBSCRIPTION_EXPIRY);\n      setSubscription({\n        isSubscribed: false,\n        isLoading: false,\n        plan: null,\n        expiresAt: null\n      });\n      return;\n    }\n\n    // Valid subscription\n    // In a real implementation, you'd verify the token with your server\n    // using fetch instead of axios\n    setSubscription({\n      isSubscribed: true,\n      isLoading: false,\n      // For now, assume monthly plan - in production you'd store this info\n      plan: 'monthly_premium',\n      expiresAt: expiryDate\n    });\n  };\n\n  // Subscribe with email only (no account)\n  const purchaseSubscription = async (email, planId) => {\n    // For development, simulate a successful purchase\n    // In production, this would redirect to Stripe Checkout\n\n    return new Promise(resolve => {\n      // Simulate API delay\n      setTimeout(() => {\n        // Generate a mock token and expiry date\n        const token = 'test_token_' + Date.now();\n        const expiryDate = new Date();\n\n        // Set expiry based on plan\n        if (planId === 'yearly_premium') {\n          expiryDate.setFullYear(expiryDate.getFullYear() + 1);\n        } else {\n          expiryDate.setMonth(expiryDate.getMonth() + 1);\n        }\n\n        // Store in localStorage\n        localStorage.setItem(storageKeys.SUBSCRIPTION_TOKEN, token);\n        localStorage.setItem(storageKeys.SUBSCRIPTION_EXPIRY, expiryDate.toISOString());\n\n        // Update state\n        setSubscription({\n          isSubscribed: true,\n          isLoading: false,\n          plan: planId,\n          expiresAt: expiryDate.toISOString()\n        });\n\n        // Generate a mock mobile access code\n        const mobileAccessCode = 'DEMO-' + Math.random().toString(36).substring(2, 6).toUpperCase() + '-' + Math.random().toString(36).substring(2, 6).toUpperCase();\n        resolve({\n          success: true,\n          mobileAccessCode\n        });\n      }, 1500);\n    });\n  };\n\n  // Check if a specific premium feature is available\n  const isPremiumFeatureAvailable = featureId => {\n    var _featureMap$subscript;\n    // If not subscribed, only allow free features\n    if (!subscription.isSubscribed) {\n      const freeFeatures = ['basic_search', 'limited_alerts'];\n      return freeFeatures.includes(featureId);\n    }\n\n    // Define features available in each plan\n    const featureMap = {\n      monthly_premium: ['premium_deals', 'unlimited_alerts', 'priority_notifications', 'full_search'],\n      yearly_premium: ['premium_deals', 'unlimited_alerts', 'priority_notifications', 'full_search', 'historical_data', 'price_predictions']\n    };\n\n    // Check if feature is available in current plan\n    return ((_featureMap$subscript = featureMap[subscription.plan]) === null || _featureMap$subscript === void 0 ? void 0 : _featureMap$subscript.includes(featureId)) || false;\n  };\n\n  // Cancel subscription\n  const cancelSubscription = async () => {\n    // In production, this would call your backend to cancel in Stripe\n    // For development, just clear the local storage\n\n    return new Promise(resolve => {\n      setTimeout(() => {\n        localStorage.removeItem(storageKeys.SUBSCRIPTION_TOKEN);\n        localStorage.removeItem(storageKeys.SUBSCRIPTION_EXPIRY);\n        setSubscription({\n          isSubscribed: false,\n          isLoading: false,\n          plan: null,\n          expiresAt: null\n        });\n        resolve({\n          success: true\n        });\n      }, 1000);\n    });\n  };\n  return {\n    isSubscribed: subscription.isSubscribed,\n    isLoading: subscription.isLoading,\n    plan: subscription.plan,\n    expiresAt: subscription.expiresAt,\n    purchaseSubscription,\n    cancelSubscription,\n    refreshSubscription: checkSubscriptionStatus,\n    isPremiumFeatureAvailable\n  };\n};\n_s(useSubscription, \"jIZu6G1h34v5p7MFKNDnxD2Irbs=\");\nexport default useSubscription;","map":{"version":3,"names":["useState","useEffect","storageKeys","useSubscription","_s","subscription","setSubscription","isSubscribed","isLoading","plan","expiresAt","checkSubscriptionStatus","token","localStorage","getItem","SUBSCRIPTION_TOKEN","expiryDate","SUBSCRIPTION_EXPIRY","isExpired","Date","removeItem","purchaseSubscription","email","planId","Promise","resolve","setTimeout","now","setFullYear","getFullYear","setMonth","getMonth","setItem","toISOString","mobileAccessCode","Math","random","toString","substring","toUpperCase","success","isPremiumFeatureAvailable","featureId","_featureMap$subscript","freeFeatures","includes","featureMap","monthly_premium","yearly_premium","cancelSubscription","refreshSubscription"],"sources":["C:/Users/juliu/Desktop/web/src/hooks/useSubscription.js"],"sourcesContent":["// src/hooks/useSubscription.js\r\n\r\nimport { useState, useEffect } from 'react';\r\nimport { storageKeys } from '../constants/storageKeys';\r\n\r\n/**\r\n * Hook for handling subscription state in a token-based system\r\n * Without requiring user accounts\r\n */\r\nexport const useSubscription = () => {\r\n  const [subscription, setSubscription] = useState({\r\n    isSubscribed: false,\r\n    isLoading: true,\r\n    plan: null,\r\n    expiresAt: null\r\n  });\r\n\r\n  // Check subscription status on mount\r\n  useEffect(() => {\r\n    checkSubscriptionStatus();\r\n  }, []);\r\n\r\n  // Check subscription status based on localStorage tokens\r\n  const checkSubscriptionStatus = () => {\r\n    const token = localStorage.getItem(storageKeys.SUBSCRIPTION_TOKEN);\r\n    const expiryDate = localStorage.getItem(storageKeys.SUBSCRIPTION_EXPIRY);\r\n    \r\n    // Not subscribed if no token or expiry date\r\n    if (!token || !expiryDate) {\r\n      setSubscription({\r\n        isSubscribed: false,\r\n        isLoading: false,\r\n        plan: null,\r\n        expiresAt: null\r\n      });\r\n      return;\r\n    }\r\n    \r\n    // Check if subscription is expired\r\n    const isExpired = new Date(expiryDate) <= new Date();\r\n    \r\n    if (isExpired) {\r\n      // Clear expired tokens\r\n      localStorage.removeItem(storageKeys.SUBSCRIPTION_TOKEN);\r\n      localStorage.removeItem(storageKeys.SUBSCRIPTION_EXPIRY);\r\n      \r\n      setSubscription({\r\n        isSubscribed: false,\r\n        isLoading: false,\r\n        plan: null,\r\n        expiresAt: null\r\n      });\r\n      return;\r\n    }\r\n    \r\n    // Valid subscription\r\n    // In a real implementation, you'd verify the token with your server\r\n    // using fetch instead of axios\r\n    setSubscription({\r\n      isSubscribed: true,\r\n      isLoading: false,\r\n      // For now, assume monthly plan - in production you'd store this info\r\n      plan: 'monthly_premium',\r\n      expiresAt: expiryDate\r\n    });\r\n  };\r\n\r\n  // Subscribe with email only (no account)\r\n  const purchaseSubscription = async (email, planId) => {\r\n    // For development, simulate a successful purchase\r\n    // In production, this would redirect to Stripe Checkout\r\n    \r\n    return new Promise((resolve) => {\r\n      // Simulate API delay\r\n      setTimeout(() => {\r\n        // Generate a mock token and expiry date\r\n        const token = 'test_token_' + Date.now();\r\n        const expiryDate = new Date();\r\n        \r\n        // Set expiry based on plan\r\n        if (planId === 'yearly_premium') {\r\n          expiryDate.setFullYear(expiryDate.getFullYear() + 1);\r\n        } else {\r\n          expiryDate.setMonth(expiryDate.getMonth() + 1);\r\n        }\r\n        \r\n        // Store in localStorage\r\n        localStorage.setItem(storageKeys.SUBSCRIPTION_TOKEN, token);\r\n        localStorage.setItem(storageKeys.SUBSCRIPTION_EXPIRY, expiryDate.toISOString());\r\n        \r\n        // Update state\r\n        setSubscription({\r\n          isSubscribed: true,\r\n          isLoading: false,\r\n          plan: planId,\r\n          expiresAt: expiryDate.toISOString()\r\n        });\r\n        \r\n        // Generate a mock mobile access code\r\n        const mobileAccessCode = 'DEMO-' + Math.random().toString(36).substring(2, 6).toUpperCase() + '-' + \r\n                                Math.random().toString(36).substring(2, 6).toUpperCase();\r\n        \r\n        resolve({ \r\n          success: true, \r\n          mobileAccessCode \r\n        });\r\n      }, 1500);\r\n    });\r\n  };\r\n\r\n  // Check if a specific premium feature is available\r\n  const isPremiumFeatureAvailable = (featureId) => {\r\n    // If not subscribed, only allow free features\r\n    if (!subscription.isSubscribed) {\r\n      const freeFeatures = ['basic_search', 'limited_alerts'];\r\n      return freeFeatures.includes(featureId);\r\n    }\r\n    \r\n    // Define features available in each plan\r\n    const featureMap = {\r\n      monthly_premium: [\r\n        'premium_deals',\r\n        'unlimited_alerts',\r\n        'priority_notifications',\r\n        'full_search',\r\n      ],\r\n      yearly_premium: [\r\n        'premium_deals',\r\n        'unlimited_alerts', \r\n        'priority_notifications',\r\n        'full_search',\r\n        'historical_data',\r\n        'price_predictions'\r\n      ]\r\n    };\r\n    \r\n    // Check if feature is available in current plan\r\n    return featureMap[subscription.plan]?.includes(featureId) || false;\r\n  };\r\n\r\n  // Cancel subscription\r\n  const cancelSubscription = async () => {\r\n    // In production, this would call your backend to cancel in Stripe\r\n    // For development, just clear the local storage\r\n    \r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        localStorage.removeItem(storageKeys.SUBSCRIPTION_TOKEN);\r\n        localStorage.removeItem(storageKeys.SUBSCRIPTION_EXPIRY);\r\n        \r\n        setSubscription({\r\n          isSubscribed: false,\r\n          isLoading: false,\r\n          plan: null,\r\n          expiresAt: null\r\n        });\r\n        \r\n        resolve({ success: true });\r\n      }, 1000);\r\n    });\r\n  };\r\n\r\n  return {\r\n    isSubscribed: subscription.isSubscribed,\r\n    isLoading: subscription.isLoading,\r\n    plan: subscription.plan,\r\n    expiresAt: subscription.expiresAt,\r\n    purchaseSubscription,\r\n    cancelSubscription,\r\n    refreshSubscription: checkSubscriptionStatus,\r\n    isPremiumFeatureAvailable\r\n  };\r\n};\r\n\r\nexport default useSubscription;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}