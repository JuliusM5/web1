{"ast":null,"code":"// src/services/skyscannerService.js\n\nimport { storageKeys } from '../constants/storageKeys';\nclass SkyScannerService {\n  constructor() {\n    this.apiKey = '708645c7a0msh8860ff1168af435p1420a8jsn8f2730758a25'; // Your RapidAPI key\n    this.apiHost = 'skyscanner89.p.rapidapi.com';\n    this.baseUrl = 'https://skyscanner89.p.rapidapi.com';\n    this.requestQueue = [];\n    this.isProcessingQueue = false;\n    this.requestsThisSecond = 0;\n    this.lastRequestTime = Date.now();\n    this.MAX_REQUESTS_PER_SECOND = 5; // Setting conservative rate limit\n\n    // Advanced caching\n    this.cache = new Map();\n    this.CACHE_EXPIRY = 3600000; // 1 hour cache\n  }\n\n  // Search for one-way flights\n  async searchOneWayFlights(origin, destination, originId, destinationId) {\n    const cacheKey = `oneway-${origin}-${destination}-${originId}-${destinationId}`;\n\n    // Check cache first to reduce API calls\n    const cachedResult = this.getFromCache(cacheKey);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    // Queue the request\n    return new Promise((resolve, reject) => {\n      this.addToQueue({\n        endpoint: `/flights/one-way/list`,\n        params: {\n          origin,\n          destination,\n          originId,\n          destinationId\n        },\n        resolve,\n        reject,\n        cacheKey\n      });\n    });\n  }\n\n  // Location autocomplete - for searching airports/cities\n  async locationAutocomplete(query) {\n    const cacheKey = `location-${query}`;\n\n    // Check cache first\n    const cachedResult = this.getFromCache(cacheKey);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    // Queue the request\n    return new Promise((resolve, reject) => {\n      this.addToQueue({\n        endpoint: `/locations/search`,\n        params: {\n          query\n        },\n        resolve,\n        reject,\n        cacheKey\n      });\n    });\n  }\n  getFromCache(key) {\n    if (this.cache.has(key)) {\n      const {\n        data,\n        timestamp\n      } = this.cache.get(key);\n      // Check if cache is still valid\n      if (Date.now() - timestamp < this.CACHE_EXPIRY) {\n        return Promise.resolve(data);\n      }\n      this.cache.delete(key); // Expired, remove it\n    }\n    return null;\n  }\n  addToCache(key, data) {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n\n    // Also persist to localStorage for offline access\n    try {\n      const cachedData = JSON.parse(localStorage.getItem(storageKeys.FLIGHT_CACHE) || '{}');\n      cachedData[key] = {\n        data,\n        timestamp: Date.now()\n      };\n      localStorage.setItem(storageKeys.FLIGHT_CACHE, JSON.stringify(cachedData));\n    } catch (error) {\n      console.error('Error saving to localStorage:', error);\n    }\n  }\n  addToQueue(request) {\n    this.requestQueue.push(request);\n    if (!this.isProcessingQueue) {\n      this.processQueue();\n    }\n  }\n  async processQueue() {\n    if (this.requestQueue.length === 0) {\n      this.isProcessingQueue = false;\n      return;\n    }\n    this.isProcessingQueue = true;\n\n    // Respect rate limits\n    const now = Date.now();\n    const timeElapsed = now - this.lastRequestTime;\n    if (timeElapsed < 1000) {\n      // Within the same second\n      if (this.requestsThisSecond >= this.MAX_REQUESTS_PER_SECOND) {\n        // Wait until the next second starts\n        await new Promise(resolve => setTimeout(resolve, 1000 - timeElapsed));\n        this.requestsThisSecond = 0;\n      }\n    } else {\n      // Reset counter for new second\n      this.requestsThisSecond = 0;\n    }\n\n    // Process the next request\n    const request = this.requestQueue.shift();\n    this.requestsThisSecond++;\n    this.lastRequestTime = Date.now();\n    try {\n      // Build URL with query parameters\n      const url = new URL(`${this.baseUrl}${request.endpoint}`);\n      if (request.params) {\n        Object.keys(request.params).forEach(key => url.searchParams.append(key, request.params[key]));\n      }\n\n      // Make the request with RapidAPI headers\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'x-rapidapi-host': this.apiHost,\n          'x-rapidapi-key': this.apiKey\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Cache successful response\n      if (request.cacheKey) {\n        this.addToCache(request.cacheKey, data);\n      }\n      request.resolve(data);\n    } catch (error) {\n      console.error('Error making RapidAPI request:', error);\n      request.reject(error);\n    }\n\n    // Continue processing queue\n    this.processQueue();\n  }\n\n  // Method to preload common routes to minimize API calls\n  async preloadPopularRoutes(popularRoutes) {\n    console.log('Preloading popular routes to minimize API calls...');\n    const preloadPromises = popularRoutes.map(route => this.searchOneWayFlights(route.origin, route.destination, route.originId, route.destinationId).catch(err => {\n      // Silently fail - this is just preloading\n      console.warn(`Failed to preload route ${route.origin} to ${route.destination}:`, err);\n      return null;\n    }));\n    await Promise.allSettled(preloadPromises);\n    console.log('Preloading complete');\n  }\n}\nexport default new SkyScannerService();","map":{"version":3,"names":["storageKeys","SkyScannerService","constructor","apiKey","apiHost","baseUrl","requestQueue","isProcessingQueue","requestsThisSecond","lastRequestTime","Date","now","MAX_REQUESTS_PER_SECOND","cache","Map","CACHE_EXPIRY","searchOneWayFlights","origin","destination","originId","destinationId","cacheKey","cachedResult","getFromCache","Promise","resolve","reject","addToQueue","endpoint","params","locationAutocomplete","query","key","has","data","timestamp","get","delete","addToCache","set","cachedData","JSON","parse","localStorage","getItem","FLIGHT_CACHE","setItem","stringify","error","console","request","push","processQueue","length","timeElapsed","setTimeout","shift","url","URL","Object","keys","forEach","searchParams","append","response","fetch","method","headers","ok","Error","status","json","preloadPopularRoutes","popularRoutes","log","preloadPromises","map","route","catch","err","warn","allSettled"],"sources":["C:/Users/juliu/Desktop/web/src/services/skyscannerService.js"],"sourcesContent":["// src/services/skyscannerService.js\r\n\r\nimport { storageKeys } from '../constants/storageKeys';\r\n\r\nclass SkyScannerService {\r\n  constructor() {\r\n    this.apiKey = '708645c7a0msh8860ff1168af435p1420a8jsn8f2730758a25'; // Your RapidAPI key\r\n    this.apiHost = 'skyscanner89.p.rapidapi.com';\r\n    this.baseUrl = 'https://skyscanner89.p.rapidapi.com';\r\n    this.requestQueue = [];\r\n    this.isProcessingQueue = false;\r\n    this.requestsThisSecond = 0;\r\n    this.lastRequestTime = Date.now();\r\n    this.MAX_REQUESTS_PER_SECOND = 5; // Setting conservative rate limit\r\n    \r\n    // Advanced caching\r\n    this.cache = new Map();\r\n    this.CACHE_EXPIRY = 3600000; // 1 hour cache\r\n  }\r\n\r\n  // Search for one-way flights\r\n  async searchOneWayFlights(origin, destination, originId, destinationId) {\r\n    const cacheKey = `oneway-${origin}-${destination}-${originId}-${destinationId}`;\r\n    \r\n    // Check cache first to reduce API calls\r\n    const cachedResult = this.getFromCache(cacheKey);\r\n    if (cachedResult) {\r\n      return cachedResult;\r\n    }\r\n    \r\n    // Queue the request\r\n    return new Promise((resolve, reject) => {\r\n      this.addToQueue({\r\n        endpoint: `/flights/one-way/list`,\r\n        params: { origin, destination, originId, destinationId },\r\n        resolve,\r\n        reject,\r\n        cacheKey\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Location autocomplete - for searching airports/cities\r\n  async locationAutocomplete(query) {\r\n    const cacheKey = `location-${query}`;\r\n    \r\n    // Check cache first\r\n    const cachedResult = this.getFromCache(cacheKey);\r\n    if (cachedResult) {\r\n      return cachedResult;\r\n    }\r\n    \r\n    // Queue the request\r\n    return new Promise((resolve, reject) => {\r\n      this.addToQueue({\r\n        endpoint: `/locations/search`,\r\n        params: { query },\r\n        resolve,\r\n        reject,\r\n        cacheKey\r\n      });\r\n    });\r\n  }\r\n  \r\n  getFromCache(key) {\r\n    if (this.cache.has(key)) {\r\n      const { data, timestamp } = this.cache.get(key);\r\n      // Check if cache is still valid\r\n      if (Date.now() - timestamp < this.CACHE_EXPIRY) {\r\n        return Promise.resolve(data);\r\n      }\r\n      this.cache.delete(key); // Expired, remove it\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  addToCache(key, data) {\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    // Also persist to localStorage for offline access\r\n    try {\r\n      const cachedData = JSON.parse(localStorage.getItem(storageKeys.FLIGHT_CACHE) || '{}');\r\n      cachedData[key] = {\r\n        data,\r\n        timestamp: Date.now()\r\n      };\r\n      localStorage.setItem(storageKeys.FLIGHT_CACHE, JSON.stringify(cachedData));\r\n    } catch (error) {\r\n      console.error('Error saving to localStorage:', error);\r\n    }\r\n  }\r\n\r\n  addToQueue(request) {\r\n    this.requestQueue.push(request);\r\n    if (!this.isProcessingQueue) {\r\n      this.processQueue();\r\n    }\r\n  }\r\n\r\n  async processQueue() {\r\n    if (this.requestQueue.length === 0) {\r\n      this.isProcessingQueue = false;\r\n      return;\r\n    }\r\n    \r\n    this.isProcessingQueue = true;\r\n    \r\n    // Respect rate limits\r\n    const now = Date.now();\r\n    const timeElapsed = now - this.lastRequestTime;\r\n    \r\n    if (timeElapsed < 1000) { // Within the same second\r\n      if (this.requestsThisSecond >= this.MAX_REQUESTS_PER_SECOND) {\r\n        // Wait until the next second starts\r\n        await new Promise(resolve => setTimeout(resolve, 1000 - timeElapsed));\r\n        this.requestsThisSecond = 0;\r\n      }\r\n    } else {\r\n      // Reset counter for new second\r\n      this.requestsThisSecond = 0;\r\n    }\r\n    \r\n    // Process the next request\r\n    const request = this.requestQueue.shift();\r\n    this.requestsThisSecond++;\r\n    this.lastRequestTime = Date.now();\r\n    \r\n    try {\r\n      // Build URL with query parameters\r\n      const url = new URL(`${this.baseUrl}${request.endpoint}`);\r\n      \r\n      if (request.params) {\r\n        Object.keys(request.params).forEach(key => \r\n          url.searchParams.append(key, request.params[key])\r\n        );\r\n      }\r\n      \r\n      // Make the request with RapidAPI headers\r\n      const response = await fetch(url, {\r\n        method: 'GET',\r\n        headers: {\r\n          'x-rapidapi-host': this.apiHost,\r\n          'x-rapidapi-key': this.apiKey\r\n        }\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API error: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      \r\n      // Cache successful response\r\n      if (request.cacheKey) {\r\n        this.addToCache(request.cacheKey, data);\r\n      }\r\n      \r\n      request.resolve(data);\r\n    } catch (error) {\r\n      console.error('Error making RapidAPI request:', error);\r\n      request.reject(error);\r\n    }\r\n    \r\n    // Continue processing queue\r\n    this.processQueue();\r\n  }\r\n  \r\n  // Method to preload common routes to minimize API calls\r\n  async preloadPopularRoutes(popularRoutes) {\r\n    console.log('Preloading popular routes to minimize API calls...');\r\n    const preloadPromises = popularRoutes.map(route => \r\n      this.searchOneWayFlights(\r\n        route.origin, \r\n        route.destination, \r\n        route.originId, \r\n        route.destinationId\r\n      ).catch(err => {\r\n        // Silently fail - this is just preloading\r\n        console.warn(`Failed to preload route ${route.origin} to ${route.destination}:`, err);\r\n        return null;\r\n      })\r\n    );\r\n    \r\n    await Promise.allSettled(preloadPromises);\r\n    console.log('Preloading complete');\r\n  }\r\n}\r\n\r\nexport default new SkyScannerService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}