{"ast":null,"code":"// src/services/SubscriptionService.js\n// Simplified subscription service without external dependencies\n\nimport dataProvider from '../data/dataProvider';\nimport stripeService from './stripeService';\nimport analyticsService from './analyticsService';\nimport { captureError } from '../utils/errorMonitoring';\nclass SubscriptionService {\n  constructor() {\n    this.currentSubscription = null;\n    this.deviceId = this.getOrCreateDeviceId();\n  }\n\n  // Get or create a unique device ID for this browser\n  getOrCreateDeviceId() {\n    let deviceId = localStorage.getItem('deviceId');\n    if (!deviceId) {\n      deviceId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n      localStorage.setItem('deviceId', deviceId);\n    }\n    return deviceId;\n  }\n\n  // Create a new subscription using Stripe\n  async createSubscription(planId, paymentMethodId) {\n    try {\n      // Create a subscription with Stripe (or mock it for testing)\n      const stripeSubscription = paymentMethodId ? await stripeService.createSubscription(paymentMethodId, planId) : stripeService.mockCreateSubscription(planId);\n\n      // Generate a unique access code\n      const accessCode = this.generateAccessCode();\n\n      // Store the subscription in our database\n      const subscription = await dataProvider.createSubscription({\n        accessCode,\n        platform: 'web',\n        originalTransactionId: stripeSubscription.id,\n        status: 'active',\n        expiresAt: new Date(stripeSubscription.current_period_end * 1000).toISOString(),\n        planId,\n        deviceId: this.deviceId,\n        activations: [{\n          deviceId: this.deviceId,\n          platform: 'web',\n          activatedAt: new Date().toISOString()\n        }]\n      });\n\n      // Set as current subscription\n      this.currentSubscription = subscription;\n      localStorage.setItem('accessCode', accessCode);\n\n      // Track the subscription event\n      analyticsService.trackSubscriptionStarted(planId, stripeSubscription.plan.amount / 100, 'web');\n      return subscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Creating subscription'\n      });\n      throw error;\n    }\n  }\n\n  // Activate a subscription using an access code\n  async activateWithCode(accessCode) {\n    try {\n      // Check if the code is valid\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\n      if (!subscription) {\n        throw new Error('Invalid access code');\n      }\n      if (subscription.status !== 'active') {\n        throw new Error('Subscription is not active');\n      }\n\n      // If the subscription has an expiration date, check if it's expired\n      if (subscription.expiresAt) {\n        const expiresAt = new Date(subscription.expiresAt);\n        if (expiresAt < new Date()) {\n          await dataProvider.updateSubscription(accessCode, {\n            status: 'expired'\n          });\n          throw new Error('Subscription has expired');\n        }\n      }\n\n      // Activate the subscription on this device\n      const activatedSubscription = await dataProvider.activateSubscriptionOnDevice(accessCode, this.deviceId, 'web');\n\n      // Set as current subscription\n      this.currentSubscription = activatedSubscription;\n      localStorage.setItem('accessCode', accessCode);\n\n      // Track code activation\n      const daysRemaining = Math.ceil((new Date(subscription.expiresAt) - new Date()) / (1000 * 60 * 60 * 24));\n      analyticsService.trackCodeActivated('web', daysRemaining);\n      return activatedSubscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Activating subscription with code'\n      });\n      throw error;\n    }\n  }\n\n  // Cancel a subscription\n  async cancelSubscription() {\n    try {\n      if (!this.currentSubscription) {\n        throw new Error('No active subscription');\n      }\n\n      // Cancel with Stripe if it's a web subscription\n      if (this.currentSubscription.platform === 'web' && this.currentSubscription.originalTransactionId) {\n        await stripeService.cancelSubscription(this.currentSubscription.originalTransactionId);\n      }\n\n      // Update subscription status in database\n      const updatedSubscription = await dataProvider.updateSubscription(this.currentSubscription.accessCode, {\n        status: 'cancelled'\n      });\n\n      // Track cancellation\n      const createdAt = new Date(this.currentSubscription.createdAt);\n      const daysSinceSubscribed = Math.floor((new Date() - createdAt) / (1000 * 60 * 60 * 24));\n      analyticsService.trackSubscriptionCancelled(this.currentSubscription.planId, 'user_initiated', daysSinceSubscribed);\n\n      // Clear current subscription\n      this.currentSubscription = null;\n      localStorage.removeItem('accessCode');\n      return updatedSubscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Cancelling subscription'\n      });\n      throw error;\n    }\n  }\n\n  // Check current subscription status\n  async checkSubscription() {\n    try {\n      const accessCode = localStorage.getItem('accessCode');\n      if (!accessCode) {\n        return null;\n      }\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\n      if (!subscription || subscription.status !== 'active') {\n        localStorage.removeItem('accessCode');\n        this.currentSubscription = null;\n        return null;\n      }\n\n      // Check if subscription is expired\n      if (subscription.expiresAt) {\n        const expiresAt = new Date(subscription.expiresAt);\n        if (expiresAt < new Date()) {\n          // Update subscription status to expired\n          await dataProvider.updateSubscription(accessCode, {\n            status: 'expired'\n          });\n          localStorage.removeItem('accessCode');\n          this.currentSubscription = null;\n          return null;\n        }\n      }\n      this.currentSubscription = subscription;\n      return subscription;\n    } catch (error) {\n      captureError(error, {\n        context: 'Checking subscription'\n      });\n      // Return null instead of throwing, to prevent app crashes on status checks\n      return null;\n    }\n  }\n\n  // Check if a specific feature is available with the current subscription\n  async isFeatureAvailable(featureName) {\n    try {\n      const subscription = await this.checkSubscription();\n      if (!subscription) {\n        return false;\n      }\n\n      // In a real implementation, you would check if the specific plan includes this feature\n      // For now, we'll assume all subscriptions include all premium features\n\n      // Track premium feature usage\n      analyticsService.trackPremiumFeatureUsed(featureName);\n      return true;\n    } catch (error) {\n      captureError(error, {\n        context: 'Checking feature availability'\n      });\n      return false;\n    }\n  }\n\n  // Get current subscription\n  async getCurrentSubscription() {\n    return await this.checkSubscription();\n  }\n\n  // Generate a random access code (format: XXXX-XXXX-XXXX)\n  generateAccessCode() {\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\n    let code = '';\n    for (let i = 0; i < 12; i++) {\n      if (i === 4 || i === 8) {\n        code += '-';\n      }\n      code += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return code;\n  }\n}\nexport default new SubscriptionService();","map":{"version":3,"names":["dataProvider","stripeService","analyticsService","captureError","SubscriptionService","constructor","currentSubscription","deviceId","getOrCreateDeviceId","localStorage","getItem","Math","random","toString","substring","setItem","createSubscription","planId","paymentMethodId","stripeSubscription","mockCreateSubscription","accessCode","generateAccessCode","subscription","platform","originalTransactionId","id","status","expiresAt","Date","current_period_end","toISOString","activations","activatedAt","trackSubscriptionStarted","plan","amount","error","context","activateWithCode","getSubscriptionByAccessCode","Error","updateSubscription","activatedSubscription","activateSubscriptionOnDevice","daysRemaining","ceil","trackCodeActivated","cancelSubscription","updatedSubscription","createdAt","daysSinceSubscribed","floor","trackSubscriptionCancelled","removeItem","checkSubscription","isFeatureAvailable","featureName","trackPremiumFeatureUsed","getCurrentSubscription","chars","code","i","charAt","length"],"sources":["C:/Users/juliu/Desktop/web/src/services/SubscriptionService.js"],"sourcesContent":["// src/services/SubscriptionService.js\r\n// Simplified subscription service without external dependencies\r\n\r\nimport dataProvider from '../data/dataProvider';\r\nimport stripeService from './stripeService';\r\nimport analyticsService from './analyticsService';\r\nimport { captureError } from '../utils/errorMonitoring';\r\n\r\nclass SubscriptionService {\r\n  constructor() {\r\n    this.currentSubscription = null;\r\n    this.deviceId = this.getOrCreateDeviceId();\r\n  }\r\n\r\n  // Get or create a unique device ID for this browser\r\n  getOrCreateDeviceId() {\r\n    let deviceId = localStorage.getItem('deviceId');\r\n    if (!deviceId) {\r\n      deviceId = Math.random().toString(36).substring(2, 15) + \r\n                Math.random().toString(36).substring(2, 15);\r\n      localStorage.setItem('deviceId', deviceId);\r\n    }\r\n    return deviceId;\r\n  }\r\n\r\n  // Create a new subscription using Stripe\r\n  async createSubscription(planId, paymentMethodId) {\r\n    try {\r\n      // Create a subscription with Stripe (or mock it for testing)\r\n      const stripeSubscription = paymentMethodId \r\n        ? await stripeService.createSubscription(paymentMethodId, planId)\r\n        : stripeService.mockCreateSubscription(planId);\r\n      \r\n      // Generate a unique access code\r\n      const accessCode = this.generateAccessCode();\r\n      \r\n      // Store the subscription in our database\r\n      const subscription = await dataProvider.createSubscription({\r\n        accessCode,\r\n        platform: 'web',\r\n        originalTransactionId: stripeSubscription.id,\r\n        status: 'active',\r\n        expiresAt: new Date(stripeSubscription.current_period_end * 1000).toISOString(),\r\n        planId,\r\n        deviceId: this.deviceId,\r\n        activations: [\r\n          {\r\n            deviceId: this.deviceId,\r\n            platform: 'web',\r\n            activatedAt: new Date().toISOString()\r\n          }\r\n        ]\r\n      });\r\n      \r\n      // Set as current subscription\r\n      this.currentSubscription = subscription;\r\n      localStorage.setItem('accessCode', accessCode);\r\n      \r\n      // Track the subscription event\r\n      analyticsService.trackSubscriptionStarted(\r\n        planId, \r\n        stripeSubscription.plan.amount / 100,\r\n        'web'\r\n      );\r\n      \r\n      return subscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Creating subscription' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Activate a subscription using an access code\r\n  async activateWithCode(accessCode) {\r\n    try {\r\n      // Check if the code is valid\r\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription) {\r\n        throw new Error('Invalid access code');\r\n      }\r\n      \r\n      if (subscription.status !== 'active') {\r\n        throw new Error('Subscription is not active');\r\n      }\r\n      \r\n      // If the subscription has an expiration date, check if it's expired\r\n      if (subscription.expiresAt) {\r\n        const expiresAt = new Date(subscription.expiresAt);\r\n        if (expiresAt < new Date()) {\r\n          await dataProvider.updateSubscription(accessCode, { status: 'expired' });\r\n          throw new Error('Subscription has expired');\r\n        }\r\n      }\r\n      \r\n      // Activate the subscription on this device\r\n      const activatedSubscription = await dataProvider.activateSubscriptionOnDevice(\r\n        accessCode,\r\n        this.deviceId,\r\n        'web'\r\n      );\r\n      \r\n      // Set as current subscription\r\n      this.currentSubscription = activatedSubscription;\r\n      localStorage.setItem('accessCode', accessCode);\r\n      \r\n      // Track code activation\r\n      const daysRemaining = Math.ceil(\r\n        (new Date(subscription.expiresAt) - new Date()) / (1000 * 60 * 60 * 24)\r\n      );\r\n      analyticsService.trackCodeActivated('web', daysRemaining);\r\n      \r\n      return activatedSubscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Activating subscription with code' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Cancel a subscription\r\n  async cancelSubscription() {\r\n    try {\r\n      if (!this.currentSubscription) {\r\n        throw new Error('No active subscription');\r\n      }\r\n      \r\n      // Cancel with Stripe if it's a web subscription\r\n      if (this.currentSubscription.platform === 'web' && \r\n          this.currentSubscription.originalTransactionId) {\r\n        await stripeService.cancelSubscription(this.currentSubscription.originalTransactionId);\r\n      }\r\n      \r\n      // Update subscription status in database\r\n      const updatedSubscription = await dataProvider.updateSubscription(\r\n        this.currentSubscription.accessCode,\r\n        { status: 'cancelled' }\r\n      );\r\n      \r\n      // Track cancellation\r\n      const createdAt = new Date(this.currentSubscription.createdAt);\r\n      const daysSinceSubscribed = Math.floor(\r\n        (new Date() - createdAt) / (1000 * 60 * 60 * 24)\r\n      );\r\n      \r\n      analyticsService.trackSubscriptionCancelled(\r\n        this.currentSubscription.planId,\r\n        'user_initiated',\r\n        daysSinceSubscribed\r\n      );\r\n      \r\n      // Clear current subscription\r\n      this.currentSubscription = null;\r\n      localStorage.removeItem('accessCode');\r\n      \r\n      return updatedSubscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Cancelling subscription' });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Check current subscription status\r\n  async checkSubscription() {\r\n    try {\r\n      const accessCode = localStorage.getItem('accessCode');\r\n      \r\n      if (!accessCode) {\r\n        return null;\r\n      }\r\n      \r\n      const subscription = await dataProvider.getSubscriptionByAccessCode(accessCode);\r\n      \r\n      if (!subscription || subscription.status !== 'active') {\r\n        localStorage.removeItem('accessCode');\r\n        this.currentSubscription = null;\r\n        return null;\r\n      }\r\n      \r\n      // Check if subscription is expired\r\n      if (subscription.expiresAt) {\r\n        const expiresAt = new Date(subscription.expiresAt);\r\n        if (expiresAt < new Date()) {\r\n          // Update subscription status to expired\r\n          await dataProvider.updateSubscription(accessCode, { status: 'expired' });\r\n          localStorage.removeItem('accessCode');\r\n          this.currentSubscription = null;\r\n          return null;\r\n        }\r\n      }\r\n      \r\n      this.currentSubscription = subscription;\r\n      return subscription;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Checking subscription' });\r\n      // Return null instead of throwing, to prevent app crashes on status checks\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Check if a specific feature is available with the current subscription\r\n  async isFeatureAvailable(featureName) {\r\n    try {\r\n      const subscription = await this.checkSubscription();\r\n      \r\n      if (!subscription) {\r\n        return false;\r\n      }\r\n      \r\n      // In a real implementation, you would check if the specific plan includes this feature\r\n      // For now, we'll assume all subscriptions include all premium features\r\n      \r\n      // Track premium feature usage\r\n      analyticsService.trackPremiumFeatureUsed(featureName);\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      captureError(error, { context: 'Checking feature availability' });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Get current subscription\r\n  async getCurrentSubscription() {\r\n    return await this.checkSubscription();\r\n  }\r\n\r\n  // Generate a random access code (format: XXXX-XXXX-XXXX)\r\n  generateAccessCode() {\r\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\r\n    let code = '';\r\n    \r\n    for (let i = 0; i < 12; i++) {\r\n      if (i === 4 || i === 8) {\r\n        code += '-';\r\n      }\r\n      code += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    \r\n    return code;\r\n  }\r\n}\r\n\r\nexport default new SubscriptionService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}